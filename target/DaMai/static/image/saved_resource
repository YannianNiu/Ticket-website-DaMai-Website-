define("base", ['util',"attribute"], function(require) {
var utilBase = require('util');
var attribute = require("attribute");
//! Copyright 2015, base@6.1.0 MIT Licensed, build time: Thu, 29 Oct 2015 07:02:07 GMT 
/*
combined modules:
base
base/lib/base
*/
var baseLibBase, baseIndex;
baseLibBase = function (exports) {
  /**!
   * @ignore
   * KISSY Class System
   * @author yiminghe@gmail.com
   */
  var util = utilBase;
  var Attribute = attribute;
  var ucfirst = util.ucfirst, ON_SET = '_onSet', noop = util.noop;
  function __getHook(method, reverse) {
    return function (origFn) {
      return function wrap() {
        var self = this;
        if (reverse) {
          if (origFn !== noop) {
            origFn.apply(self, arguments);
          }
        } else {
          self.callSuper.apply(self, arguments);
        }
        // can not use wrap in old ie
        /*jshint noarg: false*/
        var extensions = arguments.callee.__owner__.__extensions__ || [];
        if (reverse) {
          extensions.reverse();
        }
        callExtensionsMethod(self, extensions, method, arguments);
        if (reverse) {
          self.callSuper.apply(self, arguments);
        } else {
          if (origFn !== noop) {
            origFn.apply(self, arguments);
          }
        }
      };
    };
  }
  //noinspection JSValidateJSDoc
  /**
   * @class Base
   * @mixins base
   *
   * A base class which objects requiring bases, extension, plugin, custom event support can
   * extend.
   * bases configured
   * through the static {@link Base#static-ATTRS} property for each class
   * in the hierarchy will be initialized by Base.
   */
  var Base = Attribute.extend({
    constructor: function () {
      var self = this;
      self.callSuper.apply(self, arguments);
      // setup listeners
      var listeners = self.get('listeners');
      if (listeners) {
        for (var n in listeners) {
          self.on(n, listeners[n]);
        }
      }
      // initializer
      self.initializer();
      // call plugins
      constructPlugins(self);
      callPluginsMethod.call(self, 'pluginInitializer');
      // bind attr change
      self.bindInternal();
      // sync attr
      self.syncInternal();
    },
    initializer: noop,
    __getHook: __getHook,
    __callPluginsMethod: callPluginsMethod,
    /**
     * bind base change event
     * @protected
     */
    bindInternal: function () {
      var self = this, attrs = self.getAttrs(), attr, m;
      for (attr in attrs) {
        m = ON_SET + ucfirst(attr);
        if (self[m]) {
          // 自动绑定事件到对应函数
          self.on('after' + ucfirst(attr) + 'Change', onSetAttrChange);
        }
      }
    },
    /**
     * sync base change event
     * @protected
     */
    syncInternal: function () {
      var self = this, cs = [], i, c = self.constructor, attrs = self.getAttrs();
      while (c) {
        cs.push(c);
        c = c.superclass && c.superclass.constructor;
      }
      cs.reverse();
      // from super class to sub class
      for (i = 0; i < cs.length; i++) {
        var ATTRS = cs[i].ATTRS || {};
        for (var baseName in ATTRS) {
          if (baseName in attrs) {
            var baseValue, onSetMethod;
            var onSetMethodName = ON_SET + ucfirst(baseName);
            // 存在方法，并且用户设置了初始值或者存在默认值，就同步状态
            if ((onSetMethod = self[onSetMethodName]) && // 用户如果设置了显式不同步，就不同步，
              // 比如一些值从 html 中读取，不需要同步再次设置
              attrs[baseName].sync !== 0 && (baseValue = self.get(baseName)) !== undefined) {
              onSetMethod.call(self, baseValue);
            }
          }
        }
      }
    },
    /**
     * plugin a new plugins to current instance
     * @param {Function|Object} plugin
     * @chainable
     */
    plug: function (plugin) {
      var self = this;
      if (typeof plugin === 'function') {
        var Plugin = plugin;
        plugin = new Plugin();
      }
      // initialize plugin
      //noinspection JSUnresolvedVariable
      if (plugin.pluginInitializer) {
        // noinspection JSUnresolvedFunction
        plugin.pluginInitializer(self);
      }
      self.get('plugins').push(plugin);
      return self;
    },
    /**
     * unplug by pluginId or plugin instance.
     * if called with no parameter, then destroy all plugins.
     * @param {Object|String} [plugin]
     * @chainable
     */
    unplug: function (plugin) {
      var plugins = [], self = this, isString = typeof plugin === 'string';
      util.each(self.get('plugins'), function (p) {
        var keep = 0, pluginId;
        if (plugin) {
          if (isString) {
            // user defined takes priority
            pluginId = p.get && p.get('pluginId') || p.pluginId;
            if (pluginId !== plugin) {
              plugins.push(p);
              keep = 1;
            }
          } else {
            if (p !== plugin) {
              plugins.push(p);
              keep = 1;
            }
          }
        }
        if (!keep) {
          p.pluginDestructor(self);
        }
      });
      self.setInternal('plugins', plugins);
      return self;
    },
    /**
     * get specified plugin instance by id
     * @param {String} id pluginId of plugin instance
     * @return {Object}
     */
    getPlugin: function (id) {
      var plugin = null;
      util.each(this.get('plugins'), function (p) {
        // user defined takes priority
        var pluginId = p.get && p.get('pluginId') || p.pluginId;
        if (pluginId === id) {
          plugin = p;
          return false;
        }
        return undefined;
      });
      return plugin;
    },
    destructor: noop,
    destroy: function () {
      var self = this, args = util.makeArray(arguments);
      if (!self.get('destroyed')) {
        callPluginsMethod.call(self, 'pluginDestructor', args);
        self.destructor.apply(self, args);
        self.set('destroyed', true);
        self.fire('destroy');
        self.detach();
      }
    }
  });
  util.mix(Base, {
    __hooks__: {
      initializer: __getHook(),
      destructor: __getHook('__destructor', true)
    },
    ATTRS: {
      /**
       * Plugins for current component.
       * @cfg {Function[]/Object[]} plugins
       */
      /**
       * @ignore
       */
      plugins: {
        valueFn: function () {
          return [];
        }
      },
      destroyed: { value: false },
      /**
       * Config listener on created.
       *
       * for example:
       *
       *      {
           *          click:{
           *              context:{x:1},
           *              fn:function(){
           *                  alert(this.x);
           *              }
           *          }
           *      }
       *      // or
       *      {
           *          click:function(){
           *              alert(this.x);
           *          }
           *      }
       *
       * @cfg {Object} listeners
       */
      /**
       * @ignore
       */
      listeners: {}
    },
    /**
     * create a new class from extensions and static/prototype properties/methods.
     * @param {Function[]} [extensions] extension classes
     * @param {Object} [px] key-value map for prototype properties/methods.
     * @param {Object} [sx] key-value map for static properties/methods.
     * @param {String} [sx.name] new Class's name.
     * @return {Function} new class which extend called, it also has a static extend method
     * @static
     *
     * for example:
     *
     *      var Parent = Base.extend({
         *          isParent: 1
         *      });
     *      var Child = Parent.extend({
         *          isChild: 1,
         *          isParent: 0
         *      })
     */
    extend: function extend(extensions, px, sx) {
      if (!util.isArray(extensions)) {
        sx = px;
        px = /**@type {Object} @ignore*/
        extensions;
        extensions = [];
      }
      var SubClass = Attribute.extend.call(this, px, sx);
      SubClass.__extensions__ = extensions;
      // stub hooks for extensions
      baseAddMembers.call(SubClass, {});
      // merge extensions
      if (extensions.length) {
        var attrs = {};
        var prototype = {};
        // [ex1,ex2]，扩展类后面的优先，ex2 定义的覆盖 ex1 定义的
        // 主类最优先
        util.each(extensions.concat(SubClass), function (ext) {
          if (ext) {
            // 合并 ATTRS 到主类
            // 不覆盖主类上的定义(主类位于 constructors 最后)
            // 因为继承层次上扩展类比主类层次高
            // 注意：最好 value 必须是简单对象，自定义 new 出来的对象就会有问题
            // (用 function return 出来)!
            // a {y:{value:2}} b {y:{value:3,getter:fn}}
            // b is a extension of a
            // =>
            // a {y:{value:2,getter:fn}}
            util.each(ext.ATTRS, function (v, name) {
              var av = attrs[name] = attrs[name] || {};
              util.mix(av, v);
            });
            // 方法合并
            var exp = ext.prototype, p;
            for (p in exp) {
              // do not mess with parent class
              if (exp.hasOwnProperty(p)) {
                prototype[p] = exp[p];
              }
            }
          }
        });
        SubClass.ATTRS = attrs;
        prototype.constructor = SubClass;
        util.augment(SubClass, prototype);
      }
      SubClass.extend = sx && sx.extend || extend;
      SubClass.addMembers = baseAddMembers;
      return SubClass;
    }
  });
  var addMembers = Base.addMembers;
  function baseAddMembers(px) {
    var self = this;
    var extensions = self.__extensions__;
    var hooks = self.__hooks__;
    var proto = self.prototype;
    if (extensions.length && hooks) {
      // stub for call extension method
      for (var h in hooks) {
        // do not override current with stub function
        if (proto.hasOwnProperty(h) && !px.hasOwnProperty(h)) {
          continue;
        }
        px[h] = px[h] || noop;
      }
    }
    return addMembers.call(self, px);
  }
  /**
   * The default set of bases which will be available for instances of this class, and
   * their configuration
   *
   * By default if the value is an object literal or an array it will be 'shallow' cloned, to
   * protect the default value.
   *
   *      for example:
   *      @example
   *      {
       *          x:{
       *              value: // default value
       *              valueFn: // default function to get value
       *              getter: // getter function
       *              setter: // setter function
       *          }
       *      }
   *
   * @property ATTRS
   * @member Base
   * @static
   * @type {Object}
   */
  function onSetAttrChange(e) {
    var self = this, method;
    // ignore bubbling
    if (e.target === self) {
      method = self[ON_SET + e.type.slice(5).slice(0, -6)];
      method.call(self, e.newVal, e);
    }
  }
  function constructPlugins(self) {
    var plugins = self.get('plugins'), Plugin;
    util.each(plugins, function (plugin, i) {
      if (typeof plugin === 'function') {
        Plugin = plugin;
        plugins[i] = new Plugin();
      }
    });
  }
  function callPluginsMethod(method, args) {
    var len, fn, self = this, plugins = self.get('plugins');
    args = args || [];
    args = [self].concat(args);
    if (len = plugins.length) {
      for (var i = 0; i < len; i++) {
        fn = plugins[i][method];
        if (fn) {
          fn.apply(plugins[i], args);
        }
      }
    }
  }
  function callExtensionsMethod(self, extensions, method, args) {
    var len;
    if (len = extensions && extensions.length) {
      for (var i = 0; i < len; i++) {
        var fn = extensions[i] && (!method ? extensions[i] : extensions[i].prototype[method]);
        if (fn) {
          fn.apply(self, args || []);
        }
      }
    }
  }
  exports = Base;
  return exports;
}();
baseIndex = function (exports) {
  exports = baseLibBase;
  return exports;
}();
return baseIndex;
});define("attribute", ['util',"event-custom"], function(require) {
var utilBase = require('util');
var eventCustom = require("event-custom");
//! Copyright 2015, attribute@6.1.0 MIT Licensed, build time: Thu, 29 Oct 2015 07:00:25 GMT 
/*
combined modules:
attribute
attribute/lib/attribute
*/
var attributeLibAttribute, attributeIndex;
attributeLibAttribute = function (exports) {
  /**!
   * @ignore
   * attribute management
   * @author yiminghe@gmail.com, lifesinger@gmail.com
   */
  var util = utilBase;
  /* global CustomEvent: true */
  var CustomEvent = eventCustom;
  function bind(v) {
    if (v === util.noop) {
      return function () {
      };
    } else {
      return util.bind(v);
    }
  }
  // atomic flag
  var INVALID = {};
  var FALSE = false;
  function normalFn(host, method) {
    if (typeof method === 'string') {
      return host[method];
    }
    return method;
  }
  function getAttrVals(self) {
    return self.__attrVals || (self.__attrVals = {});
  }
  function whenAttrChangeEventName(when, name) {
    return when + util.ucfirst(name) + 'Change';
  }
  // fire attribute value change
  function __fireAttrChange(self, when, name, prevVal, newVal, subAttrName, attrName, data) {
    attrName = attrName || name;
    return self.fire(whenAttrChangeEventName(when, name), util.mix({
      attrName: attrName,
      subAttrName: subAttrName,
      prevVal: prevVal,
      newVal: newVal
    }, data));
  }
  function ensureNonEmpty(obj, name, doNotCreate) {
    var ret = obj[name];
    if (!doNotCreate && !ret) {
      obj[name] = ret = {};
    }
    return ret || {};
  }
  /*
   o, [x,y,z] => o[x][y][z]
   */
  function getValueByPath(o, path) {
    for (var i = 0, len = path.length; o !== undefined && i < len; i++) {
      o = o[path[i]];
    }
    return o;
  }
  /*
   o, [x,y,z], val => o[x][y][z]=val
   */
  function setValueByPath(o, path, val) {
    var len = path.length - 1, s = o;
    if (len >= 0) {
      for (var i = 0; i < len; i++) {
        o = o[path[i]];
      }
      if (o !== undefined) {
        o[path[i]] = val;
      } else {
        s = undefined;
      }
    }
    return s;
  }
  function getPathNamePair(name) {
    var path;
    if (name.indexOf('.') !== -1) {
      path = name.split('.');
      name = path.shift();
    }
    return {
      path: path,
      name: name
    };
  }
  function getValueBySubValue(prevVal, path, value) {
    var tmp = value;
    if (path) {
      if (prevVal === undefined) {
        tmp = {};
      } else {
        tmp = util.clone(prevVal);
      }
      setValueByPath(tmp, path, value);
    }
    return tmp;
  }
  function prepareDefaultSetFn(self, name) {
    var defaultBeforeFns = ensureNonEmpty(self, '__defaultBeforeFns');
    if (defaultBeforeFns[name]) {
      return;
    }
    defaultBeforeFns[name] = 1;
    var beforeChangeEventName = whenAttrChangeEventName('before', name);
    self.publish(beforeChangeEventName, {
      defaultFn: defaultSetFn,
      // only process its own default function
      defaultTargetOnly: true
    });
  }
  function setInternal(self, name, value, opts, attrs) {
    var path, subVal, prevVal, pathNamePair = getPathNamePair(name), fullName = name;
    name = pathNamePair.name;
    path = pathNamePair.path;
    prevVal = self.get(name);
    prepareDefaultSetFn(self, name);
    if (path) {
      subVal = getValueByPath(prevVal, path);
    }
    // if no change, just return
    // pass equal check to fire change event
    if (!opts.force) {
      if (!path && prevVal === value) {
        return undefined;
      } else if (path && subVal === value) {
        return undefined;
      }
    }
    value = getValueBySubValue(prevVal, path, value);
    var beforeEventObject = util.mix({
      attrName: name,
      subAttrName: fullName,
      prevVal: prevVal,
      newVal: value,
      _opts: opts,
      _attrs: attrs,
      target: self
    }, opts.data);
    // check before event
    if (opts.silent) {
      if (FALSE === defaultSetFn.call(self, beforeEventObject)) {
        return FALSE;
      }
    } else {
      if (FALSE === self.fire(whenAttrChangeEventName('before', name), beforeEventObject)) {
        return FALSE;
      }
    }
    return self;
  }
  function defaultSetFn(e) {
    var self = this, value = e.newVal, prevVal = e.prevVal, name = e.attrName, fullName = e.subAttrName, attrs = e._attrs, opts = e._opts;
    // set it
    var ret = self.setInternal(name, value);
    if (ret === FALSE) {
      return ret;
    }
    // fire after event
    if (!opts.silent) {
      value = getAttrVals(self)[name];
      __fireAttrChange(self, 'after', name, prevVal, value, fullName, null, opts.data);
      if (attrs) {
        attrs.push({
          prevVal: prevVal,
          newVal: value,
          attrName: name,
          subAttrName: fullName
        });
      } else {
        __fireAttrChange(self, '', '*', [prevVal], [value], [fullName], [name], opts.data);
      }
    }
    return undefined;
  }
  /**
   * attribute management
   * @class KISSY.Attribute
   */
  function Attribute(config) {
    var self = this, c = self.constructor;
    // save user config
    self.userConfig = config;
    // define
    while (c) {
      addAttrs(self, c.ATTRS);
      c = c.superclass ? c.superclass.constructor : null;
    }
    // initial attr
    initAttrs(self, config);
  }
  function wrapProtoForSuper(px, SubClass) {
    var hooks = SubClass.__hooks__;
    // in case px contains toString
    if (hooks) {
      for (var p in hooks) {
        if (p in px) {
          px[p] = hooks[p](px[p]);
        }
      }
    }
    util.each(px, function (v, p) {
      if (typeof v === 'function') {
        var wrapped = 0;
        if (v.__owner__) {
          var originalOwner = v.__owner__;
          delete v.__owner__;
          delete v.__name__;
          wrapped = v.__wrapped__ = 1;
          var newV = bind(v);
          newV.__owner__ = originalOwner;
          newV.__name__ = p;
          originalOwner.prototype[p] = newV;
        } else if (v.__wrapped__) {
          wrapped = 1;
        }
        if (wrapped) {
          px[p] = v = bind(v);
        }
        v.__owner__ = SubClass;
        v.__name__ = p;
      }
    });
  }
  function addMembers(px) {
    var self = this;
    wrapProtoForSuper(px, self);
    util.mix(self.prototype, px);
  }
  Attribute.extend = function extend(px, sx) {
    var SubClass, opx = px, self = this;
    sx = util.merge(sx);
    // px is shared among classes
    px = util.merge(px);
    // On lesser IE 8, Util.merge does not copied field constructor,
    // even rewrote that on object itself.
    if (opx.hasOwnProperty('constructor')) {
      px.constructor = opx.constructor;
    }
    var hooks, sxHooks = sx.__hooks__;
    if (hooks = self.__hooks__) {
      sxHooks = sx.__hooks__ = sx.__hooks__ || {};
      util.mix(sxHooks, hooks, false);
    }
    var name = sx.name || 'AttributeDerived';
    if (px.hasOwnProperty('constructor')) {
      SubClass = px.constructor;
    } else {
      // debug mode, give the right name for constructor
      if ('@DEBUG@') {
        /*jshint evil: true*/
        SubClass = new Function('return function ' + util.camelCase(name) + '(){ ' + 'this.callSuper.apply(this, arguments);' + '}')();
      } else {
        SubClass = function () {
          this.callSuper.apply(this, arguments);
        };
      }
    }
    px.constructor = SubClass;
    SubClass.__hooks__ = sxHooks;
    wrapProtoForSuper(px, SubClass);
    var inheritedStatics, sxInheritedStatics = sx.inheritedStatics;
    if (inheritedStatics = self.inheritedStatics) {
      sxInheritedStatics = sx.inheritedStatics = sx.inheritedStatics || {};
      util.mix(sxInheritedStatics, inheritedStatics, false);
    }
    util.extend(SubClass, self, px, sx);
    if (sxInheritedStatics) {
      util.mix(SubClass, sxInheritedStatics);
    }
    SubClass.extend = sx.extend || extend;
    SubClass.addMembers = addMembers;
    return SubClass;
  };
  function addAttrs(host, attrs) {
    if (attrs) {
      for (var attr in attrs) {
        // 子类上的 ATTRS 配置优先
        // 父类后加，父类不覆盖子类的相同设置
        // 属性对象会 tructorerge
        // a: {y: {getter: fn}}, b: {y: {value: 3}}
        // b extends a
        // =>
        // b {y: {value: 3, getter: fn}}
        host.addAttr(attr, attrs[attr], false);
      }
    }
  }
  function initAttrs(host, config) {
    if (config) {
      for (var attr in config) {
        // 用户设置会调用 setter/validator 的，但不会触发属性变化事件
        host.setInternal(attr, config[attr]);
      }
    }
  }
  util.augment(Attribute, CustomEvent.Target, {
    INVALID: INVALID,
    callSuper: function () {
      var method, obj, self = this, args = arguments;
      if (typeof self === 'function' && self.__name__) {
        method = self;
        obj = args[0];
        args = Array.prototype.slice.call(args, 1);
      } else {
        /*jshint noarg: false*/
        method = arguments.callee.caller;
        if (method.__wrapped__) {
          method = method.caller;
        }
        obj = self;
      }
      var name = method.__name__;
      if (!name) {
        //S.log('can not find method name for callSuper [' + self.constructor.name + ']: ' + method.toString());
        return undefined;
      }
      var member = method.__owner__.superclass[name];
      if (!member) {
        //S.log('can not find method [' + name + '] for callSuper: ' + method.__owner__.name);
        return undefined;
      }
      return member.apply(obj, args || []);
    },
    /**
     * get un-cloned attr config collections
     * @return {Object}
     * @private
     */
    getAttrs: function () {
      return this.__attrs || (this.__attrs = {});
    },
    /**
     * get un-cloned attr value collections
     * @return {Object}
     */
    getAttrVals: function () {
      var self = this, o = {}, a, attrs = self.getAttrs();
      for (a in attrs) {
        o[a] = self.get(a);
      }
      return o;
    },
    /**
     * Adds an attribute with the provided configuration to the host object.
     * @param {String} name attrName
     * @param {Object} attrConfig The config supports the following properties
     * @param [attrConfig.value] simple object or system native object
     * @param [attrConfig.valueFn] a function which can return current attribute 's default value
     * @param {Function} [attrConfig.setter] call when set attribute 's value
     * pass current attribute 's value as parameter
     * if return value is not undefined,set returned value as real value
     * @param {Function} [attrConfig.getter] call when get attribute 's value
     * pass current attribute 's value as parameter
     * return getter's returned value to invoker
     * @param {Function} [attrConfig.validator]  call before set attribute 's value
     * if return false,cancel this set action
     * @param {Boolean} [override] whether override existing attribute config ,default true
     * @chainable
     */
    addAttr: function (name, attrConfig, override) {
      var self = this, attrs = self.getAttrs(), attr,
        // shadow clone
        cfg = util.merge(attrConfig);
      if (cfg.value && typeof cfg.value === 'object') {
        cfg.value = util.clone(cfg.value);
      }
      if (attr = attrs[name]) {
        util.mix(attr, cfg, override);
      } else {
        attrs[name] = cfg;
      }
      return self;
    },
    /**
     * Configures a group of attributes, and sets initial values.
     * @param {Object} attrConfigs  An object with attribute name/configuration pairs.
     * @param {Object} initialValues user defined initial values
     * @chainable
     */
    addAttrs: function (attrConfigs, initialValues) {
      var self = this;
      util.each(attrConfigs, function (attrConfig, name) {
        self.addAttr(name, attrConfig);
      });
      if (initialValues) {
        self.set(initialValues);
      }
      return self;
    },
    /**
     * Checks if the given attribute has been added to the host.
     * @param {String} name attribute name
     * @return {Boolean}
     */
    hasAttr: function (name) {
      return this.getAttrs().hasOwnProperty(name);
    },
    /**
     * Removes an attribute from the host object.
     * @chainable
     */
    removeAttr: function (name) {
      var self = this;
      var __attrVals = getAttrVals(self);
      var __attrs = self.getAttrs();
      if (self.hasAttr(name)) {
        delete __attrs[name];
        delete __attrVals[name];
      }
      return self;
    },
    /**
     * Sets the value of an attribute.
     * @param {String|Object} name attribute 's name or attribute name and value map
     * @param [value] attribute 's value
     * @param {Object} [opts] some options
     * @param {Boolean} [opts.silent] whether fire change event
     * @param {Function} [opts.error] error handler
     * @return {Boolean} whether pass validator
     */
    set: function (name, value, opts) {
      var self = this, e;
      if (typeof name !== 'string') {
        opts = value;
        opts = opts || {};
        var all = Object(name), attrs = [], errors = [];
        for (name in all) {
          // bulk validation
          // if any one failed,all values are not set
          if ((e = validate(self, name, all[name], all)) !== undefined) {
            errors.push(e);
          }
        }
        if (errors.length) {
          if (opts.error) {
            opts.error(errors);
          }
          return FALSE;
        }
        for (name in all) {
          setInternal(self, name, all[name], opts, attrs);
        }
        var attrNames = [], prevVals = [], newVals = [], subAttrNames = [];
        util.each(attrs, function (attr) {
          prevVals.push(attr.prevVal);
          newVals.push(attr.newVal);
          attrNames.push(attr.attrName);
          subAttrNames.push(attr.subAttrName);
        });
        if (attrNames.length) {
          __fireAttrChange(self, '', '*', prevVals, newVals, subAttrNames, attrNames, opts.data);
        }
        return self;
      }
      opts = opts || {};
      // validator check
      e = validate(self, name, value);
      if (e !== undefined) {
        if (opts.error) {
          opts.error(e);
        }
        return FALSE;
      }
      return setInternal(self, name, value, opts);
    },
    /**
     * internal use, no event involved, just set.
     * override by model
     * @protected
     */
    setInternal: function (name, value) {
      var self = this, setValue,
        // if host does not have meta info corresponding to (name,value)
        // then register on demand in order to collect all data meta info
        // 一定要注册属性元数据，否则其他模块通过 _attrs 不能枚举到所有有效属性
        // 因为属性在声明注册前可以直接设置值
        attrConfig = ensureNonEmpty(self.getAttrs(), name), setter = attrConfig.setter;
      // if setter has effect
      if (setter && (setter = normalFn(self, setter))) {
        setValue = setter.call(self, value, name);
      }
      if (setValue === INVALID) {
        return FALSE;
      }
      if (setValue !== undefined) {
        value = setValue;
      }
      // finally set
      getAttrVals(self)[name] = value;
      return undefined;
    },
    /**
     * Gets the current value of the attribute.
     * @param {String} name attribute 's name
     * @return {*}
     */
    get: function (name) {
      var self = this, dot = '.', path, attrVals = getAttrVals(self), attrConfig, getter, ret;
      if (name.indexOf(dot) !== -1) {
        path = name.split(dot);
        name = path.shift();
      }
      attrConfig = ensureNonEmpty(self.getAttrs(), name, 1);
      getter = attrConfig.getter;
      // get user-set value or default value
      //user-set value takes privilege
      ret = name in attrVals ? attrVals[name] : getDefAttrVal(self, name);
      // invoke getter for this attribute
      if (getter && (getter = normalFn(self, getter))) {
        ret = getter.call(self, ret, name);
      }
      if (!(name in attrVals) && ret !== undefined) {
        attrVals[name] = ret;
      }
      if (path) {
        ret = getValueByPath(ret, path);
      }
      return ret;
    },
    /**
     * Resets the value of an attribute.just reset what addAttr set
     * (not what invoker set when call new Xx(cfg))
     * @param {String} name name of attribute
     * @param {Object} [opts] some options
     * @param {Boolean} [opts.silent] whether fire change event
     * @chainable
     */
    reset: function (name, opts) {
      var self = this;
      if (typeof name === 'string') {
        if (self.hasAttr(name)) {
          // if attribute does not have default value, then set to undefined
          return self.set(name, getDefAttrVal(self, name), opts);
        } else {
          return self;
        }
      }
      opts = name;
      var attrs = self.getAttrs(), values = {};
      // reset all
      for (name in attrs) {
        values[name] = getDefAttrVal(self, name);
      }
      self.set(values, opts);
      return self;
    }
  });
  // get default attribute value from valueFn/value
  function getDefAttrVal(self, name) {
    var attrs = self.getAttrs(), attrConfig = ensureNonEmpty(attrs, name, 1), valFn = attrConfig.valueFn, val;
    if (valFn && (valFn = normalFn(self, valFn))) {
      val = valFn.call(self);
      if (val !== undefined) {
        attrConfig.value = val;
      }
      delete attrConfig.valueFn;
      attrs[name] = attrConfig;
    }
    return attrConfig.value;
  }
  function validate(self, name, value, all) {
    var path, prevVal, pathNamePair;
    pathNamePair = getPathNamePair(name);
    name = pathNamePair.name;
    path = pathNamePair.path;
    if (path) {
      prevVal = self.get(name);
      value = getValueBySubValue(prevVal, path, value);
    }
    var attrConfig = ensureNonEmpty(self.getAttrs(), name), e, validator = attrConfig.validator;
    if (validator && (validator = normalFn(self, validator))) {
      e = validator.call(self, value, name, all);
      // undefined and true validate successfully
      if (e !== undefined && e !== true) {
        return e;
      }
    }
    return undefined;
  }
  exports = Attribute;
  return exports;
}();
attributeIndex = function (exports) {
  exports = attributeLibAttribute;
  return exports;
}();
return attributeIndex;
});define("event-custom", ["event-base",'util'], function(require) {
var eventBase = require("event-base");
var utilBase = require('util');
//! Copyright 2015, event-custom@6.1.1 MIT Licensed, build time: Thu, 29 Oct 2015 07:40:56 GMT 
/*
combined modules:
event-custom
event-custom/lib/event-custom
event-custom/lib/event-custom/target
event-custom/lib/event-custom/observable
event-custom/lib/event-custom/observer
event-custom/lib/event-custom/object
*/
var eventCustomLibEventCustomObserver, eventCustomLibEventCustomObject, eventCustomLibEventCustomObservable, eventCustomLibEventCustomTarget, eventCustomLibEventCustom, eventCustomIndex;
eventCustomLibEventCustomObserver = function (exports) {
  /**
   * @ignore
   * Observer for custom event
   * @author yiminghe@gmail.com, benfchen0418@gmail.com
   */
  var BaseEvent = eventBase;
  var util = utilBase;
  /**
   * Observer for custom event
   * @class CustomEvent.Observer
   * @extends Event.Observer
   * @private
   */
  function CustomEventObserver() {
    CustomEventObserver.superclass.constructor.apply(this, arguments);
  }
  util.extend(CustomEventObserver, BaseEvent.Observer, {
    keys: [
      'fn',
      'context',
      'groups'
    ]
  });
  exports = CustomEventObserver;
  return exports;
}();
eventCustomLibEventCustomObject = function (exports) {
  /**
   * @ignore
   * simple custom event object for custom event mechanism.
   * @author yiminghe@gmail.com, benfchen0418@gmail.com
   */
  var BaseEvent = eventBase;
  var util = utilBase;
  /**
   * Do not new by yourself.
   *
   * Custom event object.
   * @private
   * @class CustomEvent.Object
   * @param {Object} data data which will be mixed into custom event instance
   * @extends Event.Object
   */
  function CustomEventObject(data) {
    CustomEventObject.superclass.constructor.call(this);
    util.mix(this, data);
  }
  util.extend(CustomEventObject, BaseEvent.Object);
  exports = CustomEventObject;
  return exports;
}();
eventCustomLibEventCustomObservable = function (exports) {
  var BaseEvent = eventBase;
  var CustomEventObserver = eventCustomLibEventCustomObserver;
  var CustomEventObject = eventCustomLibEventCustomObject;
  var Utils = BaseEvent.Utils;
  var util = utilBase;
  function CustomEventObservable() {
    var self = this;
    CustomEventObservable.superclass.constructor.apply(self, arguments);
    self.defaultFn = null;
    self.defaultTargetOnly = false;
    self.bubbles = true;
  }
  util.extend(CustomEventObservable, BaseEvent.Observable, {
    on: function (cfg) {
      var observer = new CustomEventObserver(cfg);
      if (this.findObserver(observer) === -1) {
        this.observers.push(observer);
      }
    },
    fire: function (eventData) {
      eventData = eventData || {};
      var self = this, bubbles = self.bubbles, currentTarget = self.currentTarget, parents, parentsLen, type = self.type, defaultFn = self.defaultFn, i, customEventObject = eventData, gRet, ret;
      eventData.type = type;
      if (!customEventObject.isEventObject) {
        customEventObject = new CustomEventObject(customEventObject);
      }
      customEventObject.target = customEventObject.target || currentTarget;
      customEventObject.currentTarget = currentTarget;
      ret = self.notify(customEventObject);
      if (gRet !== false && ret !== undefined) {
        gRet = ret;
      }
      if (bubbles && !customEventObject.isPropagationStopped()) {
        parents = currentTarget.getTargets();
        parentsLen = parents && parents.length || 0;
        for (i = 0; i < parentsLen && !customEventObject.isPropagationStopped(); i++) {
          ret = parents[i].fire(type, customEventObject);
          if (gRet !== false && ret !== undefined) {
            gRet = ret;
          }
        }
      }
      if (defaultFn && !customEventObject.isDefaultPrevented()) {
        var target = customEventObject.target, lowestCustomEventObservable = target.getEventListeners(customEventObject.type);
        if (!self.defaultTargetOnly && (!lowestCustomEventObservable || !lowestCustomEventObservable.defaultTargetOnly) || currentTarget === target) {
          gRet = defaultFn.call(currentTarget, customEventObject);
        }
      }
      return gRet;
    },
    notify: function (event) {
      var observers = [].concat(this.observers), ret, gRet, len = observers.length, i;
      for (i = 0; i < len && !event.isImmediatePropagationStopped(); i++) {
        ret = observers[i].notify(event, this);
        if (gRet !== false && ret !== undefined) {
          gRet = ret;
        }
      }
      return gRet;
    },
    detach: function (cfg) {
      var groupsRe, self = this, fn = cfg.fn, context = cfg.context, currentTarget = self.currentTarget, observers = self.observers, groups = cfg.groups;
      if (!observers.length) {
        return;
      }
      if (groups) {
        groupsRe = Utils.getGroupsRe(groups);
      }
      var i, j, t, observer, observerContext, len = observers.length;
      if (fn || groupsRe) {
        context = context || currentTarget;
        for (i = 0, j = 0, t = []; i < len; ++i) {
          observer = observers[i];
          var observerConfig = observer.config;
          observerContext = observerConfig.context || currentTarget;
          if (context !== observerContext || fn && fn !== observerConfig.fn || groupsRe && !observerConfig.groups.match(groupsRe)) {
            t[j++] = observer;
          }
        }
        self.observers = t;
      } else {
        self.reset();
      }
    }
  });
  exports = CustomEventObservable;
  return exports;
}();
eventCustomLibEventCustomTarget = function (exports) {
  var BaseEvent = eventBase;
  var CustomEventObservable = eventCustomLibEventCustomObservable;
  var util = utilBase;
  var Utils = BaseEvent.Utils, splitAndRun = Utils.splitAndRun, KS_BUBBLE_TARGETS = '__~ks_bubble_targets';
  var KS_CUSTOM_EVENTS = '__~ks_custom_events';
  function getCustomEventObservable(self, type) {
    var customEvent = self.getEventListeners(type);
    if (!customEvent) {
      customEvent = self.getEventListeners()[type] = new CustomEventObservable({
        currentTarget: self,
        type: type
      });
    }
    return customEvent;
  }
  exports = {
    isTarget: 1,
    fire: function (type, eventData) {
      var self = this, ret, targets = self.getTargets(), hasTargets = targets && targets.length;
      if (type.isEventObject) {
        eventData = type;
        type = type.type;
      }
      eventData = eventData || {};
      splitAndRun(type, function (type) {
        var r2, customEventObservable;
        Utils.fillGroupsForEvent(type, eventData);
        type = eventData.type;
        customEventObservable = self.getEventListeners(type);
        if (!customEventObservable && !hasTargets) {
          return;
        }
        if (customEventObservable) {
          if (!customEventObservable.hasObserver() && !customEventObservable.defaultFn) {
            if (customEventObservable.bubbles && !hasTargets || !customEventObservable.bubbles) {
              return;
            }
          }
        } else {
          customEventObservable = new CustomEventObservable({
            currentTarget: self,
            type: type
          });
        }
        r2 = customEventObservable.fire(eventData);
        if (ret !== false && r2 !== undefined) {
          ret = r2;
        }
      });
      return ret;
    },
    publish: function (type, cfg) {
      var customEventObservable, self = this;
      splitAndRun(type, function (t) {
        customEventObservable = getCustomEventObservable(self, t);
        util.mix(customEventObservable, cfg);
      });
      return self;
    },
    addTarget: function (anotherTarget) {
      var self = this, targets = self.getTargets();
      if (!util.inArray(anotherTarget, targets)) {
        targets.push(anotherTarget);
      }
      return self;
    },
    removeTarget: function (anotherTarget) {
      var self = this, targets = self.getTargets(), index = util.indexOf(anotherTarget, targets);
      if (index !== -1) {
        targets.splice(index, 1);
      }
      return self;
    },
    getTargets: function () {
      return this[KS_BUBBLE_TARGETS] || (this[KS_BUBBLE_TARGETS] = []);
    },
    getEventListeners: function (type) {
      var observables = this[KS_CUSTOM_EVENTS] || (this[KS_CUSTOM_EVENTS] = {});
      return type ? observables[type] : observables;
    },
    on: function (type, fn, context) {
      var self = this;
      Utils.batchForType(function (type, fn, context) {
        var cfg = Utils.normalizeParam(type, fn, context);
        type = cfg.type;
        var customEvent = getCustomEventObservable(self, type);
        customEvent.on(cfg);
      }, 0, type, fn, context);
      return self;
    },
    detach: function (type, fn, context) {
      var self = this;
      Utils.batchForType(function (type, fn, context) {
        var cfg = Utils.normalizeParam(type, fn, context);
        type = cfg.type;
        if (type) {
          var customEvent = self.getEventListeners(type);
          if (customEvent) {
            customEvent.detach(cfg);
          }
        } else {
          util.each(self.getEventListeners(), function (customEvent) {
            customEvent.detach(cfg);
          });
        }
      }, 0, type, fn, context);
      return self;
    }
  };
  return exports;
}();
eventCustomLibEventCustom = function (exports) {
  var Target = eventCustomLibEventCustomTarget;
  var util = utilBase;
  exports = {
    Target: Target,
    Object: eventCustomLibEventCustomObject,
    global: util.mix({}, Target)
  };
  return exports;
}();
eventCustomIndex = function (exports) {
  exports = eventCustomLibEventCustom;
  return exports;
}();
return eventCustomIndex;
});define("event-base", ['util'], function(require) {
var utilBase = require('util');
//! Copyright 2015, event-base@6.1.1 MIT Licensed, build time: Thu, 29 Oct 2015 07:30:30 GMT 
/*
combined modules:
event-base
event-base/lib/event-base
event-base/lib/event-base/utils
event-base/lib/event-base/observer
event-base/lib/event-base/observable
event-base/lib/event-base/object
*/
var eventBaseLibEventBaseUtils, eventBaseLibEventBaseObserver, eventBaseLibEventBaseObservable, eventBaseLibEventBaseObject, eventBaseLibEventBase, eventBaseIndex;
eventBaseLibEventBaseUtils = function (exports) {
  /**
   * @ignore
   * utils for event
   * @author yiminghe@gmail.com, benfchen0418@gmail.com
   */
  var splitAndRun, getGroupsRe;
  var util = utilBase;
  function getTypedGroups(type) {
    if (type.indexOf('.') < 0) {
      return [
        type,
        ''
      ];
    }
    var m = type.match(/([^.]+)?(\..+)?$/), t = m[1], ret = [t], gs = m[2];
    if (gs) {
      gs = gs.split('.').sort();
      ret.push(gs.join('.'));
    } else {
      ret.push('');
    }
    return ret;
  }
  exports = {
    splitAndRun: splitAndRun = function (type, fn) {
      if (util.isArray(type)) {
        util.each(type, fn);
        return;
      }
      type = util.trim(type);
      if (type.indexOf(' ') === -1) {
        fn(type);
      } else {
        util.each(type.split(/\s+/), fn);
      }
    },
    normalizeParam: function (type, fn, context) {
      var cfg = fn || {};
      if (typeof fn === 'function') {
        cfg = {
          fn: fn,
          context: context
        };
      } else {
        cfg = util.merge(cfg);
      }
      var typedGroups = getTypedGroups(type);
      type = typedGroups[0];
      cfg.groups = typedGroups[1];
      cfg.type = type;
      return cfg;
    },
    batchForType: function (fn, num) {
      var args = util.makeArray(arguments), types = args[2 + num];
      if (types && util.isObject(types)) {
        util.each(types, function (value, type) {
          var args2 = [].concat(args);
          args2.splice(0, 2);
          args2[num] = type;
          args2[num + 1] = value;
          fn.apply(null, args2);
        });
      } else {
        splitAndRun(types, function (type) {
          var args2 = [].concat(args);
          args2.splice(0, 2);
          args2[num] = type;
          fn.apply(null, args2);
        });
      }
    },
    fillGroupsForEvent: function (type, eventData) {
      var typedGroups = getTypedGroups(type), _ksGroups = typedGroups[1];
      if (_ksGroups) {
        _ksGroups = getGroupsRe(_ksGroups);
        eventData._ksGroups = _ksGroups;
      }
      eventData.type = typedGroups[0];
    },
    getGroupsRe: getGroupsRe = function (groups) {
      return new RegExp(groups.split('.').join('.*\\.') + '(?:\\.|$)');
    }
  };
  return exports;
}();
eventBaseLibEventBaseObserver = function (exports) {
  var undef;
  var util = utilBase;
  function Observer(cfg) {
    this.config = cfg || {};
  }
  Observer.prototype = {
    constructor: Observer,
    equals: function (s2) {
      var self = this;
      return !!util.reduce(self.keys, function (v, k) {
        return v && self.config[k] === s2.config[k];
      }, 1);
    },
    simpleNotify: function (event, ce) {
      var ret, self = this, config = self.config;
      ret = config.fn.call(config.context || ce.currentTarget, event, config.data);
      if (config.once) {
        ce.removeObserver(self);
      }
      return ret;
    },
    notifyInternal: function (event, ce) {
      var ret = this.simpleNotify(event, ce);
      if (ret === false) {
        event.halt();
      }
      return ret;
    },
    notify: function (event, ce) {
      var self = this, config = self.config, _ksGroups = event._ksGroups;
      if (_ksGroups && (!config.groups || !config.groups.match(_ksGroups))) {
        return undef;
      }
      return self.notifyInternal(event, ce);
    }
  };
  exports = Observer;
  return exports;
}();
eventBaseLibEventBaseObservable = function (exports) {
  var util = utilBase;
  function Observable(cfg) {
    var self = this;
    self.currentTarget = null;
    util.mix(self, cfg);
    self.reset();
  }
  Observable.prototype = {
    constructor: Observable,
    hasObserver: function () {
      return !!this.observers.length;
    },
    reset: function () {
      var self = this;
      self.observers = [];
    },
    removeObserver: function (observer) {
      var self = this, i, observers = self.observers, len = observers.length;
      for (i = 0; i < len; i++) {
        if (observers[i] === observer) {
          observers.splice(i, 1);
          break;
        }
      }
      self.checkMemory();
    },
    checkMemory: function () {
    },
    findObserver: function (observer) {
      var observers = this.observers, i;
      for (i = observers.length - 1; i >= 0; --i) {
        if (observer.equals(observers[i])) {
          return i;
        }
      }
      return -1;
    }
  };
  exports = Observable;
  return exports;
}();
eventBaseLibEventBaseObject = function (exports) {
  var returnFalse = function () {
      return false;
    }, returnTrue = function () {
      return true;
    }, undef;
  var util = utilBase;
  function EventObject() {
    var self = this;
    self.timeStamp = util.now();
    self.target = undef;
    self.currentTarget = undef;
  }
  EventObject.prototype = {
    isEventObject: 1,
    constructor: EventObject,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function () {
      this.isDefaultPrevented = returnTrue;
    },
    stopPropagation: function () {
      this.isPropagationStopped = returnTrue;
    },
    stopImmediatePropagation: function () {
      var self = this;
      self.isImmediatePropagationStopped = returnTrue;
      self.stopPropagation();
    },
    halt: function (immediate) {
      var self = this;
      if (immediate) {
        self.stopImmediatePropagation();
      } else {
        self.stopPropagation();
      }
      self.preventDefault();
    }
  };
  exports = EventObject;
  return exports;
}();
eventBaseLibEventBase = function (exports) {
  var Utils = eventBaseLibEventBaseUtils;
  var Observer = eventBaseLibEventBaseObserver;
  var Observable = eventBaseLibEventBaseObservable;
  exports = {
    Utils: Utils,
    Object: eventBaseLibEventBaseObject,
    Observer: Observer,
    Observable: Observable
  };
  return exports;
}();
eventBaseIndex = function (exports) {
  exports = eventBaseLibEventBase;
  return exports;
}();
return eventBaseIndex;
});define("io", ['util',"io-extra","io-form"], function(require) {
var utilBase = require('util');
var ioExtra = require("io-extra");
var ioForm = require("io-form");
//! Copyright 2015, io@6.1.2 MIT Licensed, build time: Thu, 29 Oct 2015 12:07:15 GMT 
/*
combined modules:
io
*/
var ioIndex;
ioIndex = function (exports) {
  var util = utilBase;
  var IO = ioExtra;
  var FormSerializer = ioForm;
  util.mix(IO, {
    serialize: FormSerializer.serialize,
    getFormData: FormSerializer.getFormData
  });
  exports = IO;
  return exports;
}();
return ioIndex;
});define("io-extra", ['util',"querystring",'dom',"io-base",'util'], function(require) {
var utilExtra = require('util');
var _querystring_ = require("querystring");
var domBase = require('dom');
var ioBase = require("io-base");
var utilBase = require('util');
//! Copyright 2015, io-extra@6.1.2 MIT Licensed, build time: Thu, 29 Oct 2015 12:12:45 GMT 
/*
combined modules:
io-extra
io-extra/lib/extra
io-extra/lib/extra/iframe-transport
*/
var ioExtraLibExtraIframeTransport, ioExtraLibExtra, ioExtraIndex;
ioExtraLibExtraIframeTransport = function (exports) {
  /**
   * @ignore
   * non-refresh upload file with form by iframe
   * @author yiminghe@gmail.com
   */
  var util = utilExtra;
  var querystring = _querystring_;
  var Dom = domBase;
  var IO = ioBase;
  var ioUtils = IO._util;
  var doc = document, OK_CODE = 200, ERROR_CODE = 500, BREATH_INTERVAL = 30, iframeConverter = util.clone(IO.getConfig().converters.text);
  // https://github.com/kissyteam/kissy/issues/304
  // returned data must be escaped by server for json dataType
  // as data
  // eg:
  // <body>
  // {
  //    "&lt;a&gt;xx&lt;/a&gt;"
  // }
  // </body>
  // text or html dataType is of same effect.
  // same as normal ajax or html5 FileData
  iframeConverter.json = function (str) {
    return util.parseJson(util.unEscapeHtml(str));
  };
  // iframe 内的内容就是 body.innerText
  IO.setupConfig({
    converters: {
      // iframe 到其他类型的转化和 text 一样
      iframe: iframeConverter,
      text: {
        // fake type, just mirror
        iframe: function (text) {
          return text;
        }
      },
      xml: {
        // fake type, just mirror
        iframe: function (xml) {
          return xml;
        }
      }
    }
  });
  function createIframe(xhr) {
    var id = util.guid('io-iframe'), iframe,
      // empty src, so no history
      src = Dom.getEmptyIframeSrc();
    iframe = xhr.iframe = Dom.create('<iframe ' + (src ? ' src="' + src + '" ' : '') + ' id="' + id + '"' + // need name for target of form
    ' name="' + id + '"' + ' style="position:absolute;left:-9999px;top:-9999px;"/>');
    Dom.prepend(iframe, doc.body || doc.documentElement);
    return iframe;
  }
  function addDataToForm(query, form, serializeArray) {
    var ret = [], isArray, i, e;
    util.each(query, function (data, k) {
      isArray = util.isArray(data);
      if (!isArray) {
        data = [data];
      }
      // 数组和原生一样对待，创建多个同名输入域
      for (i = 0; i < data.length; i++) {
        e = doc.createElement('input');
        e.type = 'hidden';
        e.name = k + (isArray && serializeArray ? '[]' : '');
        e.value = data[i];
        Dom.append(e, form);
        ret.push(e);
      }
    });
    return ret;
  }
  function removeFieldsFromData(fields) {
    Dom.remove(fields);
  }
  function callback(event) {
    var self = this, form = self.form, io = self.io, eventType = /**
       @type String
       @ignore*/
      event.type, iframeDoc, iframe = io.iframe;
    // 防止重复调用 , 成功后 abort
    if (!iframe) {
      return;
    }
    // ie6 立即设置 action 设置为空导致白屏
    if (eventType === 'abort' && ioUtils.ie === 6) {
      setTimeout(function () {
        Dom.attr(form, self.attrs);
      }, 0);
    } else {
      Dom.attr(form, self.attrs);
    }
    removeFieldsFromData(this.fields);
    ioUtils.removeEvent(iframe, 'load', self._callback);
    ioUtils.removeEvent(iframe, 'error', self._callback);
    setTimeout(function () {
      // firefox will keep loading if not set timeout
      Dom.remove(iframe);
    }, BREATH_INTERVAL);
    // nullify to prevent memory leak?
    io.iframe = null;
    if (eventType === 'load') {
      try {
        iframeDoc = iframe.contentWindow.document;
        // ie<9
        if (iframeDoc && iframeDoc.body) {
          // https://github.com/kissyteam/kissy/issues/304
          io.responseText = Dom.html(iframeDoc.body);
          // ie still can retrieve xml 's responseText
          if (util.startsWith(io.responseText, '<?xml')) {
            io.responseText = undefined;
          }
        }
        // ie<9
        // http://help.dottoro.com/ljbcjfot.php
        // http://msdn.microsoft.com/en-us/library/windows/desktop/ms766512(v=vs.85).aspx
        /*
         In Internet Explorer, XML documents can also be embedded into HTML documents with the xml HTML elements.
         To get an XMLDocument object that represents the embedded XML data island,
         use the XMLDocument property of the xml element.
         Note that the support for the XMLDocument property has been removed in Internet Explorer 9.
         */
        if (iframeDoc && iframeDoc.XMLDocument) {
          io.responseXML = iframeDoc.XMLDocument;
        } else {
          // ie9 firefox chrome
          io.responseXML = iframeDoc;
        }
        if (iframeDoc) {
          io._ioReady(OK_CODE, 'success');
        } else {
          // chrome does not throw exception:
          // Unsafe JavaScript attempt to access frame with URL upload.jss from frame with URL test.html.
          // Domains, protocols and ports must match.
          // chrome will get iframeDoc to null
          // so this error is parser error to normalize all browsers
          io._ioReady(ERROR_CODE, 'parser error');
        }
      } catch (e) {
        // #245 submit to a  cross domain page except chrome
        io._ioReady(ERROR_CODE, 'parser error');
      }
    } else if (eventType === 'error') {
      io._ioReady(ERROR_CODE, 'error');
    }
  }
  function IframeTransport(io) {
    this.io = io;
    this._callback = util.bind(callback, this);
  }
  util.augment(IframeTransport, {
    send: function () {
      var self = this, io = self.io, c = io.config, fields, iframe, query, data = c.data, form = Dom.get(c.form);
      self.attrs = {
        target: Dom.attr(form, 'target') || '',
        action: Dom.attr(form, 'action') || '',
        // enctype 区分 iframe 与 serialize
        encoding: Dom.attr(form, 'encoding'),
        enctype: Dom.attr(form, 'enctype'),
        method: Dom.attr(form, 'method')
      };
      self.form = form;
      iframe = createIframe(io);
      // set target to iframe to avoid main page refresh
      Dom.attr(form, {
        target: iframe.id,
        action: io._getUrlForSend(),
        method: 'post',
        enctype: 'multipart/form-data',
        encoding: 'multipart/form-data'
      });
      // unparam to kv map
      if (data) {
        query = querystring.parse(data);
      }
      if (query) {
        fields = addDataToForm(query, form, c.serializeArray);
      }
      self.fields = fields;
      function go() {
        ioUtils.addEvent(iframe, 'load', self._callback);
        ioUtils.addEvent(iframe, 'error', self._callback);
        form.submit();
      }
      // ie6 need a breath
      if (ioUtils.ie === 6) {
        setTimeout(go, 0);
      } else {
        // can not setTimeout or else chrome will submit to top window
        go();
      }
    },
    abort: function () {
      this._callback({ type: 'abort' });
    }
  });
  IO.setupTransport('iframe', IframeTransport);
  return exports;
}();
ioExtraLibExtra = function (exports) {
  var IO = ioBase;
  var util = utilBase;
  ioExtraLibExtraIframeTransport;
  util.mix(IO, {
    upload: function (url, form, data, callback, dataType) {
      if (typeof data === 'function') {
        dataType = callback;
        callback = data;
        data = undefined;
      }
      return IO({
        url: url,
        type: 'post',
        dataType: dataType,
        form: form,
        data: data,
        complete: callback
      });
    }
  });
  exports = IO;
  return exports;
}();
ioExtraIndex = function (exports) {
  exports = ioExtraLibExtra;
  return exports;
}();
return ioExtraIndex;
});define("io-base", ['util',"querystring","promise","url",'dom',"io-script"], function(require) {
var utilBase = require('util');
var _querystring_ = require("querystring");
var promise = require("promise");
var _url_ = require("url");
var domBase = require('dom');
var ioScript = require("io-script");
//! Copyright 2015, io-base@6.1.4 MIT Licensed, build time: Thu, 29 Oct 2015 12:11:47 GMT 
/*
combined modules:
io-base
io-base/lib/main
io-base/lib/main/io
io-base/lib/main/base
io-base/lib/main/utils
io-base/lib/main/xhr-transport
io-base/lib/main/xhr-transport-base
io-base/lib/main/sub-domain-transport
io-base/lib/main/script-transport
io-base/lib/main/jsonp
io-base/lib/main/methods
*/
var ioBaseLibMainBase, ioBaseLibMainUtils, ioBaseLibMainXhrTransportBase, ioBaseLibMainSubDomainTransport, ioBaseLibMainScriptTransport, ioBaseLibMainJsonp, ioBaseLibMainMethods, ioBaseLibMainIo, ioBaseLibMainXhrTransport, ioBaseLibMain, ioBaseIndex;
ioBaseLibMainBase = function (exports) {
  /**
   * @ignore
   * a scalable client io framework
   * @author yiminghe@gmail.com
   */
  var util = utilBase;
  var querystring = _querystring_;
  var XPromise = promise;
  var url = _url_;
  var rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|widget):$/, rspace = /\s+/, mirror = function (s) {
      return s;
    }, rnoContent = /^(?:GET|HEAD)$/, locationHref = location.href, locationUrl = url.parse(locationHref), isLocal = rlocalProtocol.test(locationUrl.protocol), transports = {}, defaultConfig = {
      type: 'GET',
      contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
      async: true,
      serializeArray: true,
      processData: true,
      accepts: {
        xml: 'application/xml, text/xml',
        html: 'text/html',
        text: 'text/plain',
        json: 'application/json, text/javascript',
        '*': '*/*'
      },
      converters: {
        text: {
          json: util.parseJson,
          html: mirror,
          text: mirror,
          xml: util.parseXML || mirror
        }
      },
      headers: { 'X-Requested-With': 'XMLHttpRequest' },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      }
    };
  defaultConfig.converters.html = defaultConfig.converters.text;
  function setUpConfig(c) {
    // deep mix,exclude context!
    var context = c.context;
    delete c.context;
    c = util.mix(util.clone(defaultConfig), c, { deep: true });
    c.context = context || c;
    var data, uri, type = c.type, dataType = c.dataType;
    uri = c.uri = url.parse(url.resolve(locationHref, c.url), true);
    // see method _getUrlForSend
    uri.query = {};
    if (!('crossDomain' in c)) {
      c.crossDomain = !(uri.protocol === locationUrl.protocol && uri.host === locationUrl.host);
    }
    type = c.type = type.toUpperCase();
    c.hasContent = !rnoContent.test(type);
    if (c.processData && (data = c.data) && typeof data !== 'string') {
      // normalize to string
      c.data = querystring.stringify(data, undefined, undefined, c.serializeArray);
    }
    // 数据类型处理链，一步步将前面的数据类型转化成最后一个
    dataType = c.dataType = util.trim(dataType || '*').split(rspace);
    if (!('cache' in c) && util.inArray(dataType[0], [
        'script',
        'jsonp'
      ])) {
      c.cache = false;
    }
    if (!c.hasContent) {
      if (c.data) {
        util.mix(uri.query, querystring.parse(c.data));
      }
      if (c.cache === false) {
        uri.query._ksTS = util.now() + '_' + util.guid();
      }
    }
    return c;
  }
  /**
   * Return a io object and send request by config.
   *
   * @class IO
   * @extends Promise
   *
   * @cfg {String} url
   * request destination
   *
   * @cfg {String} type request type.
   * eg: 'get','post'
   * Default to: 'get'
   *
   * @cfg {String} contentType
   * Default to: 'application/x-www-form-urlencoded; charset=UTF-8'
   * Data will always be transmitted to the server using UTF-8 charset
   *
   * @cfg {Object} accepts
   * Default to: depends on DataType.
   * The content type sent in request header that tells the server
   * what kind of response it will accept in return.
   * It is recommended to do so once in the {@link IO#method-setupConfig}
   *
   * @cfg {Boolean} async
   * Default to: true
   * whether request is sent asynchronously
   *
   * @cfg {Boolean} cache
   * Default to: true ,false for dataType 'script' and 'jsonp'
   * if set false,will append _ksTs=Date.now() to url automatically
   *
   * @cfg {Object} contents
   * a name-regexp map to determine request data's dataType
   * It is recommended to do so once in the {@link IO#method-setupConfig}
   *
   * @cfg {Object} context
   * specify the context of this request 's callback (success,error,complete)
   *
   * @cfg {Object} converters
   * Default to: {text:{json:Json.parse,html:mirror,text:mirror,xml:parseXML}}
   * specified how to transform one dataType to another dataType
   * It is recommended to do so once in the {@link IO#method-setupConfig}
   *
   * @cfg {Boolean} crossDomain
   * Default to: false for same-domain request,true for cross-domain request
   * if server-side jsonp redirect to another domain, you should set this to true.
   * if you want use script for jsonp for same domain request, you should set this to true.
   *
   * @cfg {Object} data
   * Data sent to server.if processData is true,data will be serialized to String type.
   * if value is an Array, serialization will be based on serializeArray.
   *
   * @cfg {String} dataType
   * return data as a specified type
   * Default to: Based on server contentType header
   * 'xml' : a XML document
   * 'text'/'html': raw server data
   * 'script': evaluate the return data as script
   * 'json': parse the return data as json and return the result as final data
   * 'jsonp': load json data via jsonp
   *
   * @cfg {Object} headers
   * additional name-value header to send along with this request.
   *
   * @cfg {String} jsonp
   * Default to: 'callback'
   * Override the callback function name in a jsonp request. eg:
   * set 'callback2' , then jsonp url will append  'callback2=?'.
   *
   * @cfg {String} jsonpCallback
   * Specify the callback function name for a jsonp request.
   * set this value will replace the auto generated function name.
   * eg:
   * set 'customCall' , then jsonp url will append 'callback=customCall'
   *
   * @cfg {String} mimeType
   * override xhr 's mime type
   *
   * @cfg {String} ifModified
   * whether enter if modified mode.
   * Defaults to false.
   *
   * @cfg {Boolean} processData
   * Default to: true
   * whether data will be serialized as String
   *
   * @cfg {String} scriptCharset
   * only for dataType 'jsonp' and 'script' and 'get' type.
   * force the script to certain charset.
   *
   * @cfg {Function} beforeSend
   * beforeSend(io,config)
   * callback function called before the request is sent.this function has 2 arguments
   *
   * 1. current KISSY io object
   *
   * 2. current io config
   *
   * note: can be used for add progress event listener for native xhr's upload attribute
   * see <a href='http://www.w3.org/TR/XMLHttpRequest/#event-xhr-progress'>XMLHttpRequest2</a>
   *
   * @cfg {Function} success
   * success(data,textStatus,xhr)
   * callback function called if the request succeeds.this function has 3 arguments
   *
   * 1. data returned from this request with type specified by dataType
   *
   * 2. status of this request with type String
   *
   * 3. io object of this request , for details {@link IO}
   *
   * @cfg {Function} error
   * success(data,textStatus,xhr)
   * callback function called if the request occurs error.this function has 3 arguments
   *
   * 1. null value
   *
   * 2. status of this request with type String,such as 'timeout','Not Found','parsererror:...'
   *
   * 3. io object of this request , for details {@link IO}
   *
   * @cfg {Function} complete
   * success(data,textStatus,xhr)
   * callback function called if the request finished(success or error).this function has 3 arguments
   *
   * 1. null value if error occurs or data returned from server
   *
   * 2. status of this request with type String,such as success:'ok',
   * error:'timeout','Not Found','parsererror:...'
   *
   * 3. io object of this request , for details {@link IO}
   *
   * @cfg {Number} timeout
   * Set a timeout(in seconds) for this request.if will call error when timeout
   *
   * @cfg {Boolean} serializeArray
   * whether add [] to data's name when data's value is array in serialization
   *
   * @cfg {Object} xhrFields
   * name-value to set to native xhr.set as xhrFields:{withCredentials:true}
   * note: withCredentials defaults to true.
   *
   * @cfg {String} username
   * a username tobe used in response to HTTP access authentication request
   *
   * @cfg {String} password
   * a password tobe used in response to HTTP access authentication request
   *
   * @cfg {Object} xdr
   * cross domain request config object, contains sub config:
   *
   * xdr.src
   * Default to: KISSY 's flash url
   * flash sender url
   *
   * xdr.use
   * if set to 'use', it will always use flash for cross domain request even in chrome/firefox
   *
   * xdr.subDomain
   * cross sub domain request config object
   *
   * xdr.subDomain.proxy
   * proxy page, eg:
   * a.t.cn/a.htm send request to b.t.cn/b.htm:
   *
   * 1. a.htm set <code> document.domain='t.cn' </code>
   *
   * 2. b.t.cn/proxy.htm 's content is <code> &lt;script>document.domain='t.cn'&lt;/script> </code>
   *
   * 3. in a.htm , call <code> IO({xdr:{subDomain:{proxy:'/proxy.htm'}}}) </code>
   *
   */
  function IO(c) {
    var self = this;
    if (!(self instanceof IO)) {
      return new IO(c);
    }
    // Promise.call(self);
    IO.superclass.constructor.call(self);
    XPromise.Defer(self);
    self.userConfig = c;
    c = setUpConfig(c);
    util.mix(self, {
      // 结构化数据，如 json
      responseData: null,
      /**
       * config of current IO instance.
       * @member IO
       * @property config
       * @type Object
       */
      config: c || {},
      timeoutTimer: null,
      /**
       * String typed data returned from server
       * @type String
       */
      responseText: null,
      /**
       * xml typed data returned from server
       * @type String
       */
      responseXML: null,
      responseHeadersString: '',
      responseHeaders: null,
      requestHeaders: {},
      /**
       * readyState of current request
       * 0: initialized
       * 1: send
       * 4: completed
       * @type Number
       */
      readyState: 0,
      state: 0,
      /**
       * HTTP statusText of current request
       * @type String
       */
      statusText: null,
      /**
       * HTTP Status Code of current request
       * eg:
       * 200: ok
       * 404: Not Found
       * 500: Server Error
       * @type String
       */
      status: 0,
      transport: null
    });
    var TransportConstructor, transport;
    /**
     * fired before generating request object
     * @event start
     * @member IO
     * @static
     * @param {IO} e.io current io
     */
    IO.callPreprocessors('start', { io: self });
    IO.fire('start', { io: self });
    TransportConstructor = transports[c.dataType[0]] || transports['*'];
    transport = new TransportConstructor(self);
    self.transport = transport;
    if (c.contentType) {
      self.setRequestHeader('Content-Type', c.contentType);
    }
    var dataType = c.dataType[0], i, timeout = c.timeout, context = c.context, headers = c.headers, accepts = c.accepts;
    // Set the Accepts header for the server, depending on the dataType
    self.setRequestHeader('Accept', dataType && accepts[dataType] ? accepts[dataType] + (dataType === '*' ? '' : ', */*; q=0.01') : accepts['*']);
    // Check for headers option
    for (i in headers) {
      self.setRequestHeader(i, headers[i]);
    }
    // allow setup native listener
    // such as xhr.upload.addEventListener('progress', function (ev) {})
    if (c.beforeSend && c.beforeSend.call(context, self, c) === false) {
      return self;
    }
    self.readyState = 1;
    /**
     * fired before sending request
     * @event send
     * @member IO
     * @static
     * @param {IO} e.io current io
     */
    IO.callPreprocessors('send', { io: self });
    IO.fire('send', { io: self });
    // Timeout
    if (c.async && timeout > 0) {
      self.timeoutTimer = setTimeout(function () {
        self.abort('timeout');
      }, timeout * 1000);
    }
    try {
      // flag as sending
      self.state = 1;
      transport.send();
    } catch (e) {
      if ('@DEBUG@') {
        console.error(e.stack || e);
        setTimeout(function () {
          throw e;
        }, 0);
      }
      // Propagate exception as error if not done
      if (self.state < 2) {
        self._ioReady(0 - 1, e.message || 'send error');
      }
    }
    return self;
  }
  var preprocessors = {};
  var events = {};
  util.mix(IO, {
    preprocessors: preprocessors,
    events: events,
    addPreprocessor: function (type, callback) {
      var callbacks = preprocessors[type] = preprocessors[type] || [];
      callbacks.push(callback);
      return IO;
    },
    callPreprocessors: function (type, info) {
      var callbacks = (preprocessors[type] || []).concat();
      for (var i = 0, l = callbacks.length; i < l; i++) {
        callbacks[i].call(IO, info);
      }
    },
    on: function (type, callback) {
      var callbacks = events[type] = events[type] || [];
      callbacks.push(callback);
      return IO;
    },
    detach: function (type, callback) {
      if (callback) {
        var list = events[type];
        if (list) {
          var index = util.indexOf(callback, list);
          if (index !== -1) {
            list.splice(index, 1);
          }
        }
      } else {
        events[type] = [];
      }
    },
    fire: function (type, info) {
      var callbacks = (events[type] || []).concat();
      info = info || {};
      info.type = type;
      info.target = info.currentTarget = IO;
      for (var i = 0, l = callbacks.length; i < l; i++) {
        callbacks[i].call(IO, info);
      }
    },
    /**
     * whether current application is a local application
     * (protocol is file://,widget://,about://)
     * @type {Boolean}
     * @member IO
     * @static
     */
    isLocal: isLocal,
    /**
     * name-value object that set default config value for io class
     * @param {Object} setting
     * @member IO
     * @static
     */
    setupConfig: function (setting) {
      util.mix(defaultConfig, setting, { deep: true });
    },
    /**
     * @private
     * @member IO
     * @static
     */
    setupTransport: function (name, fn) {
      transports[name] = fn;
    },
    /**
     * @private
     * @member IO
     * @static
     */
    getTransport: function (name) {
      return transports[name];
    },
    /**
     * get default config value for io request
     * @return {Object}
     * @member IO
     * @static
     */
    getConfig: function () {
      return defaultConfig;
    }
  });
  exports = IO;
  return exports;
}();
ioBaseLibMainUtils = function (exports) {
  function addEvent(el, type, callback) {
    if (el.addEventListener) {
      el.addEventListener(type, callback, false);
    } else if (el.attachEvent) {
      el.attachEvent('on' + type, callback);
    }
  }
  function removeEvent(el, type, callback) {
    if (el.removeEventListener) {
      el.removeEventListener(type, callback, false);
    } else if (el.detachEvent) {
      el.detachEvent('on' + type, callback);
    }
  }
  var utils = {
    addEvent: addEvent,
    removeEvent: removeEvent
  };
  function numberify(s) {
    var c = 0;
    return parseFloat(s.replace(/\./g, function () {
      return c++ === 0 ? '.' : '';
    }));
  }
  var m, v;
  var ua = (window.navigator || {}).userAgent || '';
  if ((m = ua.match(/MSIE ([^;]*)|Trident.*; rv(?:\s|:)?([0-9.]+)/)) && (v = m[1] || m[2])) {
    utils.ie = numberify(v);
    utils.ieMode = document.documentMode || utils.ie;
  }
  exports = utils;
  return exports;
}();
ioBaseLibMainXhrTransportBase = function (exports) {
  var util = utilBase;
  var url = _url_;
  var querystring = _querystring_;
  var IO = ioBaseLibMainBase;
  var ioUtil = ioBaseLibMainUtils;
  var OK_CODE = 200, supportCORS, win = window, XDomainRequest_ = ioUtil.ieMode > 7 && win.XDomainRequest, NO_CONTENT_CODE = 204, NOT_FOUND_CODE = 404, NO_CONTENT_CODE2 = 1223, XhrTransportBase = { proto: {} }, lastModifiedCached = {}, eTagCached = {};
  IO.__lastModifiedCached = lastModifiedCached;
  IO.__eTagCached = eTagCached;
  XhrTransportBase.nativeXhr = win.ActiveXObject ? function (crossDomain, refWin) {
    if (!supportCORS && crossDomain && XDomainRequest_) {
      return new XDomainRequest_();
    }
    return !IO.isLocal && createStandardXHR(crossDomain, refWin) || createActiveXHR(crossDomain, refWin);
  } : createStandardXHR;
  supportCORS = XhrTransportBase.supportCORS = 'withCredentials' in XhrTransportBase.nativeXhr();
  function createStandardXHR(_, refWin) {
    try {
      return new (refWin || win).XMLHttpRequest();
    } catch (e) {
    }
    return undefined;
  }
  function createActiveXHR(_, refWin) {
    try {
      return new (refWin || win).ActiveXObject('Microsoft.XMLHTTP');
    } catch (e) {
    }
    return undefined;
  }
  XhrTransportBase.XDomainRequest_ = XDomainRequest_;
  function isInstanceOfXDomainRequest(xhr) {
    return XDomainRequest_ && xhr instanceof XDomainRequest_;
  }
  function getIfModifiedKey(c) {
    var ifModified = c.ifModified, ifModifiedKey;
    if (ifModified) {
      ifModifiedKey = c.uri;
      if (c.cache === false) {
        ifModifiedKey = util.clone(ifModifiedKey);
        delete ifModifiedKey.query._ksTS;
      }
      ifModifiedKey = url.stringify(ifModifiedKey);
    }
    return ifModifiedKey;
  }
  util.mix(XhrTransportBase.proto, {
    sendInternal: function () {
      var self = this, io = self.io, c = io.config, nativeXhr = self.nativeXhr, files = c.files, type = files ? 'post' : c.type, async = c.async, username, mimeType = io.mimeType, requestHeaders = io.requestHeaders || {}, url = io._getUrlForSend(), xhrFields, ifModifiedKey = getIfModifiedKey(c), cacheValue, i;
      if (ifModifiedKey) {
        if (cacheValue = lastModifiedCached[ifModifiedKey]) {
          requestHeaders['If-Modified-Since'] = cacheValue;
        }
        if (cacheValue = eTagCached[ifModifiedKey]) {
          requestHeaders['If-None-Match'] = cacheValue;
        }
      }
      if (username = c.username) {
        nativeXhr.open(type, url, async, username, c.password);
      } else {
        nativeXhr.open(type, url, async);
      }
      xhrFields = c.xhrFields || {};
      if ('withCredentials' in xhrFields) {
        if (!supportCORS) {
          delete xhrFields.withCredentials;
        }
      }
      for (i in xhrFields) {
        try {
          nativeXhr[i] = xhrFields[i];
        } catch (e) {
        }
      }
      if (mimeType && nativeXhr.overrideMimeType) {
        nativeXhr.overrideMimeType(mimeType);
      }
      var xRequestHeader = requestHeaders['X-Requested-With'];
      if (xRequestHeader === false) {
        delete requestHeaders['X-Requested-With'];
      }
      if (typeof nativeXhr.setRequestHeader !== 'undefined') {
        for (i in requestHeaders) {
          nativeXhr.setRequestHeader(i, requestHeaders[i]);
        }
      }
      var sendContent = c.hasContent && c.data || null;
      if (files) {
        var originalSentContent = sendContent, data = {};
        if (originalSentContent) {
          data = querystring.parse(originalSentContent);
        }
        data = util.mix(data, files);
        sendContent = new FormData();
        util.each(data, function (vs, k) {
          if (util.isArray(vs)) {
            util.each(vs, function (v) {
              sendContent.append(k + (c.serializeArray ? '[]' : ''), v);
            });
          } else {
            sendContent.append(k, vs);
          }
        });
      }
      nativeXhr.send(sendContent);
      if (!async || nativeXhr.readyState === 4) {
        self._callback();
      } else {
        if (isInstanceOfXDomainRequest(nativeXhr)) {
          nativeXhr.onload = function () {
            nativeXhr.readyState = 4;
            nativeXhr.status = 200;
            self._callback();
          };
          nativeXhr.onerror = function () {
            nativeXhr.readyState = 4;
            nativeXhr.status = 500;
            self._callback();
          };
        } else {
          nativeXhr.onreadystatechange = function () {
            self._callback();
          };
        }
      }
    },
    abort: function () {
      this._callback(0, 1);
    },
    _callback: function (event, abort) {
      var self = this, nativeXhr = self.nativeXhr, io = self.io, ifModifiedKey, lastModified, eTag, statusText, xml, c = io.config;
      try {
        if (abort || nativeXhr.readyState === 4) {
          if (isInstanceOfXDomainRequest(nativeXhr)) {
            nativeXhr.onerror = util.noop;
            nativeXhr.onload = util.noop;
          } else {
            nativeXhr.onreadystatechange = util.noop;
          }
          if (abort) {
            if (nativeXhr.readyState !== 4) {
              nativeXhr.abort();
            }
          } else {
            ifModifiedKey = getIfModifiedKey(c);
            var status = nativeXhr.status;
            if (!isInstanceOfXDomainRequest(nativeXhr)) {
              io.responseHeadersString = nativeXhr.getAllResponseHeaders();
            }
            if (ifModifiedKey) {
              lastModified = nativeXhr.getResponseHeader('Last-Modified');
              eTag = nativeXhr.getResponseHeader('ETag');
              if (lastModified) {
                lastModifiedCached[ifModifiedKey] = lastModified;
              }
              if (eTag) {
                eTagCached[eTag] = eTag;
              }
            }
            xml = nativeXhr.responseXML;
            if (xml && xml.documentElement) {
              io.responseXML = xml;
            }
            var text = io.responseText = nativeXhr.responseText;
            if (c.files && text) {
              var bodyIndex, lastBodyIndex;
              if ((bodyIndex = text.indexOf('<body>')) !== -1) {
                lastBodyIndex = text.lastIndexOf('</body>');
                if (lastBodyIndex === -1) {
                  lastBodyIndex = text.length;
                }
                text = text.slice(bodyIndex + 6, lastBodyIndex);
              }
              io.responseText = util.unEscapeHtml ? util.unEscapeHtml(text) : text;
            }
            try {
              statusText = nativeXhr.statusText;
            } catch (e) {
              statusText = '';
            }
            if (!status && IO.isLocal && !c.crossDomain) {
              status = io.responseText ? OK_CODE : NOT_FOUND_CODE;
            } else if (status === NO_CONTENT_CODE2) {
              status = NO_CONTENT_CODE;
            }
            io._ioReady(status, statusText);
          }
        }
      } catch (e) {
        if ('@DEBUG@') {
          console.error(e.stack || e);
          setTimeout(function () {
            throw e;
          }, 0);
        }
        nativeXhr.onreadystatechange = util.noop;
        if (!abort) {
          io._ioReady(0 - 1, e.message || 'process error');
        }
      }
    }
  });
  exports = XhrTransportBase;
  return exports;
}();
ioBaseLibMainSubDomainTransport = function (exports) {
  var util = utilBase;
  var ioUtil = ioBaseLibMainUtils;
  var url = _url_;
  var Dom = domBase;
  var XhrTransportBase = ioBaseLibMainXhrTransportBase;
  var PROXY_PAGE = '/sub_domain_proxy.html';
  var doc = document;
  var iframeMap = {};
  function SubDomainTransport(io) {
    var self = this, c = io.config;
    self.io = io;
    c.crossDomain = false;
    self._onLoad = util.bind(onLoad, self);
  }
  util.augment(SubDomainTransport, XhrTransportBase.proto, {
    send: function () {
      var self = this, c = self.io.config, uri = c.uri, hostname = uri.hostname, iframe, iframeUri, iframeDesc = iframeMap[hostname];
      var proxy = PROXY_PAGE;
      if (c.xdr && c.xdr.subDomain && c.xdr.subDomain.proxy) {
        proxy = c.xdr.subDomain.proxy;
      }
      if (iframeDesc && iframeDesc.ready) {
        self.nativeXhr = XhrTransportBase.nativeXhr(0, iframeDesc.iframe.contentWindow);
        if (self.nativeXhr) {
          self.sendInternal();
        } else {
          console.error('io: document.domain not set correctly!');
        }
        return;
      }
      if (!iframeDesc) {
        iframeDesc = iframeMap[hostname] = {};
        iframe = iframeDesc.iframe = doc.createElement('iframe');
        Dom.css(iframe, {
          position: 'absolute',
          left: '-9999px',
          top: '-9999px'
        });
        Dom.prepend(iframe, doc.body || doc.documentElement);
        iframeUri = {};
        iframeUri.protocol = uri.protocol;
        iframeUri.host = uri.host;
        iframeUri.pathname = proxy;
        iframe.src = url.stringify(iframeUri);
      } else {
        iframe = iframeDesc.iframe;
      }
      ioUtil.addEvent(iframe, 'load', self._onLoad);
    }
  });
  function onLoad() {
    var self = this, c = self.io.config, uri = c.uri, hostname = uri.hostname, iframeDesc = iframeMap[hostname];
    iframeDesc.ready = 1;
    ioUtil.removeEvent(iframeDesc.iframe, 'load', self._onLoad);
    self.send();
  }
  exports = SubDomainTransport;
  return exports;
}();
ioBaseLibMainScriptTransport = function (exports) {
  var util = utilBase;
  var IO = ioBaseLibMainBase;
  var OK_CODE = 200, ERROR_CODE = 500;
  IO.setupConfig({
    accepts: { script: 'text/javascript, ' + 'application/javascript, ' + 'application/ecmascript, ' + 'application/x-ecmascript' },
    contents: { script: /javascript|ecmascript/ },
    converters: {
      text: {
        script: function (text) {
          util.globalEval(text);
          return text;
        }
      }
    }
  });
  function ScriptTransport(io) {
    var config = io.config, self = this;
    if (!config.crossDomain) {
      return new (IO.getTransport('*'))(io);
    }
    self.io = io;
    return self;
  }
  util.augment(ScriptTransport, {
    send: function () {
      var self = this, io = self.io, c = io.config;
      self.script = IO.getScript(io._getUrlForSend(), {
        charset: c.scriptCharset,
        success: function () {
          self._callback('success');
        },
        error: function () {
          self._callback('error');
        }
      });
    },
    _callback: function (event, abort) {
      var self = this, script = self.script, io = self.io;
      if (!script) {
        return;
      }
      self.script = undefined;
      if (abort) {
        return;
      }
      if (event !== 'error') {
        io._ioReady(OK_CODE, 'success');
      } else if (event === 'error') {
        io._ioReady(ERROR_CODE, 'script error');
      }
    },
    abort: function () {
      this._callback(0, 1);
    }
  });
  IO.setupTransport('script', ScriptTransport);
  return exports;
}();
ioBaseLibMainJsonp = function (exports) {
  var util = utilBase;
  var IO = ioBaseLibMainBase;
  var win = window;
  IO.setupConfig({
    jsonp: 'callback',
    jsonpCallback: function () {
      return util.guid('jsonp');
    }
  });
  IO.addPreprocessor('start', function (e) {
    var io = e.io, c = io.config, dataType = c.dataType;
    if (dataType[0] === 'jsonp') {
      delete c.contentType;
      var response, cJsonpCallback = c.jsonpCallback, converters, jsonpCallback = typeof cJsonpCallback === 'function' ? cJsonpCallback() : cJsonpCallback, previous = win[jsonpCallback];
      c.uri.query[c.jsonp] = jsonpCallback;
      win[jsonpCallback] = function (r) {
        if (arguments.length > 1) {
          r = util.makeArray(arguments);
        }
        response = [r];
      };
      io.fin(function () {
        win[jsonpCallback] = previous;
        if (previous === undefined) {
          try {
            delete win[jsonpCallback];
          } catch (e) {
          }
        } else if (response) {
          previous(response[0]);
        }
      });
      converters = c.converters;
      converters.script = converters.script || {};
      converters.script.json = function () {
        if (!response) {
          throw new Error('not call jsonpCallback: ' + jsonpCallback);
        }
        return response[0];
      };
      dataType.length = 2;
      dataType[0] = 'script';
      dataType[1] = 'json';
    }
  });
  return exports;
}();
ioBaseLibMainMethods = function (exports) {
  var util = utilBase;
  var XPromise = promise;
  var IO = ioBaseLibMainBase;
  var url = _url_;
  var OK_CODE = 200, MULTIPLE_CHOICES = 300, NOT_MODIFIED = 304, HEADER_REG = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm;
  function handleResponseData(io) {
    var text = io.responseText, xml = io.responseXML, c = io.config, converts = c.converters, type, contentType, responseData, contents = c.contents, dataType = c.dataType;
    if (text || xml) {
      contentType = io.mimeType || io.getResponseHeader('Content-Type');
      while (dataType[0] === '*') {
        dataType.shift();
      }
      if (!dataType.length) {
        for (type in contents) {
          if (contents[type].test(contentType)) {
            if (dataType[0] !== type) {
              dataType.unshift(type);
            }
            break;
          }
        }
      }
      dataType[0] = dataType[0] || 'text';
      for (var dataTypeIndex = 0; dataTypeIndex < dataType.length; dataTypeIndex++) {
        if (dataType[dataTypeIndex] === 'text' && text !== undefined) {
          responseData = text;
          break;
        } else if (dataType[dataTypeIndex] === 'xml' && xml !== undefined) {
          responseData = xml;
          break;
        }
      }
      if (!responseData) {
        var rawData = {
          text: text,
          xml: xml
        };
        util.each([
          'text',
          'xml'
        ], function (prevType) {
          var type = dataType[0], converter = converts[prevType] && converts[prevType][type];
          if (converter && rawData[prevType]) {
            dataType.unshift(prevType);
            responseData = prevType === 'text' ? text : xml;
            return false;
          }
          return undefined;
        });
      }
    }
    var prevType = dataType[0];
    for (var i = 1; i < dataType.length; i++) {
      type = dataType[i];
      var converter = converts[prevType] && converts[prevType][type];
      if (!converter) {
        throw new Error('no covert for ' + prevType + ' => ' + type);
      }
      responseData = converter(responseData);
      prevType = type;
    }
    io.responseData = responseData;
  }
  util.extend(IO, XPromise, {
    setRequestHeader: function (name, value) {
      var self = this;
      self.requestHeaders[name] = value;
      return self;
    },
    getAllResponseHeaders: function () {
      var self = this;
      return self.state === 2 ? self.responseHeadersString : null;
    },
    getResponseHeader: function (name) {
      var match, responseHeaders, self = this;
      name = name.toLowerCase();
      if (self.state === 2) {
        if (!(responseHeaders = self.responseHeaders)) {
          responseHeaders = self.responseHeaders = {};
          while (match = HEADER_REG.exec(self.responseHeadersString)) {
            responseHeaders[match[1].toLowerCase()] = match[2];
          }
        }
        match = responseHeaders[name];
      }
      return match === undefined ? null : match;
    },
    overrideMimeType: function (type) {
      var self = this;
      if (!self.state) {
        self.mimeType = type;
      }
      return self;
    },
    abort: function (statusText) {
      var self = this;
      statusText = statusText || 'abort';
      if (self.transport) {
        self.transport.abort(statusText);
      }
      self._ioReady(0, statusText);
      return self;
    },
    getNativeXhr: function () {
      var transport = this.transport;
      if (transport) {
        return transport.nativeXhr;
      }
      return null;
    },
    _ioReady: function (status, statusText) {
      var self = this;
      if (self.state === 2) {
        return;
      }
      self.state = 2;
      self.readyState = 4;
      var isSuccess;
      if (status >= OK_CODE && status < MULTIPLE_CHOICES || status === NOT_MODIFIED) {
        if (status === NOT_MODIFIED) {
          statusText = 'not modified';
          isSuccess = true;
        } else {
          try {
            handleResponseData(self);
            statusText = 'success';
            isSuccess = true;
          } catch (e) {
            if ('@DEBUG@') {
              console.error(e.stack || e);
              setTimeout(function () {
                throw e;
              }, 0);
            }
            statusText = e.message || 'parser error';
          }
        }
      } else {
        if (status < 0) {
          status = 0;
        }
      }
      self.status = status;
      self.statusText = statusText;
      var defer = self.defer, config = self.config, timeoutTimer;
      if (timeoutTimer = self.timeoutTimer) {
        clearTimeout(timeoutTimer);
        self.timeoutTimer = 0;
      }
      var handler = isSuccess ? 'success' : 'error', h, v = [
          self.responseData,
          statusText,
          self
        ], context = config.context, eventObject = { io: self };
      if (h = config[handler]) {
        h.apply(context, v);
      }
      if (h = config.complete) {
        h.apply(context, v);
      }
      IO.fire(handler, eventObject);
      IO.fire('complete', eventObject);
      defer[isSuccess ? 'resolve' : 'reject'](v);
    },
    _getUrlForSend: function () {
      var c = this.config, uri = c.uri;
      var search = uri.search || '';
      delete uri.search;
      if (search && !util.isEmptyObject(uri.query)) {
        search = '&' + search.substring(1);
      }
      return url.stringify(uri, c.serializeArray) + search;
    }
  });
  return exports;
}();
ioBaseLibMainIo = function (exports) {
  var IO = ioBaseLibMainBase;
  var util = utilBase;
  var getScript = ioScript;
  function get(url, data, callback, dataType, type) {
    if (typeof data === 'function') {
      dataType = callback;
      callback = data;
      data = undefined;
    }
    return IO({
      type: type || 'get',
      url: url,
      data: data,
      complete: callback,
      dataType: dataType
    });
  }
  util.mix(IO, {
    getScript: getScript,
    get: get,
    post: function (url, data, callback, dataType) {
      if (typeof data === 'function') {
        dataType = callback;
        callback = data;
        data = undefined;
      }
      return get(url, data, callback, dataType, 'post');
    },
    jsonp: function (url, data, callback) {
      if (util.isPlainObject(url)) {
        var config = url;
        url = config.url;
        data = config.data;
        callback = config.success;
      } else if (typeof data === 'function') {
        callback = data;
        data = undefined;
      }
      return get(url, data, callback, 'jsonp');
    },
    getJSON: function (url, data, callback) {
      if (typeof data === 'function') {
        callback = data;
        data = undefined;
      }
      return get(url, data, callback, 'json');
    }
  });
  exports = IO;
  return exports;
}();
ioBaseLibMainXhrTransport = function (exports) {
  var util = utilBase;
  var IO = ioBaseLibMainBase, XhrTransportBase = ioBaseLibMainXhrTransportBase, SubDomainTransport = ioBaseLibMainSubDomainTransport;
  var doc = document;
  function isSubDomain(hostname) {
    return doc.domain && util.endsWith(hostname, doc.domain);
  }
  function XhrTransport(io) {
    var c = io.config, crossDomain = c.crossDomain, self = this, xhr, xdrCfg = c.xdr || {}, subDomain = xdrCfg.subDomain = xdrCfg.subDomain || {};
    self.io = io;
    if (crossDomain && !XhrTransportBase.supportCORS) {
      if (isSubDomain(c.uri.hostname)) {
        if (subDomain.proxy !== false) {
          return new SubDomainTransport(io);
        }
      }
    }
    xhr = self.nativeXhr = XhrTransportBase.nativeXhr(crossDomain);
    return self;
  }
  util.augment(XhrTransport, XhrTransportBase.proto, {
    send: function () {
      this.sendInternal();
    }
  });
  IO.setupTransport('*', XhrTransport);
  return exports;
}();
ioBaseLibMain = function (exports) {
  var IO = ioBaseLibMainIo;
  var ioUtil = ioBaseLibMainUtils;
  ioBaseLibMainXhrTransport;
  ioBaseLibMainScriptTransport;
  ioBaseLibMainJsonp;
  ioBaseLibMainMethods;
  IO._util = ioUtil;
  exports = IO;
  return exports;
}();
ioBaseIndex = function (exports) {
  exports = ioBaseLibMain;
  return exports;
}();
return ioBaseIndex;
});define("promise", [], function(require) {

//! Copyright 2015, promise@6.1.1 MIT Licensed, build time: Thu, 29 Oct 2015 12:29:42 GMT 
/*
combined modules:
promise
promise/lib/promise
*/
var promiseLibPromise, promiseIndex;
promiseLibPromise = function (exports) {
  /**
   * @ignore
   * implement Promise specification
   * @author yiminghe@gmail.com
   */
  var PROMISE_VALUE = '__promise_value';
  var PROMISE_STATUS = '__promise_status';
  var PROMISE_PROGRESS_LISTENERS = '__promise_progress_listeners';
  var PROMISE_PENDINGS = '__promise_pendings';
  var PENDING = 'Pending';
  var FULFILLED = 'Fulfilled';
  var REJECTED = 'Rejected';
  function each(arr, fn) {
    if (arr) {
      for (var i = 0, l = arr.length; i < l; i++) {
        if (fn(arr[i], i) === false) {
          break;
        }
      }
    }
  }
  function mix(r, s) {
    for (var p in s) {
      r[p] = s[p];
    }
  }
  function isThenable(v) {
    return v && typeof v.then === 'function';
  }
  /*
   two effects:
   1. call fulfilled with immediate value
   2. push fulfilled in right promise
   */
  function promiseWhen(promise, fulfilled, rejected) {
    // simply call rejected
    if (promise instanceof Reject) {
      // if there is a rejected , should always has! see when()
      rejected.call(promise, promise.reason);
    } else if (!(promise instanceof Promise) && isThenable(promise)) {
      // flatten
      promise.then(fulfilled, rejected);
    } else {
      var v = promise[PROMISE_VALUE];
      if (isThenable(v) || v instanceof Reject) {
        // rejected or nested promise
        promiseWhen(v, fulfilled, rejected);
        return;
      }
      if (promise[PROMISE_STATUS] === PENDING) {
        // flatten
        promise[PROMISE_PENDINGS].push([
          fulfilled,
          rejected
        ]);
      } else {
        // fulfilled value
        // normal value represents ok
        // need return user's return value
        // if return promise then forward
        if (fulfilled) {
          fulfilled.call(promise, v);
        }
      }
    }
  }
  /**
   * @class Defer
   * Defer constructor For KISSY, implement Promise specification.
   */
  function Defer(promise) {
    var self = this;
    if (!(self instanceof Defer)) {
      return new Defer(promise);
    }
    // http://en.wikipedia.org/wiki/Object-capability_model
    // principal of least authority
    /**
     * defer object's promise
     * @type {Promise}
     */
    self.promise = promise || new Promise();
    self.promise.defer = self;
  }
  Defer.prototype = {
    constructor: Defer,
    /**
     * fulfill defer object's promise
     * note: can only be called once
     * @param value defer object's value
     * @return {Promise} defer object's promise
     */
    resolve: function (value) {
      var promise = this.promise;
      if (promise[PROMISE_STATUS] !== PENDING) {
        return null;
      }
      promise[PROMISE_STATUS] = value instanceof Reject ? REJECTED : FULFILLED;
      // set current promise 's resolved value
      // maybe a promise or instant value
      promise[PROMISE_VALUE] = value;
      var pendings = promise[PROMISE_PENDINGS];
      each(pendings, function (p) {
        promiseWhen(promise, p[0], p[1]);
      });
      promise[PROMISE_PENDINGS] = [];
      promise[PROMISE_PROGRESS_LISTENERS] = [];
      return this.promise;
    },
    /**
     * reject defer object's promise
     * @param reason
     * @return {Promise} defer object's promise
     */
    reject: function (reason) {
      return this.resolve(new Reject(reason));
    },
    /**
     * notify promise 's progress listeners
     * @param message
     */
    notify: function (message) {
      if (this.promise[PROMISE_STATUS] !== PENDING) {
        return null;
      }
      each(this.promise[PROMISE_PROGRESS_LISTENERS], function (listener) {
        listener(message);
      });
    }
  };
  function isPromise(obj) {
    return obj && obj instanceof Promise;
  }
  function bind(fn, context) {
    return function () {
      return fn.apply(context, arguments);
    };
  }
  /**
   * @class Promise
   * Promise constructor.
   * This class should not be instantiated manually.
   * Instances will be created and returned as needed by {@link Defer#promise}
   * @param [v] promise 's resolved value
   */
  function Promise(v) {
    var self = this;
    self[PROMISE_PENDINGS] = [];
    self[PROMISE_PROGRESS_LISTENERS] = [];
    if (!v) {
      self[PROMISE_STATUS] = PENDING;
    } else if (typeof v === 'function') {
      self[PROMISE_STATUS] = PENDING;
      var defer = new Defer(self);
      var resolve = bind(defer.resolve, defer);
      var reject = bind(defer.reject, defer);
      try {
        v(resolve, reject);
      } catch (e) {
        reject(e);
        throw new Error(e.stack || e);
      }
    } else {
      self[PROMISE_STATUS] = FULFILLED;
    }
  }
  Promise.prototype = {
    constructor: Promise,
    /**
     * register callbacks when this promise object is resolved
     * @param {Function} fulfilled called when resolved successfully,pass a resolved value to this function and
     * return a value (could be promise object) for the new promise 's resolved value.
     * @param {Function} [rejected] called when error occurs,pass error reason to this function and
     * return a new reason for the new promise 's error reason
     * @param {Function} [progressListener] progress listener
     * @return {Promise} a new promise object
     */
    then: function (fulfilled, rejected, progressListener) {
      if (progressListener) {
        this.progress(progressListener);
      }
      return when(this, fulfilled, rejected);
    },
    /**
     * call progress listener when defer.notify is called
     * @param {Function} [progressListener] progress listener
     */
    progress: function (progressListener) {
      var self = this;
      var listeners = self[PROMISE_PROGRESS_LISTENERS];
      if (self[PROMISE_STATUS] !== PENDING) {
        return self;
      }
      if (!listeners) {
        listeners = self[PROMISE_PROGRESS_LISTENERS] = [];
      }
      listeners.push(progressListener);
      return self;
    },
    /**
     * call rejected callback when this promise object is rejected
     * @param {Function} rejected called with rejected reason
     * @return {Promise} a new promise object
     */
    fail: function (rejected) {
      return this.then(0, rejected);
    },
    /**
     * call callback when this promise object is rejected or resolved
     * @param {Function} callback the second parameter is
     * true when resolved and false when rejected
     * @@return {Promise} a new promise object
     */
    fin: function (callback) {
      return this.then(function (value) {
        return callback(value, true);
      }, function (reason) {
        return callback(reason, false);
      });
    },
    /**
     * register callbacks when this promise object is resolved,
     * and throw error at next event loop if promise
     * (current instance if no fulfilled and rejected parameter or
     * new instance caused by call this.then(fulfilled, rejected))
     * fails.
     * @param {Function} [fulfilled] called when resolved successfully,pass a resolved value to this function and
     * return a value (could be promise object) for the new promise 's resolved value.
     * @param {Function} [rejected] called when error occurs,pass error reason to this function and
     * return a new reason for the new promise 's error reason
     */
    done: function (fulfilled, rejected) {
      var self = this;
      var onUnhandledError = function (e) {
        setTimeout(function () {
          throw e;
        }, 0);
      };
      var promiseToHandle = fulfilled || rejected ? self.then(fulfilled, rejected) : self;
      promiseToHandle.fail(onUnhandledError);
    },
    /**
     * whether the given object is a resolved promise
     * if it is resolved with another promise,
     * then that promise needs to be resolved as well.
     * @member Promise
     */
    isResolved: function () {
      return isResolved(this);
    },
    /**
     * whether the given object is a rejected promise
     */
    isRejected: function () {
      return isRejected(this);
    }
  };
  /**
   * Sugar for promise.then(undefined, onRejected)
   * @method catch
   * @member {Promise}
   */
  /* eslint-disable */
  Promise.prototype['catch'] = Promise.prototype.fail;
  /* eslint-enable */
  /**
   * Reject promise
   * @param {String|Promise.Reject} reason reject reason
   * @class Promise.Reject
   * @extend Promise
   * @private
   */
  function Reject(reason) {
    if (reason instanceof Reject) {
      return reason;
    }
    this.reason = reason;
  }
  // wrap for promiseWhen
  function when(value, fulfilled, rejected) {
    var defer = new Defer();
    var done = 0;
    // wrap user's callback to catch exception
    function _fulfilled(val) {
      try {
        return fulfilled ? fulfilled.call(this, val) : /* propagate */
        val;
      } catch (ex) {
        // can not use logger.error
        // must expose to user
        // print stack info for firefox/chrome
        /* eslint-disable */
        if (window.console) {
          console.error(ex.stack || ex);
        }
        /* eslint-enable */
        return new Reject(ex);
      }
    }
    function _rejected(reason) {
      try {
        return rejected ? /* error recovery */
        rejected.call(this, reason) : /* propagate */
        new Reject(reason);
      } catch (ex) {
        // print stack info for firefox/chrome
        /* eslint-disable */
        if (window.console) {
          console.error(ex.stack || ex);
        }
        /* eslint-enable */
        return new Reject(ex);
      }
    }
    function finalFulfill(val) {
      if (done) {
        return;
      }
      done = 1;
      defer.resolve(_fulfilled.call(this, val));
    }
    if (isThenable(value)) {
      promiseWhen(value, finalFulfill, function (reason) {
        if (done) {
          return;
        }
        done = 1;
        // _reject may return non-Reject object for error recovery
        defer.resolve(_rejected.call(this, reason));
      });
    } else {
      finalFulfill(value);
    }
    // chained and leveled
    // wait for value's resolve
    return defer.promise;
  }
  function isResolved(obj) {
    // exclude Reject at first
    return obj && obj[PROMISE_STATUS] === FULFILLED;
  }
  function isRejected(obj) {
    // implicit by obj[PROMISE_VALUE]
    // isPromise(obj) &&
    return obj && obj[PROMISE_STATUS] === REJECTED;
  }
  Promise.Defer = Defer;
  mix(Promise, {
    /**
     * register callbacks when obj as a promise is resolved
     * or call fulfilled callback directly when obj is not a promise object
     * @param {Promise|*} obj a promise object or value of any type
     * @param {Function} fulfilled called when obj resolved successfully,pass a resolved value to this function and
     * return a value (could be promise object) for the new promise 's resolved value.
     * @param {Function} [rejected] called when error occurs in obj,pass error reason to this function and
     * return a new reason for the new promise 's error reason
     * @return {Promise} a new promise object
     *
     * for example:
     * @example
     * function check(p) {
    *   Promise.when(p, function(v){
    *     alert(v === 1);
    *   });
    * }
     *
     * var defer = S.Defer();
     * defer.resolve(1);
     *
     * check(1); // => alert(true)
     *
     * check(defer.promise); //=> alert(true);
     *
     * @static
     * @method
     * @member Promise
     */
    when: when,
    /**
     * Returns promise (only if promise.constructor == Promise)
     * or
     * Make a promise that fulfills to obj.
     */
    cast: function (obj) {
      if (obj instanceof Promise) {
        return obj;
      }
      return new Promise(function (resolve) {
        resolve(obj);
      });
    },
    /**
     * Make a promise that fulfills to obj.
     */
    resolve: function (obj) {
      return new Promise(function (resolve) {
        resolve(obj);
      });
    },
    /**
     * Make a promise that rejects to obj. For consistency and debugging (e.g. stack traces), obj should be an instanceof Error.
     * @param reason
     * @returns {Promise.Reject}
     */
    reject: function (reason) {
      return new Promise(function (resolve, reject) {
        reject(reason);
      });
    },
    /**
     * whether the given object is a promise
     * @method
     * @static
     * @param obj the tested object
     * @return {Boolean}
     * @member Promise
     */
    isPromise: isPromise,
    /**
     * whether the given object is a resolved promise
     * @method
     * @static
     * @param obj the tested object
     * @return {Boolean}
     * @member Promise
     */
    isResolved: isResolved,
    /**
     * whether the given object is a rejected promise
     * @method
     * @static
     * @param obj the tested object
     * @return {Boolean}
     * @member Promise
     */
    isRejected: isRejected,
    /**
     * return a new promise
     * which is resolved when all promises is resolved
     * and rejected when any one of promises is rejected
     * @param {Promise[]} promises list of promises
     * @static
     * @return {Promise}
     * @member Promise
     */
    all: function (promises) {
      var count = promises.length;
      if (!count) {
        return null;
      }
      var defer = new Defer();
      for (var i = 0; i < promises.length; i++) {
        /*jshint loopfunc:true*/
        (function (promise, j) {
          when(promise, function (value) {
            promises[j] = value;
            if (--count === 0) {
              // if all is resolved
              // then resolve final returned promise with all value
              defer.resolve(promises);
            }
          }, function (r) {
            // if any one is rejected
            // then reject final return promise with first reason
            defer.reject(r);
          });
        }(promises[i], i));
      }
      return defer.promise;
    },
    /**
     * provide es6 generator
     * @param generatorFunc es6 generator function which has yielded promise
     */
    async: function (generatorFunc) {
      return function () {
        var generator = generatorFunc.apply(this, arguments);
        function doAction(action, arg) {
          var result;
          result = generator[action](arg);
          if (result.done) {
            return result.value;
          }
          return when(result.value, next, throwEx);
        }
        function next(v) {
          return doAction('next', v);
        }
        function throwEx(ex) {
          return doAction('throw', ex);
        }
        try {
          return next();
        } catch (ex) {
          return Promise.reject(ex);
        }
      };
    }
  });
  exports = Promise;
  return exports;
}();
promiseIndex = function (exports) {
  exports = promiseLibPromise;
  return exports;
}();
return promiseIndex;
});define("dom-base", ['util',"io-script","feature",'query-selector'], function(require) {
var utilBase = require('util');
var ioScript = require("io-script");
var feature = require("feature");
var querySelectorBase = require('query-selector');
//! Copyright 2015, dom-base@6.1.2 MIT Licensed, build time: Wed, 16 Dec 2015 08:07:53 GMT 
/*
combined modules:
dom-base
dom-base/lib/main
dom-base/lib/main/api
dom-base/lib/main/attr
dom-base/lib/main/class
dom-base/lib/main/create
dom-base/lib/main/data
dom-base/lib/main/insertion
dom-base/lib/main/offset
dom-base/lib/main/style
dom-base/lib/main/selector
dom-base/lib/main/traversal
*/
var domBaseLibMainApi, domBaseLibMainAttr, domBaseLibMainClass, domBaseLibMainCreate, domBaseLibMainData, domBaseLibMainInsertion, domBaseLibMainOffset, domBaseLibMainStyle, domBaseLibMainSelector, domBaseLibMainTraversal, domBaseLibMain, domBaseIndex;
domBaseLibMainApi = function (exports) {
  /**
   * @ignore
   * dom
   * @author yiminghe@gmail.com, lifesinger@gmail.com
   */
  var util = utilBase;
  var WINDOW = window;
  var DOCUMENT = WINDOW.document;
  var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
  /**
   * Dom Element node type.
   * @enum {Number} KISSY.DOM.NodeType
   */
  var NodeType = {
    /**
     * element type
     */
    ELEMENT_NODE: 1,
    /**
     * attribute node type
     */
    ATTRIBUTE_NODE: 2,
    /**
     * text node type
     */
    TEXT_NODE: 3,
    /**
     * cdata node type
     */
    CDATA_SECTION_NODE: 4,
    /**
     * entity reference node type
     */
    ENTITY_REFERENCE_NODE: 5,
    /**
     * entity node type
     */
    ENTITY_NODE: 6,
    /**
     * processing instruction node type
     */
    PROCESSING_INSTRUCTION_NODE: 7,
    /**
     * comment node type
     */
    COMMENT_NODE: 8,
    /**
     * document node type
     */
    DOCUMENT_NODE: 9,
    /**
     * document type
     */
    DOCUMENT_TYPE_NODE: 10,
    /**
     * document fragment type
     */
    DOCUMENT_FRAGMENT_NODE: 11,
    /**
     * notation type
     */
    NOTATION_NODE: 12
  };
  /**
   * KISSY Dom Utils.
   * Provides Dom helper methods.
   * @class KISSY.DOM
   * @singleton
   */
  var Dom = exports = {
    isCustomDomain: function (win) {
      win = win || WINDOW;
      win = Dom.get(win);
      var domain = win.document.domain;
      var hostname = win.location.hostname;
      return domain !== hostname && domain !== '[' + hostname + ']';
    },
    getEmptyIframeSrc: function () {
      return '';
    },
    NodeType: NodeType,
    getWindow: function (elem) {
      elem = Dom.get(elem);
      if (!elem || !elem.nodeType) {
        return WINDOW;
      }
      if (util.isWindow(elem)) {
        return elem;
      }
      var doc = elem;
      if (doc.nodeType !== NodeType.DOCUMENT_NODE) {
        doc = elem.ownerDocument;
      }
      return doc.defaultView || doc.parentWindow;
    },
    getDocument: function (elem) {
      if (!elem) {
        return DOCUMENT;
      }
      elem = Dom.get(elem);
      return util.isWindow(elem) ? elem.document : elem.nodeType === NodeType.DOCUMENT_NODE ? elem : elem.ownerDocument;
    },
    isDomNodeList: function (o) {
      return o && !o.nodeType && o.item && !o.setTimeout;
    },
    nodeName: function (selector) {
      var el = Dom.get(selector);
      var nodeName = el.nodeName.toLowerCase();
      var scopeName = el.scopeName;
      if (scopeName && scopeName !== 'HTML') {
        nodeName = scopeName.toLowerCase() + ':' + nodeName;
      }
      return nodeName;
    },
    _RE_NUM_NO_PX: new RegExp('^(' + RE_NUM + ')(?!px)[a-z%]+$', 'i')
  };
  return exports;
}();
domBaseLibMainAttr = function (exports) {
  var util = utilBase;
  var Dom = domBaseLibMainApi;
  var NodeType = Dom.NodeType;
  var EMPTY = '';
  var nodeName = Dom.nodeName;
  var R_BOOLEAN = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i;
  var R_FOCUSABLE = /^(?:button|input|object|select|textarea)$/i;
  var R_CLICKABLE = /^a(?:rea)?$/i;
  var R_INVALID_CHAR = /:|^on/;
  var R_RETURN = /\r/g;
  var attrFix = {};
  var attrFn = {
    val: 1,
    css: 1,
    html: 1,
    text: 1,
    data: 1,
    width: 1,
    height: 1,
    offset: 1,
    scrollTop: 1,
    scrollLeft: 1
  };
  var attrHooks = {
    tabindex: {
      get: function (el) {
        var attributeNode = el.getAttributeNode('tabindex');
        return attributeNode && attributeNode.specified ? parseInt(attributeNode.value, 10) : R_FOCUSABLE.test(el.nodeName) || R_CLICKABLE.test(el.nodeName) && el.href ? 0 : undefined;
      }
    }
  };
  var propFix = {
    hidefocus: 'hideFocus',
    tabindex: 'tabIndex',
    readonly: 'readOnly',
    'for': 'htmlFor',
    'class': 'className',
    maxlength: 'maxLength',
    cellspacing: 'cellSpacing',
    cellpadding: 'cellPadding',
    rowspan: 'rowSpan',
    colspan: 'colSpan',
    usemap: 'useMap',
    frameborder: 'frameBorder',
    contenteditable: 'contentEditable'
  };
  var boolHook = {
    get: function (elem, name) {
      return Dom.prop(elem, name) ? name.toLowerCase() : undefined;
    },
    set: function (elem, value, name) {
      var propName;
      if (value === false) {
        Dom.removeAttr(elem, name);
      } else {
        propName = propFix[name] || name;
        if (propName in elem) {
          elem[propName] = true;
        }
        elem.setAttribute(name, name.toLowerCase());
      }
      return name;
    }
  };
  var propHooks = {};
  var attrNodeHook = {};
  var valHooks = {
    select: {
      get: function (elem) {
        var index = elem.selectedIndex;
        var options = elem.options;
        var ret;
        var i;
        var len;
        var one = String(elem.type) === 'select-one';
        if (index < 0) {
          return null;
        } else if (one) {
          return Dom.val(options[index]);
        }
        ret = [];
        i = 0;
        len = options.length;
        for (; i < len; ++i) {
          if (options[i].selected) {
            ret.push(Dom.val(options[i]));
          }
        }
        return ret;
      },
      set: function (elem, value) {
        var values = util.makeArray(value);
        var opts = elem.options;
        util.each(opts, function (opt) {
          opt.selected = util.inArray(Dom.val(opt), values);
        });
        if (!values.length) {
          elem.selectedIndex = -1;
        }
        return values;
      }
    }
  };
  util.each([
    'radio',
    'checkbox'
  ], function (r) {
    valHooks[r] = {
      get: function (elem) {
        return elem.getAttribute('value') === null ? 'on' : elem.value;
      },
      set: function (elem, value) {
        if (util.isArray(value)) {
          elem.checked = util.inArray(Dom.val(elem), value);
          return 1;
        }
        return undefined;
      }
    };
  });
  attrHooks.style = {
    get: function (el) {
      return el.style.cssText;
    }
  };
  function toStr(value) {
    return value == null ? '' : value + '';
  }
  function getProp(elem, name) {
    name = propFix[name] || name;
    var hook = propHooks[name];
    if (hook && hook.get) {
      return hook.get(elem, name);
    } else {
      return elem[name];
    }
  }
  util.mix(Dom, {
    _valHooks: valHooks,
    _propFix: propFix,
    _attrHooks: attrHooks,
    _propHooks: propHooks,
    _attrNodeHook: attrNodeHook,
    _attrFix: attrFix,
    prop: function (selector, name, value) {
      var elems = Dom.query(selector);
      var i;
      var elem;
      var hook;
      if (typeof name === 'object') {
        util.each(name, function (v, k) {
          Dom.prop(elems, k, v);
        });
        return undefined;
      }
      name = propFix[name] || name;
      hook = propHooks[name];
      if (value !== undefined) {
        for (i = elems.length - 1; i >= 0; i--) {
          elem = elems[i];
          if (hook && hook.set) {
            hook.set(elem, value, name);
          } else {
            elem[name] = value;
          }
        }
      } else {
        if (elems.length) {
          return getProp(elems[0], name);
        }
      }
      return undefined;
    },
    removeProp: function (selector, name) {
      name = propFix[name] || name;
      var elems = Dom.query(selector);
      var i;
      var el;
      for (i = elems.length - 1; i >= 0; i--) {
        el = elems[i];
        try {
          el[name] = undefined;
          delete el[name];
        } catch (e) {
        }
      }
    },
    attr: function (selector, name, val, pass) {
      var els = Dom.query(selector);
      var el = els[0];
      var attrNormalizer;
      var i;
      var ret;
      if (typeof name === 'object') {
        pass = val;
        for (var k in name) {
          Dom.attr(els, k, name[k], pass);
        }
        return undefined;
      }
      if (pass && attrFn[name]) {
        return Dom[name](selector, val);
      }
      name = name.toLowerCase();
      if (pass && attrFn[name]) {
        return Dom[name](selector, val);
      }
      name = attrFix[name] || name;
      if (R_BOOLEAN.test(name)) {
        attrNormalizer = boolHook;
      } else if (R_INVALID_CHAR.test(name)) {
        attrNormalizer = attrNodeHook;
      } else {
        attrNormalizer = attrHooks[name];
      }
      if (val === undefined) {
        if (el && el.nodeType === NodeType.ELEMENT_NODE) {
          if (nodeName(el) === 'form') {
            attrNormalizer = attrNodeHook;
          }
          if (attrNormalizer && attrNormalizer.get) {
            return attrNormalizer.get(el, name);
          }
          ret = el.getAttribute(name);
          if (ret === '') {
            var attrNode = el.getAttributeNode(name);
            if (!attrNode || !attrNode.specified) {
              return undefined;
            }
          }
          return ret === null ? undefined : ret;
        }
      } else {
        for (i = els.length - 1; i >= 0; i--) {
          el = els[i];
          if (el && el.nodeType === NodeType.ELEMENT_NODE) {
            if (nodeName(el) === 'form') {
              attrNormalizer = attrNodeHook;
            }
            if (attrNormalizer && attrNormalizer.set) {
              attrNormalizer.set(el, val, name);
            } else {
              el.setAttribute(name, EMPTY + val);
            }
          }
        }
      }
      return undefined;
    },
    removeAttr: function (selector, name) {
      name = name.toLowerCase();
      name = attrFix[name] || name;
      var els = Dom.query(selector);
      var propName;
      var el;
      var i;
      for (i = els.length - 1; i >= 0; i--) {
        el = els[i];
        if (el.nodeType === NodeType.ELEMENT_NODE) {
          el.removeAttribute(name);
          if (R_BOOLEAN.test(name) && (propName = propFix[name] || name) in el) {
            el[propName] = false;
          }
        }
      }
    },
    val: function (selector, value) {
      var hook;
      var ret;
      var elem;
      var els;
      var i;
      var val;
      if (value === undefined) {
        elem = Dom.get(selector);
        if (elem) {
          hook = valHooks[nodeName(elem)] || valHooks[elem.type];
          if (hook && 'get' in hook && (ret = hook.get(elem, 'value')) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === 'string' ? ret.replace(R_RETURN, '') : ret == null ? '' : ret;
        }
        return undefined;
      }
      els = Dom.query(selector);
      for (i = els.length - 1; i >= 0; i--) {
        elem = els[i];
        if (elem.nodeType !== 1) {
          return undefined;
        }
        val = value;
        if (val == null) {
          val = '';
        } else if (typeof val === 'number') {
          val += '';
        } else if (util.isArray(val)) {
          val = util.map(val, toStr);
        }
        hook = valHooks[nodeName(elem)] || valHooks[elem.type];
        var hookHasSet = hook && 'set' in hook;
        if (!hookHasSet || hook.set(elem, val, 'value') === undefined) {
          elem.value = val;
        }
      }
      return undefined;
    },
    text: function (selector, val) {
      var el;
      var els;
      var i;
      var nodeType;
      if (val === undefined) {
        el = Dom.get(selector);
        return Dom._getText(el);
      } else {
        els = Dom.query(selector);
        for (i = els.length - 1; i >= 0; i--) {
          el = els[i];
          nodeType = el.nodeType;
          if (nodeType === NodeType.ELEMENT_NODE) {
            Dom.cleanData(el.getElementsByTagName('*'));
            if ('textContent' in el) {
              el.textContent = val;
            } else {
              el.innerText = val;
            }
          } else if (nodeType === NodeType.TEXT_NODE || nodeType === NodeType.CDATA_SECTION_NODE) {
            el.nodeValue = val;
          }
        }
      }
      return undefined;
    },
    _getText: function (el) {
      return el.textContent;
    },
    _getProp: getProp
  });
  return exports;
}();
domBaseLibMainClass = function (exports) {
  var util = utilBase;
  var Dom = domBaseLibMainApi;
  var slice = [].slice;
  var NodeType = Dom.NodeType;
  var RE_SPLIT = /[\.\s]\s*\.?/;
  function strToArray(str) {
    str = util.trim(str || '');
    var arr = str.split(RE_SPLIT);
    var newArr = [];
    var v;
    var l = arr.length;
    var i = 0;
    for (; i < l; i++) {
      if (v = arr[i]) {
        newArr.push(v);
      }
    }
    return newArr;
  }
  function batchClassList(method) {
    return function (elem, classNames) {
      var i;
      var l;
      var className;
      var classList = elem.classList;
      var extraArgs = slice.call(arguments, 2);
      for (i = 0, l = classNames.length; i < l; i++) {
        if (className = classNames[i]) {
          classList[method].apply(classList, [className].concat(extraArgs));
        }
      }
    };
  }
  function batchEls(method) {
    return function (selector, className) {
      var classNames = strToArray(className);
      var extraArgs = slice.call(arguments, 2);
      Dom.query(selector).each(function (elem) {
        if (elem.nodeType === NodeType.ELEMENT_NODE) {
          Dom[method].apply(Dom, [
            elem,
            classNames
          ].concat(extraArgs));
        }
      });
    };
  }
  util.mix(Dom, {
    _hasClass: function (elem, classNames) {
      var i;
      var l;
      var className;
      var classList = elem.classList;
      if (classList.length) {
        for (i = 0, l = classNames.length; i < l; i++) {
          className = classNames[i];
          if (className && !classList.contains(className)) {
            return false;
          }
        }
        return true;
      }
      return false;
    },
    _addClass: batchClassList('add'),
    _removeClass: batchClassList('remove'),
    _toggleClass: batchClassList('toggle'),
    hasClass: function (selector, className) {
      var ret = false;
      className = strToArray(className);
      Dom.query(selector).each(function (elem) {
        if (elem.nodeType === NodeType.ELEMENT_NODE && Dom._hasClass(elem, className)) {
          ret = true;
          return false;
        }
        return undefined;
      });
      return ret;
    },
    replaceClass: function (selector, oldClassName, newClassName) {
      Dom.removeClass(selector, oldClassName);
      Dom.addClass(selector, newClassName);
    },
    addClass: batchEls('_addClass'),
    removeClass: batchEls('_removeClass'),
    toggleClass: batchEls('_toggleClass')
  });
  return exports;
}();
domBaseLibMainCreate = function (exports) {
  var util = utilBase;
  var Dom = domBaseLibMainApi;
  var undef;
  var doc = document;
  var NodeType = Dom.NodeType;
  var DIV = 'div';
  var PARENT_NODE = 'parentNode';
  var DEFAULT_DIV = doc && doc.createElement(DIV);
  var R_XHTML_TAG = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi;
  var RE_TAG = /<([\w:]+)/;
  var R_LEADING_WHITESPACE = /^\s+/;
  var R_TAIL_WHITESPACE = /\s+$/;
  var oldIE = function (ua) {
    var m;
    var v;
    if ((m = ua.match(/MSIE ([^;]*)|Trident.*; rv(?:\s|:)?([0-9.]+)/)) && (v = m[1] || m[2])) {
      return parseFloat(v) < 9;
    }
    return false;
  }(navigator.userAgent);
  var lostLeadingTailWhitespace = oldIE;
  var R_HTML = /<|&#?\w+;/;
  var RE_SIMPLE_TAG = /^<(\w+)\s*\/?>(?:<\/\1>)?$/;
  var creators = Dom._creators = { div: defaultCreator };
  var creatorsMap = {
    area: 'map',
    thead: 'table',
    td: 'tr',
    th: 'tr',
    tr: 'tbody',
    tbody: 'table',
    tfoot: 'table',
    caption: 'table',
    colgroup: 'table',
    col: 'colgroup',
    legend: 'fieldset'
  };
  var p;
  var tagTpl = '<{tag}>{html}</{tag}>';
  for (p in creatorsMap) {
    (function (tag) {
      creators[p] = function (html, ownerDoc) {
        return Dom.create(util.substitute(tagTpl, {
          tag: tag,
          html: html
        }), undef, ownerDoc);
      };
    }(creatorsMap[p]));
  }
  creators.option = creators.optgroup = function (html, ownerDoc) {
    return Dom.create('<select multiple="multiple">' + html + '</select>', undefined, ownerDoc);
  };
  creatorsMap.option = creatorsMap.optgroup = 1;
  function getElementsByTagName(el, tag) {
    return el.getElementsByTagName(tag);
  }
  function getHolderDiv(ownerDoc, clear) {
    var holder = ownerDoc && ownerDoc !== doc ? ownerDoc.createElement(DIV) : DEFAULT_DIV;
    if (clear && holder === DEFAULT_DIV) {
      holder.innerHTML = '';
    }
    return holder;
  }
  function defaultCreator(html, ownerDoc) {
    var frag = getHolderDiv(ownerDoc);
    frag.innerHTML = 'm<div>' + html + '<' + '/div>';
    return frag.lastChild;
  }
  function _empty(node) {
    try {
      node.innerHTML = '';
      return;
    } catch (e) {
    }
    while (node.lastChild) {
      _destroy(node.lastChild, node);
    }
  }
  function _destroy(node, parent) {
    if (parent) {
      if (oldIE && parent.canHaveChildren && 'removeNode' in node) {
        if (node.firstChild) {
          _empty(node);
        }
        node.removeNode(false);
      } else {
        parent.removeChild(node);
      }
    }
  }
  util.mix(Dom, {
    create: function (html, attrs, ownerDoc, _trim) {
      var ret = null;
      if (!html) {
        return ret;
      }
      if (html.nodeType) {
        return Dom.clone(html);
      }
      if (typeof html !== 'string') {
        return ret;
      }
      if (_trim === undefined) {
        _trim = true;
      }
      if (_trim) {
        html = util.trim(html);
      }
      var holder;
      var whitespaceMatch;
      var context = ownerDoc || doc;
      var m;
      var tag = DIV;
      var k;
      var nodes;
      if (!R_HTML.test(html)) {
        ret = context.createTextNode(html);
      } else if (m = RE_SIMPLE_TAG.exec(html)) {
        ret = context.createElement(m[1]);
      } else {
        html = html.replace(R_XHTML_TAG, '<$1><' + '/$2>');
        if ((m = RE_TAG.exec(html)) && (k = m[1])) {
          tag = k.toLowerCase();
        }
        holder = (creators[tag] || defaultCreator)(html, context);
        if (lostLeadingTailWhitespace && (whitespaceMatch = html.match(R_LEADING_WHITESPACE))) {
          holder.insertBefore(context.createTextNode(whitespaceMatch[0]), holder.firstChild);
        }
        if (lostLeadingTailWhitespace && /\S/.test(html) && (whitespaceMatch = html.match(R_TAIL_WHITESPACE))) {
          holder.appendChild(context.createTextNode(whitespaceMatch[0]));
        }
        nodes = holder.childNodes;
        if (nodes.length === 1) {
          ret = nodes[0][PARENT_NODE].removeChild(nodes[0]);
        } else if (nodes.length) {
          ret = nodeListToFragment(nodes);
        } else {
          throw new Error(html + ' : create node error');
        }
      }
      return attrs ? setAttributes(ret, attrs) : ret;
    },
    _fixCloneAttributes: function (src, dest) {
      var nodeName = src.nodeName.toLowerCase();
      var type = (src.type || '').toLowerCase();
      var srcValue;
      var srcChecked;
      if (nodeName === 'textarea') {
        dest.defaultValue = src.defaultValue;
        dest.value = src.value;
      } else if (nodeName === 'input' && (type === 'checkbox' || type === 'radio')) {
        srcChecked = src.checked;
        if (srcChecked) {
          dest.defaultChecked = dest.checked = srcChecked;
        }
        srcValue = src.value;
        if (dest.value !== srcValue) {
          dest.value = srcValue;
        }
      }
    },
    _defaultCreator: defaultCreator,
    html: function (selector, htmlString, loadScripts) {
      var els = Dom.query(selector);
      var el = els[0];
      var success = false;
      var valNode;
      var i;
      var elem;
      if (!el) {
        return undefined;
      }
      if (htmlString === undefined) {
        if (el.nodeType === NodeType.ELEMENT_NODE) {
          return el.innerHTML;
        } else if (el.nodeType === NodeType.DOCUMENT_FRAGMENT_NODE) {
          var holder = getHolderDiv(el.ownerDocument, 1);
          holder.appendChild(el);
          return holder.innerHTML;
        } else {
          return null;
        }
      } else {
        htmlString += '';
        if (!htmlString.match(/<(?:script|style|link)/i) && (!lostLeadingTailWhitespace || !htmlString.match(R_LEADING_WHITESPACE)) && !creatorsMap[(htmlString.match(RE_TAG) || [
            '',
            ''
          ])[1].toLowerCase()]) {
          try {
            for (i = els.length - 1; i >= 0; i--) {
              elem = els[i];
              if (elem.nodeType === NodeType.ELEMENT_NODE) {
                Dom.cleanData(getElementsByTagName(elem, '*'));
                elem.innerHTML = htmlString;
              }
            }
            success = true;
          } catch (e) {
          }
        }
        if (!success) {
          valNode = Dom.create(htmlString, 0, el.ownerDocument, 0);
          Dom.empty(els);
          Dom.append(valNode, els, loadScripts);
        }
      }
      return undefined;
    },
    remove: function (selector, keepData, DOMEvent) {
      var el;
      var els = Dom.query(selector);
      var all;
      var i;
      for (i = els.length - 1; i >= 0; i--) {
        el = els[i];
        if (!keepData && el.nodeType === NodeType.ELEMENT_NODE) {
          all = util.makeArray(getElementsByTagName(el, '*'));
          all.push(el);
          Dom.removeData(all);
          if (DOMEvent) {
            DOMEvent.detach(all);
          }
        }
        _destroy(el, el.parentNode);
      }
    },
    clone: function (selector, deep, withDataAndEvent, deepWithDataAndEvent, DOMEvent) {
      if (typeof deep === 'object') {
        deepWithDataAndEvent = deep.deepWithDataAndEvent;
        withDataAndEvent = deep.withDataAndEvent;
        deep = deep.deep;
      }
      var elem = Dom.get(selector);
      var clone;
      var _fixCloneAttributes = Dom._fixCloneAttributes;
      var elemNodeType;
      if (!elem) {
        return null;
      }
      elemNodeType = elem.nodeType;
      clone = elem.cloneNode(deep);
      if (elemNodeType === NodeType.ELEMENT_NODE || elemNodeType === NodeType.DOCUMENT_FRAGMENT_NODE) {
        if (_fixCloneAttributes && elemNodeType === NodeType.ELEMENT_NODE) {
          _fixCloneAttributes(elem, clone);
        }
        if (deep && _fixCloneAttributes) {
          processAll(_fixCloneAttributes, elem, clone);
        }
      }
      if (withDataAndEvent) {
        cloneWithDataAndEvent(elem, clone, DOMEvent);
        if (deep && deepWithDataAndEvent) {
          processAll(cloneWithDataAndEvent, elem, clone);
        }
      }
      return clone;
    },
    empty: function (selector, DOMEvent) {
      var els = Dom.query(selector);
      var el;
      var i;
      for (i = els.length - 1; i >= 0; i--) {
        el = els[i];
        Dom.remove(el.childNodes, false, DOMEvent);
      }
    },
    _nodeListToFragment: nodeListToFragment,
    _getHolderDiv: getHolderDiv
  });
  function processAll(fn, elem, clone) {
    var elemNodeType = elem.nodeType;
    if (elemNodeType === NodeType.DOCUMENT_FRAGMENT_NODE) {
      var eCs = elem.childNodes;
      var cloneCs = clone.childNodes;
      var fIndex = 0;
      while (eCs[fIndex]) {
        if (cloneCs[fIndex]) {
          processAll(fn, eCs[fIndex], cloneCs[fIndex]);
        }
        fIndex++;
      }
    } else if (elemNodeType === NodeType.ELEMENT_NODE) {
      var elemChildren = getElementsByTagName(elem, '*');
      var cloneChildren = getElementsByTagName(clone, '*');
      var cIndex = 0;
      while (elemChildren[cIndex]) {
        if (cloneChildren[cIndex]) {
          fn(elemChildren[cIndex], cloneChildren[cIndex]);
        }
        cIndex++;
      }
    }
  }
  function cloneWithDataAndEvent(src, dest, DOMEvent) {
    var srcData;
    var d;
    if (dest.nodeType === NodeType.ELEMENT_NODE) {
      return;
    }
    srcData = Dom.data(src);
    for (d in srcData) {
      Dom.data(dest, d, srcData[d]);
    }
    if (DOMEvent) {
      DOMEvent.clone(src, dest);
    }
  }
  function setAttributes(elem, attrs) {
    var nodeType = elem.nodeType;
    if (nodeType === NodeType.ELEMENT_NODE) {
      Dom.attr(elem, attrs, true);
    } else if (nodeType === NodeType.DOCUMENT_FRAGMENT_NODE) {
      Dom.attr(elem.childNodes, attrs, true);
    }
    return elem;
  }
  function nodeListToFragment(nodes) {
    var ret = null;
    var i;
    var ownerDoc;
    var len;
    if (nodes && (nodes.push || nodes.item) && nodes[0]) {
      ownerDoc = nodes[0].ownerDocument;
      ret = ownerDoc.createDocumentFragment();
      nodes = util.makeArray(nodes);
      for (i = 0, len = nodes.length; i < len; i++) {
        ret.appendChild(nodes[i]);
      }
    } else {
      throw new Error('Unable to convert ' + nodes + ' to fragment.');
    }
    return ret;
  }
  return exports;
}();
domBaseLibMainData = function (exports) {
  var util = utilBase;
  var Dom = domBaseLibMainApi;
  var win = window;
  var EXPANDO = '_ks_data_' + util.now();
  var dataCache = {};
  var winDataCache = {};
  var noData = {
    applet: 1,
    object: 1,
    embed: 1
  };
  var objectOps = {
    data: function (ob, name, value) {
      if (ob == win) {
        return objectOps.data(winDataCache, name, value);
      }
      var cache = ob[EXPANDO];
      if (value !== undefined) {
        cache = ob[EXPANDO] = ob[EXPANDO] || {};
        cache[name] = value;
      } else {
        if (name !== undefined) {
          return cache && cache[name];
        } else {
          cache = ob[EXPANDO] = ob[EXPANDO] || {};
          return cache;
        }
      }
    },
    removeData: function (ob, name) {
      if (ob == win) {
        return objectOps.removeData(winDataCache, name);
      }
      var cache = ob[EXPANDO];
      if (name !== undefined) {
        delete cache[name];
        if (util.isEmptyObject(cache)) {
          objectOps.removeData(ob);
        }
      } else {
        try {
          delete ob[EXPANDO];
        } catch (e) {
          ob[EXPANDO] = undefined;
        }
      }
    }
  };
  var domOps = {
    data: function (elem, name, value) {
      if (noData[elem.nodeName.toLowerCase()]) {
        return undefined;
      }
      var key = elem[EXPANDO];
      var cache;
      if (!key) {
        if (name !== undefined && value === undefined) {
          return undefined;
        }
        key = elem[EXPANDO] = util.guid();
      }
      cache = dataCache[key];
      if (value !== undefined) {
        cache = dataCache[key] = dataCache[key] || {};
        cache[name] = value;
      } else {
        if (name !== undefined) {
          return cache && cache[name];
        } else {
          cache = dataCache[key] = dataCache[key] || {};
          return cache;
        }
      }
    },
    removeData: function (elem, name) {
      var key = elem[EXPANDO];
      if (!key) {
        return;
      }
      var cache = dataCache[key];
      if (name !== undefined) {
        delete cache[name];
        if (util.isEmptyObject(cache)) {
          domOps.removeData(elem);
        }
      } else {
        delete dataCache[key];
        try {
          delete elem[EXPANDO];
        } catch (e) {
          elem[EXPANDO] = undefined;
        }
        if (elem.removeAttribute) {
          elem.removeAttribute(EXPANDO);
        }
      }
    }
  };
  util.mix(Dom, {
    __EXPANDO: EXPANDO,
    _dataCache: dataCache,
    _winDataCache: winDataCache,
    data: function (selector, name, data) {
      var elems = Dom.query(selector);
      var elem = elems[0];
      if (typeof name === 'object') {
        for (var k in name) {
          Dom.data(elems, k, name[k]);
        }
        return undefined;
      }
      if (data === undefined) {
        if (elem) {
          if (elem.nodeType) {
            return domOps.data(elem, name);
          } else {
            return objectOps.data(elem, name);
          }
        }
      } else {
        for (var i = elems.length - 1; i >= 0; i--) {
          elem = elems[i];
          if (elem.nodeType) {
            domOps.data(elem, name, data);
          } else {
            objectOps.data(elem, name, data);
          }
        }
      }
      return undefined;
    },
    removeData: function (selector, name) {
      var els = Dom.query(selector);
      var elem;
      var i;
      for (i = els.length - 1; i >= 0; i--) {
        elem = els[i];
        if (elem.nodeType) {
          domOps.removeData(elem, name);
        } else {
          objectOps.removeData(elem, name);
        }
      }
    },
    cleanData: function (selector, deep, DOMEvent) {
      var els = Dom.query(selector);
      var elem;
      var i;
      for (i = els.length - 1; i >= 0; i--) {
        elem = els[i];
        if (elem.nodeType) {
          var descendants = deep && util.makeArray(elem.getElementsByTagName('*')) || [];
          descendants.push(elem);
          for (var j = 0, len = descendants.length; j < len; j++) {
            domOps.removeData(descendants[j]);
          }
          if (DOMEvent) {
            DOMEvent.detach(descendants);
          }
        } else {
          objectOps.removeData(elem);
        }
      }
    }
  });
  return exports;
}();
domBaseLibMainInsertion = function (exports) {
  var util = utilBase;
  var getScript = ioScript;
  var Dom = domBaseLibMainApi;
  var PARENT_NODE = 'parentNode';
  var NodeType = Dom.NodeType;
  var RE_FORM_EL = /^(?:button|input|object|select|textarea)$/i;
  var getNodeName = Dom.nodeName;
  var makeArray = util.makeArray;
  var splice = [].splice;
  var NEXT_SIBLING = 'nextSibling';
  var R_SCRIPT_TYPE = /\/(java|ecma)script/i;
  function isJs(el) {
    return !el.type || R_SCRIPT_TYPE.test(el.type);
  }
  function filterScripts(nodes, scripts) {
    var ret = [];
    var i;
    var el;
    var nodeName;
    for (i = 0; nodes[i]; i++) {
      el = nodes[i];
      nodeName = getNodeName(el);
      if (el.nodeType === NodeType.DOCUMENT_FRAGMENT_NODE) {
        ret.push.apply(ret, filterScripts(makeArray(el.childNodes), scripts));
      } else if (nodeName === 'script' && isJs(el)) {
        if (el.parentNode) {
          el.parentNode.removeChild(el);
        }
        if (scripts) {
          scripts.push(el);
        }
      } else {
        if (el.nodeType === NodeType.ELEMENT_NODE && !RE_FORM_EL.test(nodeName)) {
          var tmp = [];
          var s;
          var j;
          var ss = el.getElementsByTagName('script');
          for (j = 0; j < ss.length; j++) {
            s = ss[j];
            if (isJs(s)) {
              tmp.push(s);
            }
          }
          splice.apply(nodes, [
            i + 1,
            0
          ].concat(tmp));
        }
        ret.push(el);
      }
    }
    return ret;
  }
  function evalScript(el) {
    if (el.src) {
      getScript(el.src);
    } else {
      var code = util.trim(el.text || el.textContent || el.innerHTML || '');
      if (code) {
        util.globalEval(code);
      }
    }
  }
  function insertion(newNodes, refNodes, fn, scripts) {
    newNodes = Dom.query(newNodes);
    if (scripts) {
      scripts = [];
    }
    newNodes = filterScripts(newNodes, scripts);
    if (Dom._fixInsertionChecked) {
      Dom._fixInsertionChecked(newNodes);
    }
    refNodes = Dom.query(refNodes);
    var newNodesLength = newNodes.length;
    var newNode;
    var i;
    var refNode;
    var node;
    var clonedNode;
    var refNodesLength = refNodes.length;
    if (!newNodesLength && (!scripts || !scripts.length) || !refNodesLength) {
      return;
    }
    newNode = Dom._nodeListToFragment(newNodes);
    if (refNodesLength > 1) {
      clonedNode = Dom.clone(newNode, true);
      refNodes = util.makeArray(refNodes);
    }
    for (i = 0; i < refNodesLength; i++) {
      refNode = refNodes[i];
      if (newNode) {
        node = i > 0 ? Dom.clone(clonedNode, true) : newNode;
        fn(node, refNode);
      }
      if (scripts && scripts.length) {
        util.each(scripts, evalScript);
      }
    }
  }
  util.mix(Dom, {
    _fixInsertionChecked: null,
    insertBefore: function (newNodes, refNodes, loadScripts) {
      insertion(newNodes, refNodes, function (newNode, refNode) {
        if (refNode[PARENT_NODE]) {
          refNode[PARENT_NODE].insertBefore(newNode, refNode);
        }
      }, loadScripts);
    },
    insertAfter: function (newNodes, refNodes, loadScripts) {
      insertion(newNodes, refNodes, function (newNode, refNode) {
        if (refNode[PARENT_NODE]) {
          refNode[PARENT_NODE].insertBefore(newNode, refNode[NEXT_SIBLING]);
        }
      }, loadScripts);
    },
    appendTo: function (newNodes, parents, loadScripts) {
      insertion(newNodes, parents, function (newNode, parent) {
        parent.appendChild(newNode);
      }, loadScripts);
    },
    prependTo: function (newNodes, parents, loadScripts) {
      insertion(newNodes, parents, function (newNode, parent) {
        parent.insertBefore(newNode, parent.firstChild);
      }, loadScripts);
    },
    replaceWith: function (selector, newNodes) {
      var nodes = Dom.query(selector);
      newNodes = Dom.query(newNodes);
      Dom.remove(newNodes, true);
      Dom.insertBefore(newNodes, nodes);
      Dom.remove(nodes);
    }
  });
  util.each({
    prepend: 'prependTo',
    append: 'appendTo',
    before: 'insertBefore',
    after: 'insertAfter'
  }, function (value, key) {
    Dom[key] = Dom[value];
  });
  return exports;
}();
domBaseLibMainOffset = function (exports) {
  var util = utilBase;
  var Dom = domBaseLibMainApi;
  var win = window;
  var doc = win.document;
  var NodeType = Dom.NodeType;
  var docElem = doc && doc.documentElement;
  var getWindow = Dom.getWindow;
  var CSS1Compat = 'CSS1Compat';
  var compatMode = 'compatMode';
  var max = Math.max;
  var POSITION = 'position';
  var RELATIVE = 'relative';
  var DOCUMENT = 'document';
  var BODY = 'body';
  var DOC_ELEMENT = 'documentElement';
  var VIEWPORT = 'viewport';
  var SCROLL = 'scroll';
  var CLIENT = 'client';
  var LEFT = 'left';
  var TOP = 'top';
  var SCROLL_LEFT = SCROLL + 'Left';
  var SCROLL_TOP = SCROLL + 'Top';
  var mobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  util.mix(Dom, {
    offset: function (selector, coordinates, relativeWin) {
      var elem;
      if (coordinates === undefined) {
        elem = Dom.get(selector);
        var ret;
        if (elem) {
          ret = getOffset(elem, relativeWin);
        }
        return ret;
      }
      var els = Dom.query(selector);
      var i;
      for (i = els.length - 1; i >= 0; i--) {
        elem = els[i];
        setOffset(elem, coordinates);
      }
      return undefined;
    },
    docWidth: 0,
    docHeight: 0,
    viewportHeight: 0,
    viewportWidth: 0,
    scrollTop: 0,
    scrollLeft: 0
  });
  util.each([
    'Left',
    'Top'
  ], function (name, i) {
    var method = SCROLL + name;
    Dom[method] = function (elem, v) {
      if (typeof elem === 'number') {
        return arguments.callee(win, elem);
      }
      elem = Dom.get(elem);
      var ret;
      var left;
      var top;
      var w;
      var d;
      if (elem && elem.nodeType === NodeType.ELEMENT_NODE) {
        if (v !== undefined) {
          elem[method] = parseFloat(v);
        } else {
          ret = elem[method];
        }
      } else {
        w = getWindow(elem);
        if (v !== undefined) {
          v = parseFloat(v);
          left = name === 'Left' ? v : Dom.scrollLeft(w);
          top = name === 'Top' ? v : Dom.scrollTop(w);
          w.scrollTo(left, top);
        } else {
          ret = w['page' + (i ? 'Y' : 'X') + 'Offset'];
          if (typeof ret !== 'number') {
            d = w[DOCUMENT];
            ret = d[DOC_ELEMENT][method];
            if (typeof ret !== 'number') {
              ret = d[BODY][method];
            }
          }
        }
      }
      return ret;
    };
  });
  util.each([
    'Width',
    'Height'
  ], function (name) {
    Dom['doc' + name] = function (refWin) {
      refWin = Dom.get(refWin);
      var d = Dom.getDocument(refWin);
      return max(d[DOC_ELEMENT][SCROLL + name], d[BODY][SCROLL + name], Dom[VIEWPORT + name](d));
    };
    Dom[VIEWPORT + name] = function (refWin) {
      refWin = Dom.get(refWin);
      var refWindow = getWindow(refWin);
      var ret = refWindow['inner' + name];
      if (mobile && ret) {
        return ret;
      }
      var prop = CLIENT + name;
      var refDoc = refWindow[DOCUMENT];
      var body = refDoc[BODY];
      var documentElement = refDoc[DOC_ELEMENT];
      var documentElementProp = documentElement[prop];
      return refDoc[compatMode] === CSS1Compat && documentElementProp || body && body[prop] || documentElementProp;
    };
  });
  function getClientPosition(elem) {
    var box;
    var x;
    var y;
    var ownerDoc = elem.ownerDocument;
    var body = ownerDoc.body;
    if (!elem.getBoundingClientRect) {
      return {
        left: 0,
        top: 0
      };
    }
    box = elem.getBoundingClientRect();
    x = box[LEFT];
    y = box[TOP];
    x -= docElem.clientLeft || body.clientLeft || 0;
    y -= docElem.clientTop || body.clientTop || 0;
    return {
      left: x,
      top: y
    };
  }
  function getPageOffset(el) {
    var pos = getClientPosition(el);
    var w = getWindow(el);
    pos.left += Dom[SCROLL_LEFT](w);
    pos.top += Dom[SCROLL_TOP](w);
    return pos;
  }
  function getOffset(el, relativeWin) {
    var position = {
      left: 0,
      top: 0
    };
    var currentWin = getWindow(el);
    var offset;
    var currentEl = el;
    relativeWin = relativeWin || currentWin;
    do {
      offset = currentWin == relativeWin ? getPageOffset(currentEl) : getClientPosition(currentEl);
      position.left += offset.left;
      position.top += offset.top;
    } while (currentWin && currentWin != relativeWin && (currentEl = currentWin.frameElement) && (currentWin = currentWin.parent));
    return position;
  }
  function setOffset(elem, offset) {
    if (Dom.css(elem, POSITION) === 'static') {
      elem.style[POSITION] = RELATIVE;
    }
    var old = getOffset(elem);
    var ret = {};
    var current;
    var key;
    for (key in offset) {
      current = parseFloat(Dom.css(elem, key)) || 0;
      ret[key] = current + offset[key] - old[key];
    }
    Dom.css(elem, ret);
  }
  return exports;
}();
domBaseLibMainStyle = function (exports) {
  var util = utilBase;
  var Feature = feature;
  var Dom = domBaseLibMainApi;
  var globalWindow = window;
  var getCssVendorInfo = Feature.getCssVendorInfo;
  var BOX_MODELS = [
    'margin',
    'border',
    'padding'
  ];
  var CONTENT_INDEX = -1;
  var PADDING_INDEX = 2;
  var BORDER_INDEX = 1;
  var MARGIN_INDEX = 0;
  var doc = globalWindow.document || {};
  var RE_MARGIN = /^margin/;
  var WIDTH = 'width';
  var HEIGHT = 'height';
  var DISPLAY = 'display';
  var OLD_DISPLAY = DISPLAY + util.now();
  var NONE = 'none';
  var cssNumber = {
    fillOpacity: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    orphans: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1
  };
  var EMPTY = '';
  var DEFAULT_UNIT = 'px';
  var NO_PX_REG = /\d(?!px)[a-z%]+$/i;
  var cssHooks = {};
  var cssProps = { 'float': 'cssFloat' };
  var defaultDisplay = {};
  var camelCase = util.camelCase;
  function normalizeCssPropName(name) {
    if (cssProps[name]) {
      return cssProps[name];
    }
    var vendor = getCssVendorInfo(name);
    return vendor && vendor.propertyName || name;
  }
  function getDefaultDisplay(tagName) {
    var body;
    var oldDisplay = defaultDisplay[tagName];
    var elem;
    if (!defaultDisplay[tagName]) {
      body = doc.body || doc.documentElement;
      elem = doc.createElement(tagName);
      Dom.prepend(elem, body);
      oldDisplay = Dom.css(elem, 'display');
      body.removeChild(elem);
      defaultDisplay[tagName] = oldDisplay;
    }
    return oldDisplay;
  }
  util.mix(Dom, {
    _cssHooks: cssHooks,
    _cssProps: cssProps,
    _getComputedStyle: function (elem, name, computedStyle) {
      var val = '';
      var width;
      var minWidth;
      var maxWidth;
      var elStyle;
      var d = elem.ownerDocument;
      name = normalizeCssPropName(name);
      if (computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null)) {
        val = computedStyle.getPropertyValue(name) || computedStyle[name];
      }
      if (val === '' && !Dom.contains(d, elem)) {
        val = elem.style[name];
      }
      if (Dom._RE_NUM_NO_PX.test(val) && RE_MARGIN.test(name)) {
        elStyle = elem.style;
        width = elStyle.width;
        minWidth = elStyle.minWidth;
        maxWidth = elStyle.maxWidth;
        elStyle.minWidth = elStyle.maxWidth = elStyle.width = val;
        val = computedStyle.width;
        elStyle.width = width;
        elStyle.minWidth = minWidth;
        elStyle.maxWidth = maxWidth;
      }
      return val;
    },
    _style: style,
    css: function (selector, name, val) {
      var els = Dom.query(selector);
      var elem = els[0];
      var k;
      var hook;
      var ret;
      var i;
      if (typeof name === 'object') {
        for (k in name) {
          for (i = els.length - 1; i >= 0; i--) {
            style(els[i], k, name[k]);
          }
        }
        return undefined;
      }
      name = camelCase(name);
      hook = cssHooks[name];
      if (val === undefined) {
        ret = '';
        if (elem) {
          if (!(hook && 'get' in hook && (ret = hook.get(elem, true)) !== undefined)) {
            ret = Dom._getComputedStyle(elem, name);
          }
        }
        return typeof ret === 'undefined' ? '' : ret;
      } else {
        for (i = els.length - 1; i >= 0; i--) {
          style(els[i], name, val, 1);
        }
      }
      return undefined;
    },
    show: function (selector) {
      var els = Dom.query(selector);
      var tagName;
      var old;
      var elem;
      var i;
      for (i = els.length - 1; i >= 0; i--) {
        elem = els[i];
        elem.style[DISPLAY] = Dom.data(elem, OLD_DISPLAY) || EMPTY;
        if (Dom.css(elem, DISPLAY) === NONE) {
          tagName = elem.tagName.toLowerCase();
          old = getDefaultDisplay(tagName);
          Dom.data(elem, OLD_DISPLAY, old);
          elem.style[DISPLAY] = old;
        }
      }
    },
    hide: function (selector) {
      var els = Dom.query(selector);
      var elem;
      var i;
      for (i = els.length - 1; i >= 0; i--) {
        elem = els[i];
        var elStyle = elem.style;
        var old = elStyle[DISPLAY];
        if (old !== NONE) {
          if (old) {
            Dom.data(elem, OLD_DISPLAY, old);
          }
          elStyle[DISPLAY] = NONE;
        }
      }
    },
    toggle: function (selector) {
      var els = Dom.query(selector);
      var elem;
      var i;
      for (i = els.length - 1; i >= 0; i--) {
        elem = els[i];
        if (Dom.css(elem, DISPLAY) === NONE) {
          Dom.show(elem);
        } else {
          Dom.hide(elem);
        }
      }
    },
    addStyleSheet: function (refWin, cssText, id) {
      if (typeof refWin === 'string') {
        id = cssText;
        cssText = refWin;
        refWin = globalWindow;
      }
      var refDoc = Dom.getDocument(refWin);
      var elem;
      if (id && (id = id.replace('#', EMPTY))) {
        elem = Dom.get('#' + id, refDoc);
      }
      if (elem) {
        return;
      }
      elem = Dom.create('<style>', { id: id }, refDoc);
      Dom.get('head', refDoc).appendChild(elem);
      if (elem.styleSheet) {
        elem.styleSheet.cssText = cssText;
      } else {
        elem.appendChild(refDoc.createTextNode(cssText));
      }
    },
    innerWidth: 0,
    innerHeight: 0,
    outerWidth: 0,
    outerHeight: 0,
    width: 0,
    height: 0
  });
  util.each([
    WIDTH,
    HEIGHT
  ], function (name) {
    Dom['inner' + util.ucfirst(name)] = function (selector) {
      var el = Dom.get(selector);
      return el && getWHIgnoreDisplay(el, name, PADDING_INDEX);
    };
    Dom['outer' + util.ucfirst(name)] = function (selector, includeMargin) {
      var el = Dom.get(selector);
      return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
    };
    var which = name === WIDTH ? [
      'Left',
      'Right'
    ] : [
      'Top',
      'Bottom'
    ];
    Dom[name] = function (selector, val) {
      var elem = Dom.get(selector);
      if (val !== undefined) {
        if (elem) {
          var computedStyle = getComputedStyle(elem);
          var isBorderBox = isBorderBoxFn(elem, computedStyle);
          if (isBorderBox) {
            val += getPBMWidth(elem, [
              'padding',
              'border'
            ], which, computedStyle);
          }
          return Dom.css(selector, name, val);
        }
        return undefined;
      }
      return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
    };
    cssHooks[name] = {
      get: function (elem, computed) {
        var val;
        if (computed) {
          val = getWHIgnoreDisplay(elem, name) + 'px';
        }
        return val;
      }
    };
  });
  var cssShow = {
    position: 'absolute',
    visibility: 'hidden',
    display: 'block'
  };
  util.each([
    'left',
    'top'
  ], function (name) {
    cssHooks[name] = {
      get: function (el, computed) {
        var val;
        var isAutoPosition;
        var position;
        if (computed) {
          position = Dom.css(el, 'position');
          if (position === 'static') {
            return 'auto';
          }
          val = Dom._getComputedStyle(el, name);
          isAutoPosition = val === 'auto';
          if (isAutoPosition && position === 'relative') {
            return '0px';
          }
          if (isAutoPosition || NO_PX_REG.test(val)) {
            val = getPosition(el)[name] + 'px';
          }
        }
        return val;
      }
    };
  });
  function swap(elem, options, callback) {
    var old = {};
    var elStyle = elem.style;
    var name;
    for (name in options) {
      old[name] = elStyle[name];
      elStyle[name] = options[name];
    }
    callback.call(elem);
    for (name in options) {
      elStyle[name] = old[name];
    }
  }
  function style(elem, name, val, camelCased) {
    var elStyle;
    var ret;
    var hook;
    if (!(elStyle = elem.style)) {
      return undefined;
    }
    name = camelCased ? name : camelCase(name);
    hook = cssHooks[name];
    name = normalizeCssPropName(name);
    if (val !== undefined) {
      if (val === null || val === EMPTY) {
        val = EMPTY;
      } else if (!isNaN(Number(val)) && !cssNumber[name]) {
        val += DEFAULT_UNIT;
      }
      if (hook && hook.set) {
        val = hook.set(elem, val);
      }
      if (val !== undefined) {
        try {
          elStyle[name] = val;
        } catch (e) {
        }
        if (val === EMPTY && elStyle.removeAttribute) {
          elStyle.removeAttribute(name);
        }
      }
      if (!elStyle.cssText) {
        elem.removeAttribute('style');
      }
      return undefined;
    } else {
      if (!(hook && 'get' in hook && (ret = hook.get(elem, false)) !== undefined)) {
        ret = elStyle[name];
      }
      return ret === undefined ? '' : ret;
    }
  }
  function getWHIgnoreDisplay(elem) {
    var val;
    var args = arguments;
    if (elem.offsetWidth !== 0) {
      val = getWH.apply(undefined, args);
    } else {
      swap(elem, cssShow, function () {
        val = getWH.apply(undefined, args);
      });
    }
    return val;
  }
  function getPBMWidth(elem, props, which, computedStyle) {
    var value = 0;
    var prop;
    var j;
    var i;
    for (j = 0; j < props.length; j++) {
      prop = props[j];
      if (prop) {
        for (i = 0; i < which.length; i++) {
          var cssProp;
          if (prop === 'border') {
            cssProp = prop + which[i] + 'Width';
          } else {
            cssProp = prop + which[i];
          }
          value += parseFloat(Dom._getComputedStyle(elem, cssProp, computedStyle)) || 0;
        }
      }
    }
    return value;
  }
  function isBorderBoxFn(elem, computedStyle) {
    return Dom._getComputedStyle(elem, 'boxSizing', computedStyle) === 'border-box';
  }
  function getComputedStyle(elem) {
    var ownerDoc = elem.ownerDocument;
    var computedStyle;
    if (ownerDoc.defaultView) {
      computedStyle = ownerDoc.defaultView.getComputedStyle(elem, null);
    }
    return computedStyle;
  }
  function getWH(elem, name, extra) {
    if (util.isWindow(elem)) {
      return name === WIDTH ? Dom.viewportWidth(elem) : Dom.viewportHeight(elem);
    } else if (elem.nodeType === 9) {
      return name === WIDTH ? Dom.docWidth(elem) : Dom.docHeight(elem);
    }
    var which = name === WIDTH ? [
      'Left',
      'Right'
    ] : [
      'Top',
      'Bottom'
    ];
    var borderBoxValue = name === WIDTH ? elem.offsetWidth : elem.offsetHeight;
    var computedStyle = getComputedStyle(elem);
    var isBorderBox = isBorderBoxFn(elem, computedStyle);
    var cssBoxValue = 0;
    if (borderBoxValue == null || borderBoxValue <= 0) {
      borderBoxValue = undefined;
      cssBoxValue = Dom._getComputedStyle(elem, name, computedStyle);
      if (cssBoxValue == null || Number(cssBoxValue) < 0) {
        cssBoxValue = elem.style[name] || 0;
      }
      cssBoxValue = parseFloat(cssBoxValue) || 0;
    }
    if (extra === undefined) {
      extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
    }
    var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
    var val = borderBoxValue || cssBoxValue;
    if (extra === CONTENT_INDEX) {
      if (borderBoxValueOrIsBorderBox) {
        return val - getPBMWidth(elem, [
          'border',
          'padding'
        ], which, computedStyle);
      } else {
        return cssBoxValue;
      }
    } else if (borderBoxValueOrIsBorderBox) {
      return val + (extra === BORDER_INDEX ? 0 : extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which, computedStyle) : getPBMWidth(elem, ['margin'], which, computedStyle));
    } else {
      return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which, computedStyle);
    }
  }
  var ROOT_REG = /^(?:body|html)$/i;
  function getPosition(el) {
    var offsetParent;
    var offset;
    var parentOffset = {
      top: 0,
      left: 0
    };
    if (Dom.css(el, 'position') === 'fixed') {
      offset = el.getBoundingClientRect();
    } else {
      offsetParent = getOffsetParent(el);
      offset = Dom.offset(el);
      parentOffset = Dom.offset(offsetParent);
      parentOffset.top += parseFloat(Dom.css(offsetParent, 'borderTopWidth')) || 0;
      parentOffset.left += parseFloat(Dom.css(offsetParent, 'borderLeftWidth')) || 0;
    }
    offset.top -= parseFloat(Dom.css(el, 'marginTop')) || 0;
    offset.left -= parseFloat(Dom.css(el, 'marginLeft')) || 0;
    return {
      top: offset.top - parentOffset.top,
      left: offset.left - parentOffset.left
    };
  }
  function getOffsetParent(el) {
    var offsetParent = el.offsetParent || (el.ownerDocument || doc).body;
    while (offsetParent && !ROOT_REG.test(offsetParent.nodeName) && Dom.css(offsetParent, 'position') === 'static') {
      offsetParent = offsetParent.offsetParent;
    }
    return offsetParent;
  }
  return exports;
}();
domBaseLibMainSelector = function (exports) {
  var Dom = domBaseLibMainApi;
  var util = utilBase;
  var querySelectorAll = querySelectorBase;
  var doc = document;
  var docElem = doc.documentElement;
  var matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector;
  var supportGetElementsByClassName = 'getElementsByClassName' in doc;
  var isArray = util.isArray;
  var getElementsByClassName;
  var makeArray = util.makeArray;
  var isDomNodeList = Dom.isDomNodeList;
  var SPACE = ' ';
  var push = Array.prototype.push;
  var rClassSelector = /^\.([\w-]+)$/;
  var rIdSelector = /^#([\w-]+)$/;
  var rTagSelector = /^([\w-])+$/;
  var rTagIdSelector = /^([\w-]+)#([\w-]+)$/;
  var rSimpleSelector = /^(?:#([\w-]+))?\s*([\w-]+|\*)?\.?([\w-]+)?$/;
  var trim = util.trim;
  if (!supportGetElementsByClassName) {
    getElementsByClassName = function (el, match) {
      var result = [];
      var elements = el.getElementsByTagName('*');
      var i;
      var elem;
      match = ' ' + match + ' ';
      for (i = 0; i < elements.length; i++) {
        elem = elements[i];
        if ((' ' + (elem.className || elem.getAttribute('class')) + ' ').indexOf(match) > -1) {
          result.push(elem);
        }
      }
      return result;
    };
  } else {
    getElementsByClassName = function (el, match) {
      return el.getElementsByClassName(match);
    };
  }
  function queryEach(f) {
    var self = this;
    var l = self.length;
    var i;
    for (i = 0; i < l; i++) {
      if (f(self[i], i) === false) {
        break;
      }
    }
  }
  function checkSelectorAndReturn(selector) {
    var name = selector.substr(1);
    if (!name) {
      throw new Error('An invalid or illegal string was specified for selector.');
    }
    return name;
  }
  function makeMatch(selector) {
    var s = selector.charAt(0);
    if (s === '#') {
      return makeIdMatch(checkSelectorAndReturn(selector));
    } else if (s === '.') {
      return makeClassMatch(checkSelectorAndReturn(selector));
    } else {
      return makeTagMatch(selector);
    }
  }
  function makeIdMatch(id) {
    return function (elem) {
      var match = Dom._getElementById(id, doc);
      return match && Dom._contains(elem, match) ? [match] : [];
    };
  }
  function makeClassMatch(className) {
    return function (elem) {
      return getElementsByClassName(elem, className);
    };
  }
  function makeTagMatch(tagName) {
    return function (elem) {
      return elem.getElementsByTagName(tagName);
    };
  }
  function isSimpleSelector(selector) {
    var complexReg = /,|\+|=|~|\[|\]|:|>|\||\$|\^|\*|\(|\)|[\w-]+\.[\w-]+|[\w-]+#[\w-]+/;
    return !selector.match(complexReg);
  }
  function query(selector, context) {
    var ret;
    var i;
    var el;
    var simpleContext;
    var isSelectorString = typeof selector === 'string';
    var contexts = context !== undefined ? query(context) : (simpleContext = 1) && [doc];
    var contextsLen = contexts.length;
    if (!selector) {
      ret = [];
    } else if (isSelectorString) {
      selector = trim(selector);
      if (simpleContext) {
        if (selector === 'body') {
          ret = [doc.body];
        } else if (rClassSelector.test(selector)) {
          ret = makeArray(getElementsByClassName(doc, RegExp.$1));
        } else if (rTagIdSelector.test(selector)) {
          el = Dom._getElementById(RegExp.$2, doc);
          ret = el && el.nodeName.toLowerCase() === RegExp.$1 ? [el] : [];
        } else if (rIdSelector.test(selector)) {
          el = Dom._getElementById(selector.substr(1), doc);
          ret = el ? [el] : [];
        } else if (rTagSelector.test(selector)) {
          ret = makeArray(doc.getElementsByTagName(selector));
        } else if (isSimpleSelector(selector)) {
          var parts = selector.split(/\s+/);
          var partsLen;
          var parents = contexts;
          var parentIndex;
          var parentsLen;
          for (i = 0, partsLen = parts.length; i < partsLen; i++) {
            parts[i] = makeMatch(parts[i]);
          }
          for (i = 0, partsLen = parts.length; i < partsLen; i++) {
            var part = parts[i];
            var newParents = [];
            var parMatches;
            for (parentIndex = 0, parentsLen = parents.length; parentIndex < parentsLen; parentIndex++) {
              parMatches = part(parents[parentIndex]);
              newParents.push.apply(newParents, makeArray(parMatches));
            }
            parents = newParents;
            if (!parents.length) {
              break;
            }
          }
          ret = parents && parents.length > 1 ? Dom.unique(parents) : parents;
        }
      }
      if (!ret) {
        ret = [];
        for (i = 0; i < contextsLen; i++) {
          push.apply(ret, Dom._selectInternal(selector, contexts[i]));
        }
        if (ret.length > 1 && contextsLen > 1) {
          Dom.unique(ret);
        }
      }
    } else {
      if (selector.nodeType || util.isWindow(selector)) {
        ret = [selector];
      } else if (selector.getDOMNodes) {
        ret = selector.getDOMNodes();
      } else if (isArray(selector)) {
        ret = selector;
      } else if (isDomNodeList(selector)) {
        ret = makeArray(selector);
      } else {
        ret = [selector];
      }
      if (!simpleContext) {
        var tmp = ret;
        var ci;
        var len = tmp.length;
        ret = [];
        for (i = 0; i < len; i++) {
          for (ci = 0; ci < contextsLen; ci++) {
            if (Dom._contains(contexts[ci], tmp[i])) {
              ret.push(tmp[i]);
              break;
            }
          }
        }
      }
    }
    ret.each = queryEach;
    return ret;
  }
  function hasSingleClass(el, cls) {
    var className = el && getAttr(el, 'class');
    return className && (className = className.replace(/[\r\t\n]/g, SPACE)) && (SPACE + className + SPACE).indexOf(SPACE + cls + SPACE) > -1;
  }
  function getAttr(el, name) {
    var ret = el && el.getAttributeNode(name);
    if (ret && ret.specified) {
      return 'value' in ret ? ret.value : ret.nodeValue;
    }
    return undefined;
  }
  function isTag(el, value) {
    return value === '*' || el.nodeName.toLowerCase() === value.toLowerCase();
  }
  var compareNodeOrder = 'sourceIndex' in docElem ? function (a, b) {
    return a.sourceIndex - b.sourceIndex;
  } : function (a, b) {
    if (!a.compareDocumentPosition || !b.compareDocumentPosition) {
      return a.compareDocumentPosition ? -1 : 1;
    }
    var bit = a.compareDocumentPosition(b) & 4;
    return bit ? -1 : 1;
  };
  var matchesInternal = querySelectorAll && querySelectorAll.matches ? querySelectorAll.matches : function (str, seeds) {
    var ret = [];
    var i = 0;
    var n;
    var len = seeds.length;
    for (; i < len; i++) {
      n = seeds[i];
      if (matches.call(n, str)) {
        ret.push(n);
      }
    }
    return ret;
  };
  util.mix(Dom, {
    _getElementsByTagName: function (name, context) {
      return makeArray(context.querySelectorAll(name));
    },
    _getElementById: function (id, rootDoc) {
      return rootDoc.getElementById(id);
    },
    _getSimpleAttr: getAttr,
    _isTag: isTag,
    _hasSingleClass: hasSingleClass,
    _selectInternal: querySelectorAll || function (str, context) {
      return makeArray(context.querySelectorAll(str));
    },
    query: query,
    get: function (selector, context) {
      return query(selector, context)[0] || null;
    },
    unique: function () {
      var hasDuplicate;
      var baseHasDuplicate = true;
      [
        0,
        0
      ].sort(function () {
        baseHasDuplicate = false;
        return 0;
      });
      function sortOrder(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        return compareNodeOrder(a, b);
      }
      return function (elements) {
        hasDuplicate = baseHasDuplicate;
        elements.sort(sortOrder);
        if (hasDuplicate) {
          var i = 1;
          var len = elements.length;
          while (i < len) {
            if (elements[i] === elements[i - 1]) {
              elements.splice(i, 1);
              --len;
            } else {
              i++;
            }
          }
        }
        return elements;
      };
    }(),
    filter: function (selector, filter, context) {
      var elems = query(selector, context);
      var id;
      var tag;
      var match;
      var cls;
      var ret = [];
      if (typeof filter === 'string' && (filter = trim(filter)) && (match = rSimpleSelector.exec(filter))) {
        id = match[1];
        tag = match[2];
        cls = match[3];
        if (!id) {
          filter = function (elem) {
            var tagRe = true;
            var clsRe = true;
            if (tag) {
              tagRe = isTag(elem, tag);
            }
            if (cls) {
              clsRe = hasSingleClass(elem, cls);
            }
            return clsRe && tagRe;
          };
        } else if (id && !tag && !cls) {
          filter = function (elem) {
            return getAttr(elem, 'id') === id;
          };
        }
      }
      if (typeof filter === 'function') {
        ret = util.filter(elems, filter);
      } else {
        ret = matchesInternal(filter, elems);
      }
      return ret;
    },
    test: function (selector, filter, context) {
      var elements = query(selector, context);
      return elements.length && Dom.filter(elements, filter, context).length === elements.length;
    }
  });
  return exports;
}();
domBaseLibMainTraversal = function (exports) {
  var util = utilBase;
  var Dom = domBaseLibMainApi;
  var NodeType = Dom.NodeType;
  var CONTAIN_MASK = 16;
  util.mix(Dom, {
    _contains: function (a, b) {
      return !!(a.compareDocumentPosition(b) & CONTAIN_MASK);
    },
    closest: function (selector, filter, context, allowTextNode) {
      return nth(selector, filter, 'parentNode', function (elem) {
        return elem.nodeType !== NodeType.DOCUMENT_FRAGMENT_NODE;
      }, context, true, allowTextNode);
    },
    parent: function (selector, filter, context) {
      return nth(selector, filter, 'parentNode', function (elem) {
        return elem.nodeType !== NodeType.DOCUMENT_FRAGMENT_NODE;
      }, context, undefined);
    },
    first: function (selector, filter, allowTextNode) {
      var elem = Dom.get(selector);
      return nth(elem && elem.firstChild, filter, 'nextSibling', undefined, undefined, true, allowTextNode);
    },
    last: function (selector, filter, allowTextNode) {
      var elem = Dom.get(selector);
      return nth(elem && elem.lastChild, filter, 'previousSibling', undefined, undefined, true, allowTextNode);
    },
    next: function (selector, filter, allowTextNode) {
      return nth(selector, filter, 'nextSibling', undefined, undefined, undefined, allowTextNode);
    },
    prev: function (selector, filter, allowTextNode) {
      return nth(selector, filter, 'previousSibling', undefined, undefined, undefined, allowTextNode);
    },
    siblings: function (selector, filter, allowTextNode) {
      return getSiblings(selector, filter, true, allowTextNode);
    },
    children: function (selector, filter) {
      return getSiblings(selector, filter, undefined);
    },
    contents: function (selector, filter) {
      return getSiblings(selector, filter, undefined, 1);
    },
    contains: function (container, contained) {
      container = Dom.get(container);
      contained = Dom.get(contained);
      if (container && contained) {
        return Dom._contains(container, contained);
      }
      return false;
    },
    index: function (selector, s2) {
      var els = Dom.query(selector);
      var c;
      var n = 0;
      var p;
      var els2;
      var el = els[0];
      if (!s2) {
        p = el && el.parentNode;
        if (!p) {
          return -1;
        }
        c = el;
        while (c = c.previousSibling) {
          if (c.nodeType === NodeType.ELEMENT_NODE) {
            n++;
          }
        }
        return n;
      }
      els2 = Dom.query(s2);
      if (typeof s2 === 'string') {
        return util.indexOf(el, els2);
      }
      return util.indexOf(els2[0], els);
    },
    equals: function (n1, n2) {
      n1 = Dom.query(n1);
      n2 = Dom.query(n2);
      if (n1.length !== n2.length) {
        return false;
      }
      for (var i = n1.length; i >= 0; i--) {
        if (n1[i] !== n2[i]) {
          return false;
        }
      }
      return true;
    }
  });
  function nth(elem, filter, direction, extraFilter, context, includeSef, allowTextNode) {
    if (!(elem = Dom.get(elem))) {
      return null;
    }
    if (filter === 0) {
      return elem;
    }
    if (!includeSef) {
      elem = elem[direction];
    }
    if (!elem) {
      return null;
    }
    context = context && Dom.get(context) || null;
    if (filter === undefined) {
      filter = 1;
    }
    var ret = [];
    var isArray = util.isArray(filter);
    var fi;
    var filterLength;
    if (typeof filter === 'number') {
      fi = 0;
      filterLength = filter;
      filter = function () {
        return ++fi === filterLength;
      };
    }
    while (elem && elem !== context) {
      if ((elem.nodeType === NodeType.ELEMENT_NODE || elem.nodeType === NodeType.TEXT_NODE && allowTextNode) && testFilter(elem, filter) && (!extraFilter || extraFilter(elem))) {
        ret.push(elem);
        if (!isArray) {
          break;
        }
      }
      elem = elem[direction];
    }
    return isArray ? ret : ret[0] || null;
  }
  function testFilter(elem, filter) {
    if (!filter) {
      return true;
    }
    if (util.isArray(filter)) {
      var i;
      var l = filter.length;
      if (!l) {
        return true;
      }
      for (i = 0; i < l; i++) {
        if (Dom.test(elem, filter[i])) {
          return true;
        }
      }
    } else if (Dom.test(elem, filter)) {
      return true;
    }
    return false;
  }
  function getSiblings(selector, filter, parent, allowText) {
    var ret = [];
    var tmp;
    var i;
    var el;
    var elem = Dom.get(selector);
    var parentNode = elem;
    if (elem && parent) {
      parentNode = elem.parentNode;
    }
    if (parentNode) {
      tmp = util.makeArray(parentNode.childNodes);
      for (i = 0; i < tmp.length; i++) {
        el = tmp[i];
        if (!allowText && el.nodeType !== NodeType.ELEMENT_NODE) {
          continue;
        }
        if (el === elem) {
          continue;
        }
        ret.push(el);
      }
      if (filter) {
        ret = Dom.filter(ret, filter);
      }
    }
    return ret;
  }
  return exports;
}();
domBaseLibMain = function (exports) {
  var Dom = domBaseLibMainApi;
  domBaseLibMainAttr;
  domBaseLibMainClass;
  domBaseLibMainCreate;
  domBaseLibMainData;
  domBaseLibMainInsertion;
  domBaseLibMainOffset;
  domBaseLibMainStyle;
  domBaseLibMainSelector;
  domBaseLibMainTraversal;
  exports = Dom;
  return exports;
}();
domBaseIndex = function (exports) {
  exports = domBaseLibMain;
  return exports;
}();
return domBaseIndex;
});define("query-selector-base", [], function(require) {

//! Copyright 2015, query-selector-base@6.1.2 MIT Licensed, build time: Thu, 29 Oct 2015 12:31:02 GMT 
/*
combined modules:
query-selector-base
*/
var querySelectorBaseIndex;
querySelectorBaseIndex = function (exports) {
  exports = null;
  return exports;
}();
return querySelectorBaseIndex;
});define("dom-extra", ["dom-base",'util',"feature"], function(require) {
var domBase = require("dom-base");
var utilBase = require('util');
var feature = require("feature");
//! Copyright 2015, dom-extra@6.1.2 MIT Licensed, build time: Thu, 29 Oct 2015 09:44:48 GMT 
/*
combined modules:
dom-extra
dom-extra/lib/extra
dom-extra/lib/extra/api
dom-extra/lib/extra/attr
dom-extra/lib/extra/create
dom-extra/lib/extra/data
dom-extra/lib/extra/insertion
dom-extra/lib/extra/offset
dom-extra/lib/extra/style
*/
var domExtraLibExtraApi, domExtraLibExtraAttr, domExtraLibExtraCreate, domExtraLibExtraData, domExtraLibExtraInsertion, domExtraLibExtraOffset, domExtraLibExtraStyle, domExtraLibExtra, domExtraIndex;
domExtraLibExtraApi = function (exports) {
  var Dom = domBase;
  exports = Dom;
  return exports;
}();
domExtraLibExtraAttr = function (exports) {
  var util = utilBase;
  var Dom = domExtraLibExtraApi;
  var doc = document;
  var docElement = doc && doc.documentElement;
  var getProp = Dom._getProp;
  util.mix(Dom, {
    /**
     * Whether one of the matched elements has specified attribute
     * @method
     * @param {HTMLElement[]|String} selector matched elements
     * @param {String} name The attribute to be tested
     * @return {Boolean}
     */
    hasAttr: docElement && !docElement.hasAttribute ? function (selector, name) {
      name = name.toLowerCase();
      var elems = Dom.query(selector);
      var i, el, attrNode;
      // from ppk :http://www.quirksmode.org/dom/w3c_core.html
      // IE5-7 doesn't return the value of a style attribute.
      // var $attr = el.attributes[name];
      for (i = 0; i < elems.length; i++) {
        el = elems[i];
        attrNode = el.getAttributeNode(name);
        if (attrNode && attrNode.specified) {
          return true;
        }
      }
      return false;
    } : function (selector, name) {
      var elems = Dom.query(selector);
      var len = elems.length;
      for (var i = 0; i < len; i++) {
        //使用原生实现
        if (elems[i].hasAttribute(name)) {
          return true;
        }
      }
      return false;
    },
    /**
     * Whether one of the matched elements has specified property name
     * @param {HTMLElement[]|String|HTMLElement} selector 元素
     * @param {String} name The name of property to test
     * @return {Boolean}
     */
    hasProp: function (selector, name) {
      var elems = Dom.query(selector);
      var i, el;
      var len = elems.length;
      for (i = 0; i < len; i++) {
        el = elems[i];
        if (getProp(el, name) !== undefined) {
          return true;
        }
      }
      return false;
    }
  });
  return exports;
}();
domExtraLibExtraCreate = function (exports) {
  var util = utilBase;
  var Dom = domExtraLibExtraApi;
  var doc = document, supportOuterHTML = doc && 'outerHTML' in doc.documentElement, NodeType = Dom.NodeType, getHolderDiv = Dom._getHolderDiv;
  util.mix(Dom, {
    /**
     * Get the outerHTML of the first element in the set of matched elements.
     * or
     * Set the outerHTML of each element in the set of matched elements.
     * @param {HTMLElement|String|HTMLElement[]} selector matched elements
     * @param {String} [htmlString]  A string of HTML to set as outerHTML of each matched element.
     * @param {Boolean} [loadScripts=false] True to look for and process scripts
     * @param {Object} [DOMEvent] Pass the Kissy's DOM-Event Object to remove all event listeners attached on elements
     */
    outerHtml: function (selector, htmlString, loadScripts, DOMEvent) {
      var els = Dom.query(selector), holder, i, valNode, length = els.length, el = els[0];
      if (!el) {
        return null;
      }
      // getter
      if (htmlString === undefined) {
        if (supportOuterHTML && el.nodeType !== NodeType.DOCUMENT_FRAGMENT_NODE) {
          return el.outerHTML;
        } else {
          holder = getHolderDiv(el.ownerDocument, 1);
          holder.appendChild(Dom.clone(el, true));
          return holder.innerHTML;
        }
      } else {
        htmlString += '';
        if (!htmlString.match(/<(?:script|style|link)/i) && supportOuterHTML) {
          for (i = length - 1; i >= 0; i--) {
            el = els[i];
            if (el.nodeType === NodeType.ELEMENT_NODE) {
              Dom.cleanData(el, 1);
              el.outerHTML = htmlString;
            }
          }
        } else {
          valNode = Dom.create(htmlString, 0, el.ownerDocument, 0);
          Dom.insertBefore(valNode, els, loadScripts);
          Dom.remove(els, false, DOMEvent);
        }
      }
      return undefined;
    }
  });
  // compatibility
  Dom.outerHTML = Dom.outerHtml;
  return exports;
}();
domExtraLibExtraData = function (exports) {
  var util = utilBase;
  var Dom = domExtraLibExtraApi;
  var win = window, EXPANDO = Dom.__EXPANDO,
    // 让每一份 kissy 的 expando 都不同
    dataCache = Dom._dataCache,
    // 存储 node 节点的 data
    winDataCache = Dom._winDataCache;
  // 避免污染全局
  var commonOps = {
    hasData: function (cache, name) {
      if (cache) {
        if (name !== undefined) {
          if (name in cache) {
            return true;
          }
        } else if (!util.isEmptyObject(cache)) {
          return true;
        }
      }
      return false;
    }
  };
  var objectOps = {
    hasData: function (ob, name) {
      // 只判断当前窗口，iframe 窗口内数据直接放入全局变量
      if (ob === win) {
        return objectOps.hasData(winDataCache, name);
      }
      // 直接建立在对象内
      var thisCache = ob[EXPANDO];
      return commonOps.hasData(thisCache, name);
    }
  };
  var domOps = {
    hasData: function (elem, name) {
      var key = elem[EXPANDO];
      if (!key) {
        return false;
      }
      var thisCache = dataCache[key];
      return commonOps.hasData(thisCache, name);
    }
  };
  util.mix(Dom, {
    /**
     * Determine whether an element has any data or specified data name associated with it.
     * @param {HTMLElement[]|String|HTMLElement} selector Matched elements
     * @param {String} [name] A string naming the piece of data to set.
     * @return {Boolean}
     */
    hasData: function (selector, name) {
      var ret = false, elems = Dom.query(selector);
      for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (elem.nodeType) {
          ret = domOps.hasData(elem, name);
        } else {
          // window
          ret = objectOps.hasData(elem, name);
        }
        if (ret) {
          return ret;
        }
      }
      return ret;
    }
  });
  return exports;
}();
domExtraLibExtraInsertion = function (exports) {
  var util = utilBase;
  var Dom = domExtraLibExtraApi;
  util.mix(Dom, {
    /**
     * Wrap a node around all elements in the set of matched elements
     * @param {HTMLElement|HTMLElement[]|String} wrappedNodes set of matched elements
     * @param {HTMLElement|String} wrapperNode html node or selector to get the node wrapper
     */
    wrapAll: function (wrappedNodes, wrapperNode) {
      // deep clone
      wrapperNode = Dom.clone(Dom.get(wrapperNode), true);
      wrappedNodes = Dom.query(wrappedNodes);
      if (wrappedNodes[0].parentNode) {
        Dom.insertBefore(wrapperNode, wrappedNodes[0]);
      }
      var c;
      while ((c = wrapperNode.firstChild) && c.nodeType === 1) {
        wrapperNode = c;
      }
      Dom.appendTo(wrappedNodes, wrapperNode);
    },
    /**
     * Wrap a node around each element in the set of matched elements
     * @param {HTMLElement|HTMLElement[]|String} wrappedNodes set of matched elements
     * @param {HTMLElement|String} wrapperNode html node or selector to get the node wrapper
     */
    wrap: function (wrappedNodes, wrapperNode) {
      wrappedNodes = Dom.query(wrappedNodes);
      wrapperNode = Dom.get(wrapperNode);
      util.each(wrappedNodes, function (w) {
        Dom.wrapAll(w, wrapperNode);
      });
    },
    /**
     * Wrap a node around the childNodes of each element in the set of matched elements.
     * @param {HTMLElement|HTMLElement[]|String} wrappedNodes set of matched elements
     * @param {HTMLElement|String} wrapperNode html node or selector to get the node wrapper
     */
    wrapInner: function (wrappedNodes, wrapperNode) {
      wrappedNodes = Dom.query(wrappedNodes);
      wrapperNode = Dom.get(wrapperNode);
      util.each(wrappedNodes, function (w) {
        var contents = w.childNodes;
        if (contents.length) {
          Dom.wrapAll(contents, wrapperNode);
        } else {
          w.appendChild(wrapperNode);
        }
      });
    },
    /**
     * Remove the parents of the set of matched elements from the Dom,
     * leaving the matched elements in their place.
     * @param {HTMLElement|HTMLElement[]|String} wrappedNodes set of matched elements
     */
    unwrap: function (wrappedNodes) {
      wrappedNodes = Dom.query(wrappedNodes);
      util.each(wrappedNodes, function (w) {
        var p = w.parentNode;
        Dom.replaceWith(p, p.childNodes);
      });
    }
  });
  return exports;
}();
domExtraLibExtraOffset = function (exports) {
  var util = utilBase;
  var Dom = domExtraLibExtraApi;
  var getWindow = Dom.getWindow, NodeType = Dom.NodeType, LEFT = 'left', TOP = 'top';
  util.mix(Dom, {
    /**
     * scrolls the first of matched elements into container view
     * @param {HTMLElement[]|String|HTMLElement} selector Matched elements
     * @param {String|HTMLElement|HTMLDocument} [container=window] Container element
     * @param {Boolean|Object} [alignWithTop=true]If true, the scrolled element is aligned with the top of the scroll area.
     * If false, it is aligned with the bottom.
     * @param {Boolean} [alignWithTop.allowHorizontalScroll=true] Whether trigger horizontal scroll.
     * @param {Boolean} [alignWithTop.onlyScrollIfNeeded=false] scrollIntoView when element is out of view
     * and set top to false or true automatically if top is undefined
     * @param {Boolean} [allowHorizontalScroll=true] Whether trigger horizontal scroll.
     * refer: http://www.w3.org/TR/2009/WD-html5-20090423/editing.html#scrollIntoView
     *        http://www.sencha.com/deploy/dev/docs/source/Element.scroll-more.html#scrollIntoView
     *        http://yiminghe.javaeye.com/blog/390732
     */
    scrollIntoView: function (selector, container, alignWithTop, allowHorizontalScroll) {
      var elem, onlyScrollIfNeeded;
      if (!(elem = Dom.get(selector))) {
        return;
      }
      if (container) {
        container = Dom.get(container);
      }
      if (!container) {
        container = elem.ownerDocument;
      }
      // document 归一化到 window
      if (container.nodeType === NodeType.DOCUMENT_NODE) {
        container = getWindow(container);
      }
      if (typeof alignWithTop === 'object') {
        allowHorizontalScroll = alignWithTop.allowHorizontalScroll;
        onlyScrollIfNeeded = alignWithTop.onlyScrollIfNeeded;
        alignWithTop = alignWithTop.alignWithTop;
      }
      allowHorizontalScroll = allowHorizontalScroll === undefined ? true : allowHorizontalScroll;
      var isWin = util.isWindow(container), elemOffset = Dom.offset(elem), eh = Dom.outerHeight(elem), ew = Dom.outerWidth(elem), containerOffset, ch, cw, containerScroll, diffTop, diffBottom, win, winScroll, ww, wh;
      if (isWin) {
        win = container;
        wh = Dom.height(win);
        ww = Dom.width(win);
        winScroll = {
          left: Dom.scrollLeft(win),
          top: Dom.scrollTop(win)
        };
        // elem 相对 container 可视视窗的距离
        diffTop = {
          left: elemOffset[LEFT] - winScroll[LEFT],
          top: elemOffset[TOP] - winScroll[TOP]
        };
        diffBottom = {
          left: elemOffset[LEFT] + ew - (winScroll[LEFT] + ww),
          top: elemOffset[TOP] + eh - (winScroll[TOP] + wh)
        };
        containerScroll = winScroll;
      } else {
        containerOffset = Dom.offset(container);
        ch = container.clientHeight;
        cw = container.clientWidth;
        containerScroll = {
          left: Dom.scrollLeft(container),
          top: Dom.scrollTop(container)
        };
        // elem 相对 container 可视视窗的距离
        // 注意边框 , offset 是边框到根节点
        diffTop = {
          left: elemOffset[LEFT] - (containerOffset[LEFT] + (parseFloat(Dom.css(container, 'borderLeftWidth')) || 0)),
          top: elemOffset[TOP] - (containerOffset[TOP] + (parseFloat(Dom.css(container, 'borderTopWidth')) || 0))
        };
        diffBottom = {
          left: elemOffset[LEFT] + ew - (containerOffset[LEFT] + cw + (parseFloat(Dom.css(container, 'borderRightWidth')) || 0)),
          top: elemOffset[TOP] + eh - (containerOffset[TOP] + ch + (parseFloat(Dom.css(container, 'borderBottomWidth')) || 0))
        };
      }
      if (onlyScrollIfNeeded) {
        if (diffTop.top < 0 || diffBottom.top > 0) {
          // 强制向上
          if (alignWithTop === true) {
            Dom.scrollTop(container, containerScroll.top + diffTop.top);
          } else if (alignWithTop === false) {
            Dom.scrollTop(container, containerScroll.top + diffBottom.top);
          } else {
            // 自动调整
            if (diffTop.top < 0) {
              Dom.scrollTop(container, containerScroll.top + diffTop.top);
            } else {
              Dom.scrollTop(container, containerScroll.top + diffBottom.top);
            }
          }
        }
      } else {
        alignWithTop = alignWithTop === undefined ? true : !!alignWithTop;
        if (alignWithTop) {
          Dom.scrollTop(container, containerScroll.top + diffTop.top);
        } else {
          Dom.scrollTop(container, containerScroll.top + diffBottom.top);
        }
      }
      if (allowHorizontalScroll) {
        if (onlyScrollIfNeeded) {
          if (diffTop.left < 0 || diffBottom.left > 0) {
            // 强制向上
            if (alignWithTop === true) {
              Dom.scrollLeft(container, containerScroll.left + diffTop.left);
            } else if (alignWithTop === false) {
              Dom.scrollLeft(container, containerScroll.left + diffBottom.left);
            } else {
              // 自动调整
              if (diffTop.left < 0) {
                Dom.scrollLeft(container, containerScroll.left + diffTop.left);
              } else {
                Dom.scrollLeft(container, containerScroll.left + diffBottom.left);
              }
            }
          }
        } else {
          alignWithTop = alignWithTop === undefined ? true : !!alignWithTop;
          if (alignWithTop) {
            Dom.scrollLeft(container, containerScroll.left + diffTop.left);
          } else {
            Dom.scrollLeft(container, containerScroll.left + diffBottom.left);
          }
        }
      }
    }
  });
  return exports;
}();
domExtraLibExtraStyle = function (exports) {
  var util = utilBase;
  var Feature = feature;
  var Dom = domExtraLibExtraApi;
  var camelCase = util.camelCase, style = Dom._style, getNodeName = Dom.nodeName, getCssVendorInfo = Feature.getCssVendorInfo, userSelectVendorInfo = getCssVendorInfo('userSelect'), userSelectProperty = userSelectVendorInfo && userSelectVendorInfo.propertyName;
  util.mix(Dom, {
    /**
     *  Get inline style property from the first element of matched elements
     *  or
     *  Set one or more CSS properties for the set of matched elements.
     *  @param {HTMLElement[]|String|HTMLElement} selector Matched elements
     *  @param {String|Object} name A CSS property. or A map of property-value pairs to set.
     *  @param [val] A value to set for the property.
     *  @return {undefined|String}
     */
    style: function (selector, name, val) {
      var els = Dom.query(selector), k, ret, elem = els[0], i;
      // supports hash
      if (typeof name === 'object') {
        for (k in name) {
          k = camelCase(k);
          for (i = els.length - 1; i >= 0; i--) {
            style(els[i], k, name[k], 1);
          }
        }
        return undefined;
      }
      name = camelCase(name);
      if (val === undefined) {
        ret = '';
        if (elem) {
          ret = style(elem, name, val, 1);
        }
        return ret;
      } else {
        for (i = els.length - 1; i >= 0; i--) {
          style(els[i], name, val, 1);
        }
      }
      return undefined;
    },
    /**
     * Make matched elements unselectable
     * @param {HTMLElement[]|String|HTMLElement} selector  Matched elements.
     */
    unselectable: userSelectProperty ? function (selector) {
      var els = Dom.query(selector);
      for (var j = els.length - 1; j >= 0; j--) {
        els[j].style[userSelectProperty] = 'none';
      }
    } : function (selector) {
      var _els = Dom.query(selector), elem, j, e, i = 0, excludes, style, els;
      excludes = [
        'iframe',
        'textarea',
        'input',
        'select'
      ];
      for (j = _els.length - 1; j >= 0; j--) {
        elem = _els[j];
        style = elem.style;
        els = elem.getElementsByTagName('*');
        elem.setAttribute('unselectable', 'on');
        while (e = els[i++]) {
          if (!util.inArray(getNodeName(e), excludes)) {
            e.setAttribute('unselectable', 'on');
          }
        }
      }
    }
  });
  return exports;
}();
domExtraLibExtra = function (exports) {
  var Dom = domExtraLibExtraApi;
  domExtraLibExtraAttr;
  domExtraLibExtraCreate;
  domExtraLibExtraData;
  domExtraLibExtraInsertion;
  domExtraLibExtraOffset;
  domExtraLibExtraStyle;
  exports = Dom;
  return exports;
}();
domExtraIndex = function (exports) {
  exports = domExtraLibExtra;
  return exports;
}();
return domExtraIndex;
});define("io-form", ['util','dom',"querystring","io-base"], function(require) {
var utilBase = require('util');
var domBase = require('dom');
var _querystring_ = require("querystring");
var ioBase = require("io-base");
//! Copyright 2015, io-form@6.1.2 MIT Licensed, build time: Tue, 03 Nov 2015 06:31:15 GMT 
/*
combined modules:
io-form
io-form/lib/form
io-form/lib/form-serializer
*/
var ioFormLibFormSerializer, ioFormLibForm, ioFormIndex;
ioFormLibFormSerializer = function (exports) {
  /**
   * @ignore
   * form data  serialization util
   * @author yiminghe@gmail.com
   */
  var util = utilBase;
  var Dom = domBase;
  var querystring = _querystring_;
  var rselectTextarea = /^(?:select|textarea)/i, rCRLF = /\r?\n/g, FormSerializer, rinput = /^(?:color|date|datetime|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i;
  function normalizeCRLF(v) {
    return v.replace(rCRLF, '\r\n');
  }
  FormSerializer = {
    /**
     * form serialization
     * @method
     * @param {HTMLElement[]|HTMLElement|Node} forms form elements
     * @return {String} serialized string represent form elements
     * @param {Boolean}[serializeArray=false] See {@link KISSY#method-param} 同名参数
     * @member IO
     * @static
     */
    serialize: function (forms, serializeArray) {
      // 名值键值对序列化,数组元素名字前不加 []
      return querystring.stringify(FormSerializer.getFormData(forms), undefined, undefined, serializeArray || false);
    },
    getFormData: function (forms) {
      var elements = [], data = {};
      util.each(Dom.query(forms), function (el) {
        // form 取其表单元素集合
        // 其他直接取自身
        var subs = el.elements ? elementsToArray(el.elements) : [el];
        elements.push.apply(elements, subs);
      });
      // 对表单元素进行过滤，具备有效值的才保留
      elements = util.filter(elements, function (el) {
        // 有名字
        return el.name && // 不被禁用
        !el.disabled && // radio,checkbox 被选择了
        (el.checked || // select 或者 textarea
        rselectTextarea.test(el.nodeName) || // input 类型
        rinput.test(el.type));
      });
      util.each(elements, function (el) {
        var val = Dom.val(el), vs;
        // <select></select> select nothing!
        // #297
        if (val === null) {
          return;
        }
        // 字符串换行平台归一化
        if (util.isArray(val)) {
          val = util.map(val, normalizeCRLF);
        } else {
          val = normalizeCRLF(val);
        }
        vs = data[el.name];
        if (vs === undefined) {
          data[el.name] = val;
          return;
        }
        if (!util.isArray(vs)) {
          // 多个元素重名时搞成数组
          vs = data[el.name] = [vs];
        }
        vs.push.apply(vs, util.makeArray(val));
      });
      return data;
    }
  };
  // do not pass form.elements to S.makeArray ie678 bug
  function elementsToArray(elements) {
    var ret = [];
    for (var i = 0; i < elements.length; i++) {
      ret.push(elements[i]);
    }
    return ret;
  }
  exports = FormSerializer;
  return exports;
}();
ioFormLibForm = function (exports) {
  var util = utilBase;
  var IO = ioBase;
  var Dom = domBase;
  var querystring = _querystring_;
  var FormSerializer = ioFormLibFormSerializer;
  var win = window, slice = Array.prototype.slice, FormData = win.FormData;
  IO.addPreprocessor('start', function (e) {
    var io = e.io, form, d, dataType, formParam, data, c = io.config, tmpForm = c.form;
    if (tmpForm) {
      form = Dom.get(tmpForm);
      data = c.data;
      var isUpload = false;
      var files = {};
      var inputs = Dom.query('input', form);
      for (var i = 0, l = inputs.length; i < l; i++) {
        var input = inputs[i];
        if (input.type.toLowerCase() === 'file') {
          isUpload = true;
          if (!FormData) {
            break;
          }
          var selected = slice.call(input.files, 0);
          files[Dom.attr(input, 'name')] = selected.length > 1 ? selected : selected[0] || null;
        }
      }
      if (isUpload && FormData) {
        c.files = c.files || {};
        util.mix(c.files, files);
        delete c.contentType;
      }
      if (!isUpload || FormData) {
        formParam = FormSerializer.getFormData(form);
        if (c.hasContent) {
          formParam = querystring.stringify(formParam, undefined, undefined, c.serializeArray);
          if (data) {
            c.data += '&' + formParam;
          } else {
            c.data = formParam;
          }
        } else {
          util.mix(c.uri.query, formParam);
        }
      } else {
        dataType = c.dataType;
        d = dataType[0];
        if (d === '*') {
          d = 'text';
        }
        dataType.length = 2;
        dataType[0] = 'iframe';
        dataType[1] = d;
      }
    }
  });
  exports = FormSerializer;
  return exports;
}();
ioFormIndex = function (exports) {
  exports = ioFormLibForm;
  return exports;
}();
return ioFormIndex;
});define("node", ["node-base","node-event","node-anim"], function(require) {
var nodeBase = require("node-base");
var nodeEvent = require("node-event");
var nodeAnim = require("node-anim");
//! Copyright 2015, node@6.1.0 MIT Licensed, build time: Thu, 29 Oct 2015 12:25:22 GMT 
/*
combined modules:
node
*/
var nodeIndex;
nodeIndex = function (exports) {
  var Node = nodeBase;
  nodeEvent;
  nodeAnim;
  exports = Node;
  return exports;
}();
return nodeIndex;
});define("node-base", ['util','dom'], function(require) {
var utilBase = require('util');
var domBase = require('dom');
//! Copyright 2015, node-base@6.1.1 MIT Licensed, build time: Wed, 16 Dec 2015 07:40:56 GMT 
/*
combined modules:
node-base
node-base/lib/base
node-base/lib/attach
node-base/lib/override
*/
var nodeBaseLibBase, nodeBaseLibAttach, nodeBaseLibOverride, nodeBaseIndex;
nodeBaseLibBase = function (exports) {
  /**
   * @ignore
   * definition for node and nodelist
   * @author yiminghe@gmail.com, lifesinger@gmail.com
   */
  var util = utilBase;
  var Dom = domBase;
  var AP = Array.prototype, slice = AP.slice, NodeType = Dom.NodeType, push = AP.push, makeArray = util.makeArray, isDomNodeList = Dom.isDomNodeList;
  /**
   * The Node class provides a {@link KISSY.DOM} wrapper for manipulating Dom Node.
   * use KISSY.all/one to retrieve NodeList instances.
   *
   *
   *      @example
   *      KISSY.all('a').attr('href','http://docs.kissyui.com');
   *
   * @class KISSY.Node
   */
  function Node(html, attrs, ownerDocument) {
    var self = this, domNode;
    if (html instanceof Node && arguments.length === 1) {
      return html.slice();
    }
    if (!(self instanceof Node)) {
      return Node.all.apply(Node, arguments);
    }
    // handle Node(''), Node(null), or Node(undefined)
    if (!html) {
      return self;
    } else if (typeof html === 'string') {
      // create from html
      domNode = Dom.create(html, attrs, ownerDocument);
      // ('<p>1</p><p>2</p>') 转换为 Node
      if (domNode.nodeType === NodeType.DOCUMENT_FRAGMENT_NODE) {
        // fragment
        push.apply(this, makeArray(domNode.childNodes));
        return self;
      }
    } else if (util.isArray(html) || isDomNodeList(html)) {
      push.apply(self, makeArray(html));
      return self;
    } else {
      // node, document, window
      domNode = html;
    }
    self[0] = domNode;
    self.length = 1;
    return self;
  }
  Node.prototype = {
    constructor: Node,
    isNode: true,
    /**
     * length of Node
     * @type {Number}
     */
    length: 0,
    /**
     * Get one node at index
     * @param {Number} index Index position.
     * @return {KISSY.Node}
     */
    item: function (index) {
      var self = this;
      index = parseInt(index, 10);
      return typeof index === 'number' && !isNaN(index) && index < self.length ? new Node(self[index]) : null;
    },
    /**
     * return a new Node object which consists of current node list and parameter node list.
     * @param {KISSY.Node} selector Selector string or html string or common dom node.
     * @param {KISSY.Node|Number} [context] Search context for selector
     * @param {Number} [index] Insert position.
     * @return {KISSY.Node} a new Node
     */
    add: function (selector, context, index) {
      if (typeof context === 'number') {
        index = context;
        context = undefined;
      }
      var list = Node.all(selector, context).getDOMNodes(), ret = new Node(this);
      if (index === undefined) {
        push.apply(ret, list);
      } else {
        var args = [
          index,
          0
        ];
        args.push.apply(args, list);
        AP.splice.apply(ret, args);
      }
      return ret;
    },
    /**
     * Get part of node list.
     * Arguments are same with Array.prototype.slice
     * @return {KISSY.Node}
     */
    slice: function () {
      // ie<9 : [1,2].slice(0 - 2,undefined) => []
      // ie<9 : [1,2].slice(0 - 2) => [1,2]
      // fix #85
      return new Node(slice.apply(this, arguments));
    },
    /**
     * Retrieves the DOMNodes.
     */
    getDOMNodes: function () {
      return slice.call(this);
    },
    /**
     * Applies the given function to each Node in the Node.
     * @param {Function} fn The function to apply. It receives 3 arguments:
     * the current node instance, the node's index,
     * and the Node instance
     * @param [context] An optional context to
     * apply the function with Default context is the current Node instance
     * @return {KISSY.Node}
     */
    each: function (fn, context) {
      util.each(this, function (n, i) {
        // n = new Node(n);
        return fn.call(context || n, n, i, this);
      }, this);
      return this;
    },
    /**
     * Executes the supplied function on each item in the array.
     * Returns a new array containing the items that the supplied
     * function returned for.
     * @method
     * @param fn {Function} the function to execute on each item
     * @param [context] {Object} optional context object
     * refer: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/map
     * @return {KISSY.Node} The items on which the supplied function returned
     */
    map: function (fn, context) {
      return util.map(this, function (n, i) {
        // n = new Node(n);
        return fn.call(context || n, n, i, this);
      }, this);
    },
    /**
     * Retrieves the DOMNode.
     * @return {HTMLElement}
     */
    getDOMNode: function () {
      return this[0];
    },
    /**
     * return last stack node list.
     * @return {KISSY.Node}
     */
    end: function () {
      var self = this;
      return self.__parent || self;
    },
    /**
     * return new Node which contains only nodes which passes filter
     * @param {String|Function} filter
     * @return {KISSY.Node}
     */
    filter: function (filter) {
      return new Node(Dom.filter(this, !util.isString(filter) ? function (val, idx, arr) {
        return filter.call(val, val, idx, arr);
      } : filter));
    },
    /**
     * Get node list which are descendants of current node list.
     * @param {String} selector Selector string
     * @return {KISSY.Node}
     */
    all: function (selector) {
      var ret, self = this;
      if (self.length > 0) {
        ret = Node.all(selector, self);
      } else {
        ret = new Node();
      }
      ret.__parent = self;
      return ret;
    },
    /**
     * Get node list which match selector under current node list sub tree.
     * @param {String} selector
     * @return {KISSY.Node}
     */
    one: function (selector) {
      var self = this, all = self.all(selector), ret = all.length ? all.slice(0, 1) : null;
      if (ret) {
        ret.__parent = self;
      }
      return ret;
    }
  };
  Node.prototype.find = Node.prototype.all;
  Node.fn = Node.prototype;
  util.mix(Node, {
    /**
     * Get node list from selector or construct new node list from html string.
     * Can also called from KISSY.all
     * @param {String|KISSY.Node} selector Selector string or html string or common dom node.
     * @param {String|KISSY.Node} [context] Search context for selector
     * @return {KISSY.Node}
     * @member KISSY.Node
     * @static
     */
    all: function (selector, context) {
      // are we dealing with html string ?
      // TextNode 仍需要自己 new Node
      if (typeof selector === 'string' && (selector = util.trim(selector)) && selector.length >= 3 && util.startsWith(selector, '<') && util.endsWith(selector, '>')) {
        var attrs;
        if (context) {
          if (context.getDOMNode) {
            context = context[0];
          }
          if (!context.nodeType) {
            attrs = context;
            context = arguments[2];
          }
        }
        return new Node(selector, attrs, context);
      }
      return new Node(Dom.query(selector, context));
    },
    /**
     * Get node list with length of one
     * from selector or construct new node list from html string.
     * @param {String|KISSY.Node} selector Selector string or html string or common dom node.
     * @param {String|KISSY.Node} [context] Search context for selector
     * @return {KISSY.Node}
     * @member KISSY.Node
     * @static
     */
    one: function (selector, context) {
      var all = Node.all(selector, context);
      return all.length ? all.slice(0, 1) : null;
    }
  });
  Node.Dom = Dom;
  // for kissy
  if ('undefined' !== typeof KISSY) {
    util.mix(KISSY, {
      all: Node.all,
      one: Node.one
    });
  }
  exports = Node;
  return exports;
}();
nodeBaseLibAttach = function (exports) {
  var util = utilBase;
  var Dom = domBase;
  var Node = nodeBaseLibBase;
  var NLP = Node.prototype, makeArray = util.makeArray, DOM_INCLUDES_NORM = [
      'nodeName',
      'isCustomDomain',
      'getEmptyIframeSrc',
      'equals',
      'contains',
      'index',
      'scrollTop',
      'scrollLeft',
      'height',
      'width',
      'innerHeight',
      'innerWidth',
      'outerHeight',
      'outerWidth',
      'addStyleSheet',
      'appendTo',
      'prependTo',
      'insertBefore',
      'before',
      'after',
      'insertAfter',
      'test',
      'hasClass',
      'addClass',
      'removeClass',
      'replaceClass',
      'toggleClass',
      'removeAttr',
      'hasAttr',
      'hasProp',
      'show',
      'hide',
      'toggle',
      'scrollIntoView',
      'remove',
      'empty',
      'removeData',
      'hasData',
      'unselectable',
      'wrap',
      'wrapAll',
      'replaceWith',
      'wrapInner',
      'unwrap'
    ], DOM_INCLUDES_NORM_NODE_LIST = [
      'getWindow',
      'getDocument',
      'first',
      'last',
      'parent',
      'closest',
      'next',
      'prev',
      'clone',
      'siblings',
      'contents',
      'children'
    ], DOM_INCLUDES_NORM_IF = {
      attr: 1,
      text: 0,
      css: 1,
      style: 1,
      val: 0,
      prop: 1,
      offset: 0,
      html: 0,
      outerHTML: 0,
      outerHtml: 0,
      data: 1
    };
  function accessNorm(fn, self, args) {
    args.unshift(self);
    var ret = Dom[fn].apply(Dom, args);
    if (ret === undefined) {
      return self;
    }
    return ret;
  }
  function accessNormList(fn, self, args) {
    args.unshift(self);
    var ret = Dom[fn].apply(Dom, args);
    if (ret === undefined) {
      return self;
    } else if (ret === null) {
      return null;
    }
    return new Node(ret);
  }
  function accessNormIf(fn, self, index, args) {
    if (args[index] === undefined && !util.isObject(args[0])) {
      args.unshift(self);
      return Dom[fn].apply(Dom, args);
    }
    return accessNorm(fn, self, args);
  }
  util.each(DOM_INCLUDES_NORM, function (k) {
    NLP[k] = function () {
      var args = makeArray(arguments);
      return accessNorm(k, this, args);
    };
  });
  util.each(DOM_INCLUDES_NORM_NODE_LIST, function (k) {
    NLP[k] = function () {
      var args = makeArray(arguments);
      return accessNormList(k, this, args);
    };
  });
  util.each(DOM_INCLUDES_NORM_IF, function (index, k) {
    NLP[k] = function () {
      var args = makeArray(arguments);
      return accessNormIf(k, this, index, args);
    };
  });
  return exports;
}();
nodeBaseLibOverride = function (exports) {
  var util = utilBase;
  var Dom = domBase;
  var Node = nodeBaseLibBase;
  nodeBaseLibAttach;
  var NLP = Node.prototype;
  util.each([
    'append',
    'prepend',
    'before',
    'after'
  ], function (insertType) {
    NLP[insertType] = function (html) {
      var newNode = html, self = this;
      if (typeof newNode !== 'object') {
        newNode = Dom.create(newNode + '');
      }
      if (newNode) {
        Dom[insertType](newNode, self);
      }
      return self;
    };
  });
  util.each([
    'wrap',
    'wrapAll',
    'replaceWith',
    'wrapInner'
  ], function (fixType) {
    var orig = NLP[fixType];
    NLP[fixType] = function (others) {
      var self = this;
      if (typeof others === 'string') {
        others = Node.all(others, self[0].ownerDocument);
      }
      return orig.call(self, others);
    };
  });
  return exports;
}();
nodeBaseIndex = function (exports) {
  var Node = nodeBaseLibBase;
  nodeBaseLibAttach;
  nodeBaseLibOverride;
  exports = Node;
  return exports;
}();
return nodeBaseIndex;
});define("node-event", ["node-base",'util','event-dom'], function(require) {
var nodeBase = require("node-base");
var utilBase = require('util');
var eventDomBase = require('event-dom');
//! Copyright 2015, node-event@6.1.2 MIT Licensed, build time: Thu, 29 Oct 2015 12:27:55 GMT 
/*
combined modules:
node-event
node-event/lib/attach
*/
var nodeEventLibAttach, nodeEventIndex;
nodeEventLibAttach = function (exports) {
  /**
   * @ignore
   * import methods from Event to Node.prototype
   * @author yiminghe@gmail.com
   */
  var NodeBase = nodeBase;
  var util = utilBase;
  var DomEvent = eventDomBase;
  var NLP = NodeBase.prototype, makeArray = util.makeArray,
    // Event 添加到 NP 上的方法
    EVENT_INCLUDES_SELF = [
      'on',
      'detach',
      'delegate',
      'undelegate',
      // kimi
      'off'
    ], EVENT_INCLUDES_RET = [
      'fire',
      'fireHandler',
      // kimi
      'trigger',
      'triggerHandler'
    ];
  NodeBase.KeyCode = DomEvent.KeyCode;
  NodeBase.Event = DomEvent;
  util.each(EVENT_INCLUDES_SELF, function (k) {
    NLP[k] = function () {
      var self = this, args = makeArray(arguments);
      args.unshift(self);
      DomEvent[k].apply(DomEvent, args);
      return self;
    };
  });
  util.each(EVENT_INCLUDES_RET, function (k) {
    NLP[k] = function () {
      var self = this, args = makeArray(arguments);
      args.unshift(self);
      return DomEvent[k].apply(DomEvent, args);
    };
  });
  exports = NodeBase;
  return exports;
}();
nodeEventIndex = function (exports) {
  exports = nodeEventLibAttach;
  return exports;
}();
return nodeEventIndex;
});define("event-dom-base", ['dom',"event-base",'util'], function(require) {
var domBase = require('dom');
var eventBase = require("event-base");
var utilBase = require('util');
//! Copyright 2015, event-dom-base@6.1.1 MIT Licensed, build time: Thu, 29 Oct 2015 08:16:36 GMT 
/*
combined modules:
event-dom-base
event-dom-base/lib/main
event-dom-base/lib/main/dom-event
event-dom-base/lib/main/utils
event-dom-base/lib/main/special
event-dom-base/lib/main/observable
event-dom-base/lib/main/observer
event-dom-base/lib/main/object
event-dom-base/lib/main/special-events
*/
var eventDomBaseLibMainUtils, eventDomBaseLibMainSpecial, eventDomBaseLibMainObserver, eventDomBaseLibMainObject, eventDomBaseLibMainObservable, eventDomBaseLibMainDomEvent, eventDomBaseLibMainSpecialEvents, eventDomBaseLibMain, eventDomBaseIndex;
eventDomBaseLibMainUtils = function (exports) {
  /**
   * @ignore
   * utils for event
   * @author yiminghe@gmail.com
   */
  var Dom = domBase;
  var EVENT_GUID = 'ksEventTargetId_' + +new Date(), doc = document, simpleAdd = doc && doc.addEventListener ? function (el, type, fn, capture) {
      if (el.addEventListener) {
        el.addEventListener(type, fn, !!capture);
      }
    } : function (el, type, fn) {
      if (el.attachEvent) {
        el.attachEvent('on' + type, fn);
      }
    }, simpleRemove = doc && doc.removeEventListener ? function (el, type, fn, capture) {
      if (el.removeEventListener) {
        el.removeEventListener(type, fn, !!capture);
      }
    } : function (el, type, fn) {
      if (el.detachEvent) {
        el.detachEvent('on' + type, fn);
      }
    };
  exports = {
    simpleAdd: simpleAdd,
    simpleRemove: simpleRemove,
    data: function (elem, v) {
      return Dom.data(elem, EVENT_GUID, v);
    },
    removeData: function (elem) {
      return Dom.removeData(elem, EVENT_GUID);
    }
  };
  return exports;
}();
eventDomBaseLibMainSpecial = function (exports) {
  /**
   * @ignore
   * special house for special events
   * @author yiminghe@gmail.com
   */
  exports = {};
  return exports;
}();
eventDomBaseLibMainObserver = function (exports) {
  /**
   * @ignore
   * observer for dom event.
   * @author yiminghe@gmail.com
   */
  var BaseEvent = eventBase;
  var Special = eventDomBaseLibMainSpecial;
  var util = utilBase;
  /**
   * observer for dom event
   * @class Event.DomEvent.Observer
   * @extends Event.Observer
   * @private
   */
  function DomEventObserver(cfg) {
    DomEventObserver.superclass.constructor.call(this, cfg);
  }
  util.extend(DomEventObserver, BaseEvent.Observer, {
    keys: [
      'fn',
      'filter',
      'data',
      'context',
      'originalType',
      'groups',
      'last'
    ],
    notifyInternal: function (event, ce) {
      var self = this, s, t, ret, type = event.type, originalType;
      if (originalType = self.config.originalType) {
        event.type = originalType;
      } else {
        originalType = type;
      }
      // context undefined 时不能写死在 listener 中，否则不能保证 clone 时的 this
      if ((s = Special[originalType]) && s.handle) {
        t = s.handle(event, self, ce);
        // can handle
        if (t && t.length > 0) {
          ret = t[0];
        }
      } else {
        ret = self.simpleNotify(event, ce);
      }
      if (ret === false) {
        event.halt();
      }
      // notify other mousemove listener
      event.type = type;
      return ret;
    }
  });
  exports = DomEventObserver;
  return exports;
}();
eventDomBaseLibMainObject = function (exports) {
  /**
   * @ignore
   * event object for dom
   * @author yiminghe@gmail.com
   */
  var BaseEvent = eventBase;
  var util = utilBase;
  var DOCUMENT = document, TRUE = true, FALSE = false, commonProps = [
      'altKey',
      'bubbles',
      'cancelable',
      'ctrlKey',
      'currentTarget',
      'eventPhase',
      'metaKey',
      'shiftKey',
      'target',
      'timeStamp',
      'view',
      'type'
    ], eventNormalizers = [
      {
        reg: /^key/,
        props: [
          'char',
          'charCode',
          'key',
          'keyCode',
          'which'
        ],
        fix: function (event, originalEvent) {
          if (event.which == null) {
            event.which = originalEvent.charCode != null ? originalEvent.charCode : originalEvent.keyCode;
          }
          // add metaKey to non-Mac browsers (use ctrl for PC 's and Meta for Macs)
          if (event.metaKey === undefined) {
            event.metaKey = event.ctrlKey;
          }
        }
      },
      {
        reg: /^touch/,
        props: [
          'touches',
          'changedTouches',
          'targetTouches'
        ]
      },
      {
        reg: /^hashchange$/,
        props: [
          'newURL',
          'oldURL'
        ]
      },
      {
        reg: /^gesturechange$/i,
        props: [
          'rotation',
          'scale'
        ]
      },
      {
        reg: /^(mousewheel|DOMMouseScroll)$/,
        props: [],
        fix: function (event, originalEvent) {
          var deltaX, deltaY, delta, wheelDelta = originalEvent.wheelDelta, axis = originalEvent.axis, wheelDeltaY = originalEvent.wheelDeltaY, wheelDeltaX = originalEvent.wheelDeltaX, detail = originalEvent.detail;
          // ie/webkit
          if (wheelDelta) {
            delta = wheelDelta / 120;
          }
          // gecko
          if (detail) {
            // press control e.detail == 1 else e.detail == 3
            delta = 0 - (detail % 3 === 0 ? detail / 3 : detail);
          }
          // Gecko
          if (axis !== undefined) {
            if (axis === event.HORIZONTAL_AXIS) {
              deltaY = 0;
              deltaX = 0 - delta;
            } else if (axis === event.VERTICAL_AXIS) {
              deltaX = 0;
              deltaY = delta;
            }
          }
          // Webkit
          if (wheelDeltaY !== undefined) {
            deltaY = wheelDeltaY / 120;
          }
          if (wheelDeltaX !== undefined) {
            deltaX = -1 * wheelDeltaX / 120;
          }
          // 默认 deltaY (ie)
          if (!deltaX && !deltaY) {
            deltaY = delta;
          }
          if (deltaX !== undefined) {
            /**
             * deltaX of mousewheel event
             * @property deltaX
             * @member Event.DomEvent.Object
             */
            event.deltaX = deltaX;
          }
          if (deltaY !== undefined) {
            /**
             * deltaY of mousewheel event
             * @property deltaY
             * @member Event.DomEvent.Object
             */
            event.deltaY = deltaY;
          }
          if (delta !== undefined) {
            /**
             * delta of mousewheel event
             * @property delta
             * @member Event.DomEvent.Object
             */
            event.delta = delta;
          }
        }
      },
      {
        reg: /^mouse|contextmenu|click|mspointer|(^DOMMouseScroll$)/i,
        props: [
          'buttons',
          'clientX',
          'clientY',
          'button',
          'offsetX',
          'relatedTarget',
          'which',
          'fromElement',
          'toElement',
          'offsetY',
          'pageX',
          'pageY',
          'screenX',
          'screenY'
        ],
        fix: function (event, originalEvent) {
          var eventDoc, doc, body, target = event.target, button = originalEvent.button;
          // Calculate pageX/Y if missing and clientX/Y available
          if (target && event.pageX == null && originalEvent.clientX != null) {
            eventDoc = target.ownerDocument || DOCUMENT;
            doc = eventDoc.documentElement;
            body = eventDoc.body;
            event.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
            event.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
          }
          // which for click: 1 === left; 2 === middle; 3 === right
          // do not use button
          if (!event.which && button !== undefined) {
            event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
          }
          // add relatedTarget, if necessary
          if (!event.relatedTarget && event.fromElement) {
            event.relatedTarget = event.fromElement === target ? event.toElement : event.fromElement;
          }
          return event;
        }
      }
    ];
  function retTrue() {
    return TRUE;
  }
  function retFalse() {
    return FALSE;
  }
  /**
   * Do not new by yourself.
   *
   * KISSY 's dom event system normalizes the event object according to
   * W3C standards.
   *
   * The event object is guaranteed to be passed to
   * the event handler.
   *
   * Most properties from the original event are
   * copied over and normalized to the new event object
   * according to [W3C standards](http://www.w3.org/TR/dom/#event).
   *
   * @class Event.DomEvent.Object
   * @extends Event.Object
   * @private
   * @param originalEvent native dom event
   */
  function DomEventObject(originalEvent) {
    var self = this, type = originalEvent.type;
    var isNative = typeof originalEvent.stopPropagation === 'function' || typeof originalEvent.cancelBubble === 'boolean';
    /**
     * altKey
     * @property altKey
     */
    /**
     * attrChange
     * @property attrChange
     */
    /**
     * attrName
     * @property attrName
     */
    /**
     * bubbles
     * @property bubbles
     */
    /**
     * button
     * @property button
     */
    /**
     * cancelable
     * @property cancelable
     */
    /**
     * charCode
     * @property charCode
     */
    /**
     * clientX
     * @property clientX
     */
    /**
     * clientY
     * @property clientY
     */
    /**
     * ctrlKey
     * @property ctrlKey
     */
    /**
     * data
     * @property data
     */
    /**
     * detail
     * @property detail
     */
    /**
     * eventPhase
     * @property eventPhase
     */
    /**
     * fromElement
     * @property fromElement
     */
    /**
     * handler
     * @property handler
     */
    /**
     * keyCode
     * @property keyCode
     */
    /**
     * metaKey
     * @property metaKey
     */
    /**
     * newValue
     * @property newValue
     */
    /**
     * offsetX
     * @property offsetX
     */
    /**
     * offsetY
     * @property offsetY
     */
    /**
     * pageX
     * @property pageX
     */
    /**
     * pageY
     * @property pageY
     */
    /**
     * prevValue
     * @property prevValue
     */
    /**
     * relatedNode
     * @property relatedNode
     */
    /**
     * relatedTarget
     * @property relatedTarget
     */
    /**
     * screenX
     * @property screenX
     */
    /**
     * screenY
     * @property screenY
     */
    /**
     * shiftKey
     * @property shiftKey
     */
    /**
     * srcElement
     * @property srcElement
     */
    /**
     * toElement
     * @property toElement
     */
    /**
     * view
     * @property view
     */
    /**
     * wheelDelta
     * @property wheelDelta
     */
    /**
     * which
     * @property which
     */
    /**
     * changedTouches
     * @property changedTouches
     */
    /**
     * touches
     * @property touches
     */
    /**
     * targetTouches
     * @property targetTouches
     */
    /**
     * rotation
     * @property rotation
     */
    /**
     * scale
     * @property scale
     */
    /**
     * source html node of current event
     * @property target
     * @type {HTMLElement}
     */
    /**
     * current htm node which processes current event
     * @property currentTarget
     * @type {HTMLElement}
     */
    DomEventObject.superclass.constructor.call(self);
    self.originalEvent = originalEvent;
    // in case dom event has been mark as default prevented by lower dom node
    var isDefaultPrevented = retFalse;
    if ('defaultPrevented' in originalEvent) {
      isDefaultPrevented = originalEvent.defaultPrevented ? retTrue : retFalse;
    } else if ('getPreventDefault' in originalEvent) {
      // https://bugzilla.mozilla.org/show_bug.cgi?id=691151
      isDefaultPrevented = originalEvent.getPreventDefault() ? retTrue : retFalse;
    } else if ('returnValue' in originalEvent) {
      isDefaultPrevented = originalEvent.returnValue === FALSE ? retTrue : retFalse;
    }
    self.isDefaultPrevented = isDefaultPrevented;
    var fixFns = [], fixFn, l, prop, props = commonProps.concat();
    util.each(eventNormalizers, function (normalizer) {
      if (type.match(normalizer.reg)) {
        props = props.concat(normalizer.props);
        if (normalizer.fix) {
          fixFns.push(normalizer.fix);
        }
      }
      return undefined;
    });
    l = props.length;
    // clone properties of the original event object
    while (l) {
      prop = props[--l];
      self[prop] = originalEvent[prop];
    }
    // fix target property, if necessary
    if (!self.target && isNative) {
      self.target = originalEvent.srcElement || DOCUMENT;
    }
    // check if target is a text node (safari)
    if (self.target && self.target.nodeType === 3) {
      self.target = self.target.parentNode;
    }
    l = fixFns.length;
    while (l) {
      fixFn = fixFns[--l];
      fixFn(self, originalEvent);
    }
    self.timeStamp = originalEvent.timeStamp || util.now();
  }
  util.extend(DomEventObject, BaseEvent.Object, {
    constructor: DomEventObject,
    preventDefault: function () {
      var self = this, e = self.originalEvent;
      // if preventDefault exists run it on the original event
      if (e.preventDefault) {
        e.preventDefault();
      } else {
        // otherwise set the returnValue property of the original event to FALSE (IE)
        e.returnValue = FALSE;
      }
      DomEventObject.superclass.preventDefault.call(self);
    },
    stopPropagation: function () {
      var self = this, e = self.originalEvent;
      // if stopPropagation exists run it on the original event
      if (e.stopPropagation) {
        e.stopPropagation();
      } else {
        // otherwise set the cancelBubble property of the original event to TRUE (IE)
        e.cancelBubble = TRUE;
      }
      DomEventObject.superclass.stopPropagation.call(self);
    }
  });
  exports = DomEventObject;
  return exports;
}();
eventDomBaseLibMainObservable = function (exports) {
  var util = utilBase;
  var BaseEvent = eventBase;
  var Dom = domBase;
  var Special = eventDomBaseLibMainSpecial;
  var DomEventUtils = eventDomBaseLibMainUtils;
  var DomEventObserver = eventDomBaseLibMainObserver;
  var DomEventObject = eventDomBaseLibMainObject;
  var BaseUtils = BaseEvent.Utils;
  function DomEventObservable(cfg) {
    var self = this;
    util.mix(self, cfg);
    self.reset();
  }
  util.extend(DomEventObservable, BaseEvent.Observable, {
    constructor: DomEventObservable,
    setup: function () {
      var self = this, type = self.type, s = Special[type] || {}, currentTarget = self.currentTarget, eventDesc = DomEventUtils.data(currentTarget), handle = eventDesc.handle;
      if (!s.setup || s.setup.call(currentTarget, type) === false) {
        DomEventUtils.simpleAdd(currentTarget, type, handle);
      }
    },
    reset: function () {
      var self = this;
      DomEventObservable.superclass.reset.call(self);
      self.delegateCount = 0;
      self.lastCount = 0;
    },
    notify: function (event) {
      var target = event.target, eventType = event.type, self = this, currentTarget = self.currentTarget, observers = self.observers, allObservers = [], currentTarget0, ret, gRet, observerObj, i, j, len, delegateCount = self.delegateCount || 0, currentTargetObservers, currentTargetObserver, observer;
      if (delegateCount && target.nodeType) {
        while (target !== currentTarget) {
          if (target.disabled !== true || eventType !== 'click') {
            var cachedMatch = {}, matched, key, filter;
            currentTargetObservers = [];
            for (i = 0; i < delegateCount; i++) {
              observer = observers[i];
              filter = observer.config.filter;
              key = filter + '';
              matched = cachedMatch[key];
              if (matched === undefined) {
                matched = cachedMatch[key] = Dom.test(target, filter);
              }
              if (matched) {
                currentTargetObservers.push(observer);
              }
            }
            if (currentTargetObservers.length) {
              allObservers.push({
                currentTarget: target,
                currentTargetObservers: currentTargetObservers
              });
            }
          }
          target = target.parentNode || currentTarget;
        }
      }
      if (delegateCount < observers.length) {
        allObservers.push({
          currentTarget: currentTarget,
          currentTargetObservers: observers.slice(delegateCount)
        });
      }
      for (i = 0, len = allObservers.length; !event.isPropagationStopped() && i < len; ++i) {
        observerObj = allObservers[i];
        currentTargetObservers = observerObj.currentTargetObservers;
        currentTarget0 = observerObj.currentTarget;
        event.currentTarget = currentTarget0;
        for (j = 0; !event.isImmediatePropagationStopped() && j < currentTargetObservers.length; j++) {
          currentTargetObserver = currentTargetObservers[j];
          ret = currentTargetObserver.notify(event, self);
          if (gRet !== false && ret !== undefined) {
            gRet = ret;
          }
        }
      }
      return gRet;
    },
    fire: function (event, onlyHandlers) {
      event = event || {};
      var self = this, eventType = String(self.type), domEventObservable, eventData, specialEvent = Special[eventType] || {}, bubbles = specialEvent.bubbles !== false, currentTarget = self.currentTarget;
      if (specialEvent.fire && specialEvent.fire.call(currentTarget, onlyHandlers) === false) {
        return;
      }
      if (!event.isEventObject) {
        eventData = event;
        event = new DomEventObject({ type: eventType });
        util.mix(event, eventData);
      }
      event.currentTarget = currentTarget;
      event.target = event.target || currentTarget;
      if (specialEvent.preFire && specialEvent.preFire.call(currentTarget, event, onlyHandlers) === false) {
        return;
      }
      var cur = currentTarget, win = Dom.getWindow(cur), curDocument = win.document, eventPath = [], gret, ret, ontype = 'on' + eventType, eventPathIndex = 0;
      do {
        eventPath.push(cur);
        cur = cur.parentNode || cur.ownerDocument || cur === curDocument && win;
      } while (!onlyHandlers && cur && bubbles);
      cur = eventPath[eventPathIndex];
      do {
        event.currentTarget = cur;
        domEventObservable = DomEventObservable.getDomEventObservable(cur, eventType);
        if (domEventObservable) {
          ret = domEventObservable.notify(event);
          if (ret !== undefined && gret !== false) {
            gret = ret;
          }
        }
        if (cur[ontype] && cur[ontype].call(cur) === false) {
          event.preventDefault();
        }
        cur = eventPath[++eventPathIndex];
      } while (!onlyHandlers && cur && !event.isPropagationStopped());
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        try {
          if (currentTarget[eventType] && !util.isWindow(currentTarget)) {
            DomEventObservable.triggeredEvent = eventType;
            currentTarget[eventType]();
          }
        } catch (eError) {
          console.error('event-dom: trigger action error: ' + eError);
        }
        DomEventObservable.triggeredEvent = '';
      }
      return gret;
    },
    on: function (cfg) {
      var self = this, observers = self.observers, s = Special[self.type] || {}, observer = cfg instanceof DomEventObserver ? cfg : new DomEventObserver(cfg);
      if (self.findObserver(observer) === -1) {
        if (observer.config.filter) {
          observers.splice(self.delegateCount, 0, observer);
          self.delegateCount++;
        } else {
          if (observer.config.last) {
            observers.push(observer);
            self.lastCount++;
          } else {
            observers.splice(observers.length - self.lastCount, 0, observer);
          }
        }
        if (s.add) {
          s.add.call(self.currentTarget, observer);
        }
      }
    },
    detach: function (cfg) {
      var groupsRe, self = this, s = Special[self.type] || {}, hasFilter = 'filter' in cfg, filter = cfg.filter, context = cfg.context, fn = cfg.fn, currentTarget = self.currentTarget, observers = self.observers, groups = cfg.groups;
      if (!observers.length) {
        return;
      }
      if (groups) {
        groupsRe = BaseUtils.getGroupsRe(groups);
      }
      var i, j, t, observer, observerContext, len = observers.length;
      if (fn || hasFilter || groupsRe) {
        context = context || currentTarget;
        for (i = 0, j = 0, t = []; i < len; ++i) {
          observer = observers[i];
          var observerConfig = observer.config;
          observerContext = observerConfig.context || currentTarget;
          if (context !== observerContext || fn && fn !== observerConfig.fn || hasFilter && (filter && filter !== observerConfig.filter || !filter && !observerConfig.filter) || groupsRe && !observerConfig.groups.match(groupsRe)) {
            t[j++] = observer;
          } else {
            if (observerConfig.filter && self.delegateCount) {
              self.delegateCount--;
            }
            if (observerConfig.last && self.lastCount) {
              self.lastCount--;
            }
            if (s.remove) {
              s.remove.call(currentTarget, observer);
            }
          }
        }
        self.observers = t;
      } else {
        self.reset();
      }
      self.checkMemory();
    },
    checkMemory: function () {
      var self = this, type = self.type, domEventObservables, handle, s = Special[type] || {}, currentTarget = self.currentTarget, eventDesc = DomEventUtils.data(currentTarget);
      if (eventDesc) {
        domEventObservables = eventDesc.observables;
        if (!self.hasObserver()) {
          handle = eventDesc.handle;
          if (!s.tearDown || s.tearDown.call(currentTarget, type) === false) {
            DomEventUtils.simpleRemove(currentTarget, type, handle);
          }
          delete domEventObservables[type];
        }
        if (util.isEmptyObject(domEventObservables)) {
          eventDesc.handle = null;
          DomEventUtils.removeData(currentTarget);
        }
      }
    }
  });
  DomEventObservable.triggeredEvent = '';
  DomEventObservable.getDomEventObservable = function (node, type) {
    var domEventObservablesHolder = DomEventUtils.data(node), domEventObservables;
    if (domEventObservablesHolder) {
      domEventObservables = domEventObservablesHolder.observables;
    }
    if (domEventObservables) {
      return domEventObservables[type];
    }
    return null;
  };
  DomEventObservable.getDomEventObservablesHolder = function (node, create) {
    var domEventObservables = DomEventUtils.data(node);
    if (!domEventObservables && create) {
      DomEventUtils.data(node, domEventObservables = {});
    }
    return domEventObservables;
  };
  exports = DomEventObservable;
  return exports;
}();
eventDomBaseLibMainDomEvent = function (exports) {
  var BaseEvent = eventBase;
  var DomEventUtils = eventDomBaseLibMainUtils;
  var Dom = domBase;
  var Special = eventDomBaseLibMainSpecial;
  var DomEventObservable = eventDomBaseLibMainObservable;
  var DomEventObject = eventDomBaseLibMainObject;
  var util = utilBase;
  var BaseUtils = BaseEvent.Utils;
  function fixType(cfg, type) {
    var s = Special[type] || {}, typeFix;
    if (!cfg.originalType && (typeFix = s.typeFix)) {
      cfg.originalType = type;
      type = typeFix;
    }
    return type;
  }
  function addInternal(currentTarget, type, cfg) {
    var domEventObservablesHolder, domEventObservable, domEventObservables, handle;
    cfg = util.merge(cfg);
    type = fixType(cfg, type);
    domEventObservablesHolder = DomEventObservable.getDomEventObservablesHolder(currentTarget, 1);
    if (!(handle = domEventObservablesHolder.handle)) {
      handle = domEventObservablesHolder.handle = function (event) {
        var type = event.type, domEventObservable, currentTarget = handle.currentTarget;
        if (DomEventObservable.triggeredEvent === type) {
          return undefined;
        }
        domEventObservable = DomEventObservable.getDomEventObservable(currentTarget, type);
        if (domEventObservable) {
          event.currentTarget = currentTarget;
          event = new DomEventObject(event);
          return domEventObservable.notify(event);
        }
        return undefined;
      };
      handle.currentTarget = currentTarget;
    }
    if (!(domEventObservables = domEventObservablesHolder.observables)) {
      domEventObservables = domEventObservablesHolder.observables = {};
    }
    domEventObservable = domEventObservables[type];
    if (!domEventObservable) {
      domEventObservable = domEventObservables[type] = new DomEventObservable({
        type: type,
        currentTarget: currentTarget
      });
      domEventObservable.setup();
    }
    domEventObservable.on(cfg);
    currentTarget = null;
  }
  function removeInternal(currentTarget, type, cfg) {
    cfg = util.merge(cfg);
    var customEvent;
    type = fixType(cfg, type);
    var domEventObservablesHolder = DomEventObservable.getDomEventObservablesHolder(currentTarget), domEventObservables = (domEventObservablesHolder || {}).observables;
    if (!domEventObservablesHolder || !domEventObservables) {
      return;
    }
    if (!type) {
      for (type in domEventObservables) {
        domEventObservables[type].detach(cfg);
      }
      return;
    }
    customEvent = domEventObservables[type];
    if (customEvent) {
      customEvent.detach(cfg);
    }
  }
  var DomEvent = {
    on: function (targets, type, fn, context) {
      targets = Dom.query(targets);
      BaseUtils.batchForType(function (targets, type, fn, context) {
        var cfg = BaseUtils.normalizeParam(type, fn, context), i, t;
        type = cfg.type;
        for (i = targets.length - 1; i >= 0; i--) {
          t = targets[i];
          addInternal(t, type, cfg);
        }
      }, 1, targets, type, fn, context);
      return targets;
    },
    detach: function (targets, type, fn, context) {
      targets = Dom.query(targets);
      BaseUtils.batchForType(function (targets, singleType, fn, context) {
        var cfg = BaseUtils.normalizeParam(singleType, fn, context), i, j, elChildren, t;
        singleType = cfg.type;
        for (i = targets.length - 1; i >= 0; i--) {
          t = targets[i];
          removeInternal(t, singleType, cfg);
          if (cfg.deep && t.getElementsByTagName) {
            elChildren = t.getElementsByTagName('*');
            for (j = elChildren.length - 1; j >= 0; j--) {
              removeInternal(elChildren[j], singleType, cfg);
            }
          }
        }
      }, 1, targets, type, fn, context);
      return targets;
    },
    delegate: function (targets, eventType, filter, fn, context) {
      return DomEvent.on(targets, eventType, {
        fn: fn,
        context: context,
        filter: filter
      });
    },
    undelegate: function (targets, eventType, filter, fn, context) {
      return DomEvent.detach(targets, eventType, {
        fn: fn,
        context: context,
        filter: filter
      });
    },
    fire: function (targets, eventType, eventData, onlyHandlers) {
      var ret;
      if (eventType.isEventObject) {
        eventData = eventType;
        eventType = eventType.type;
      }
      eventData = eventData || {};
      eventData.synthetic = 1;
      BaseUtils.splitAndRun(eventType, function (eventType) {
        var r, i, target, domEventObservable;
        BaseUtils.fillGroupsForEvent(eventType, eventData);
        eventType = eventData.type;
        var s = Special[eventType];
        var originalType = eventType;
        if (s && s.typeFix) {
          originalType = s.typeFix;
        }
        targets = Dom.query(targets);
        for (i = targets.length - 1; i >= 0; i--) {
          target = targets[i];
          domEventObservable = DomEventObservable.getDomEventObservable(target, originalType);
          if (!onlyHandlers && !domEventObservable) {
            domEventObservable = new DomEventObservable({
              type: originalType,
              currentTarget: target
            });
          }
          if (domEventObservable) {
            r = domEventObservable.fire(eventData, onlyHandlers);
            if (ret !== false && r !== undefined) {
              ret = r;
            }
          }
        }
      });
      return ret;
    },
    fireHandler: function (targets, eventType, eventData) {
      return DomEvent.fire(targets, eventType, eventData, 1);
    },
    clone: function (src, dest) {
      var domEventObservablesHolder, domEventObservables;
      if (!(domEventObservablesHolder = DomEventObservable.getDomEventObservablesHolder(src))) {
        return;
      }
      var srcData = DomEventUtils.data(src);
      if (srcData && srcData === DomEventUtils.data(dest)) {
        DomEventUtils.removeData(dest);
      }
      domEventObservables = domEventObservablesHolder.observables;
      util.each(domEventObservables, function (customEvent, type) {
        util.each(customEvent.observers, function (observer) {
          addInternal(dest, type, observer.config);
        });
      });
    },
    getEventListeners: function (target, type) {
      var observables = (DomEventObservable.getDomEventObservablesHolder(target) || { observables: {} }).observables;
      return type ? observables[type] : observables;
    }
  };
  exports = DomEvent;
  return exports;
}();
eventDomBaseLibMainSpecialEvents = function (exports) {
  var DomEvent = eventDomBaseLibMainDomEvent;
  var Special = eventDomBaseLibMainSpecial;
  var util = utilBase;
  var MOUSE_WHEEL = 'onmousewheel' in document.documentElement ? 'mousewheel' : 'DOMMouseScroll';
  exports = util.mix(Special, {
    mousewheel: { typeFix: MOUSE_WHEEL },
    load: { bubbles: false },
    click: {
      fire: function (onlyHandlers) {
        var self = this;
        if (!onlyHandlers && String(self.type) === 'checkbox' && self.click && self.nodeName.toLowerCase() === 'input') {
          self.click();
          return false;
        }
        return undefined;
      }
    },
    focus: {
      bubbles: false,
      preFire: function (event, onlyHandlers) {
        if (!onlyHandlers) {
          return DomEvent.fire(this, 'focusin');
        }
      },
      fire: function (onlyHandlers) {
        var self = this;
        if (!onlyHandlers && self.ownerDocument) {
          if (self !== self.ownerDocument.activeElement && self.focus) {
            self.focus();
            return false;
          }
        }
        return undefined;
      }
    },
    blur: {
      bubbles: false,
      preFire: function (event, onlyHandlers) {
        if (!onlyHandlers) {
          return DomEvent.fire(this, 'focusout');
        }
      },
      fire: function (onlyHandlers) {
        var self = this;
        if (!onlyHandlers && self.ownerDocument) {
          if (self === self.ownerDocument.activeElement && self.blur) {
            self.blur();
            return false;
          }
        }
        return undefined;
      }
    }
  });
  return exports;
}();
eventDomBaseLibMain = function (exports) {
  var util = utilBase;
  var DomEvent = eventDomBaseLibMainDomEvent;
  var DomEventObject = eventDomBaseLibMainObject;
  var Observable = eventDomBaseLibMainObservable;
  var Special = eventDomBaseLibMainSpecialEvents;
  var Utils = eventDomBaseLibMainUtils;
  exports = util.merge({
    add: DomEvent.on,
    remove: DomEvent.detach,
    off: DomEvent.detach,
    trigger: DomEvent.fire,
    triggerHandler: DomEvent.fireHandler,
    Observable: Observable,
    Special: Special,
    Object: DomEventObject,
    Utils: Utils
  }, DomEvent);
  return exports;
}();
eventDomBaseIndex = function (exports) {
  exports = eventDomBaseLibMain;
  return exports;
}();
return eventDomBaseIndex;
});define("event-dom-extra", ["event-dom-base",'util',"ua",'util','dom',"feature",'dom'], function(require) {
var eventDomBase = require("event-dom-base");
var utilBase = require('util');
var _ua_ = require("ua");
var utilExtra = require('util');
var domBase = require('dom');
var _feature_ = require("feature");
var domExtra = require('dom');
//! Copyright 2015, event-dom-extra@6.1.2 MIT Licensed, build time: Thu, 29 Oct 2015 09:48:21 GMT 
/*
combined modules:
event-dom-extra
event-dom-extra/lib/extra
event-dom-extra/lib/extra/api
event-dom-extra/lib/extra/key-codes
event-dom-extra/lib/extra/focusin
event-dom-extra/lib/extra/hashchange
event-dom-extra/lib/extra/input
event-dom-extra/lib/extra/mouseenter
*/
var eventDomExtraLibExtraKeyCodes, eventDomExtraLibExtraApi, eventDomExtraLibExtraFocusin, eventDomExtraLibExtraHashchange, eventDomExtraLibExtraInput, eventDomExtraLibExtraMouseenter, eventDomExtraLibExtra, eventDomExtraIndex;
eventDomExtraLibExtraKeyCodes = function (exports) {
  /**
   * @ignore
   * some key-codes definition and utils from closure-library
   * @author yiminghe@gmail.com
   */
  var
  /**
   * @enum {Number} Event.DomEvent.KeyCode
   * @alias Event.KeyCode
   * All key codes.
   */
  KeyCode = {
    /**
     * MAC_ENTER
     */
    MAC_ENTER: 3,
    /**
     * BACKSPACE
     */
    BACKSPACE: 8,
    /**
     * TAB
     */
    TAB: 9,
    /**
     * NUMLOCK on FF/Safari Mac
     */
    NUM_CENTER: 12,
    // NUMLOCK on FF/Safari Mac
    /**
     * ENTER
     */
    ENTER: 13,
    /**
     * SHIFT
     */
    SHIFT: 16,
    /**
     * CTRL
     */
    CTRL: 17,
    /**
     * ALT
     */
    ALT: 18,
    /**
     * PAUSE
     */
    PAUSE: 19,
    /**
     * CAPS_LOCK
     */
    CAPS_LOCK: 20,
    /**
     * ESC
     */
    ESC: 27,
    /**
     * SPACE
     */
    SPACE: 32,
    /**
     * PAGE_UP
     */
    PAGE_UP: 33,
    // also NUM_NORTH_EAST
    /**
     * PAGE_DOWN
     */
    PAGE_DOWN: 34,
    // also NUM_SOUTH_EAST
    /**
     * END
     */
    END: 35,
    // also NUM_SOUTH_WEST
    /**
     * HOME
     */
    HOME: 36,
    // also NUM_NORTH_WEST
    /**
     * LEFT
     */
    LEFT: 37,
    // also NUM_WEST
    /**
     * UP
     */
    UP: 38,
    // also NUM_NORTH
    /**
     * RIGHT
     */
    RIGHT: 39,
    // also NUM_EAST
    /**
     * DOWN
     */
    DOWN: 40,
    // also NUM_SOUTH
    /**
     * PRINT_SCREEN
     */
    PRINT_SCREEN: 44,
    /**
     * INSERT
     */
    INSERT: 45,
    // also NUM_INSERT
    /**
     * DELETE
     */
    DELETE: 46,
    // also NUM_DELETE
    /**
     * ZERO
     */
    ZERO: 48,
    /**
     * ONE
     */
    ONE: 49,
    /**
     * TWO
     */
    TWO: 50,
    /**
     * THREE
     */
    THREE: 51,
    /**
     * FOUR
     */
    FOUR: 52,
    /**
     * FIVE
     */
    FIVE: 53,
    /**
     * SIX
     */
    SIX: 54,
    /**
     * SEVEN
     */
    SEVEN: 55,
    /**
     * EIGHT
     */
    EIGHT: 56,
    /**
     * NINE
     */
    NINE: 57,
    /**
     * QUESTION_MARK
     */
    QUESTION_MARK: 63,
    // needs localization
    /**
     * A
     */
    A: 65,
    /**
     * B
     */
    B: 66,
    /**
     * C
     */
    C: 67,
    /**
     * D
     */
    D: 68,
    /**
     * E
     */
    E: 69,
    /**
     * F
     */
    F: 70,
    /**
     * G
     */
    G: 71,
    /**
     * H
     */
    H: 72,
    /**
     * I
     */
    I: 73,
    /**
     * J
     */
    J: 74,
    /**
     * K
     */
    K: 75,
    /**
     * L
     */
    L: 76,
    /**
     * M
     */
    M: 77,
    /**
     * N
     */
    N: 78,
    /**
     * O
     */
    O: 79,
    /**
     * P
     */
    P: 80,
    /**
     * Q
     */
    Q: 81,
    /**
     * R
     */
    R: 82,
    /**
     * S
     */
    S: 83,
    /**
     * T
     */
    T: 84,
    /**
     * U
     */
    U: 85,
    /**
     * V
     */
    V: 86,
    /**
     * W
     */
    W: 87,
    /**
     * X
     */
    X: 88,
    /**
     * Y
     */
    Y: 89,
    /**
     * Z
     */
    Z: 90,
    /**
     * META
     */
    META: 91,
    // WIN_KEY_LEFT
    /**
     * WIN_KEY_RIGHT
     */
    WIN_KEY_RIGHT: 92,
    /**
     * CONTEXT_MENU
     */
    CONTEXT_MENU: 93,
    /**
     * NUM_ZERO
     */
    NUM_ZERO: 96,
    /**
     * NUM_ONE
     */
    NUM_ONE: 97,
    /**
     * NUM_TWO
     */
    NUM_TWO: 98,
    /**
     * NUM_THREE
     */
    NUM_THREE: 99,
    /**
     * NUM_FOUR
     */
    NUM_FOUR: 100,
    /**
     * NUM_FIVE
     */
    NUM_FIVE: 101,
    /**
     * NUM_SIX
     */
    NUM_SIX: 102,
    /**
     * NUM_SEVEN
     */
    NUM_SEVEN: 103,
    /**
     * NUM_EIGHT
     */
    NUM_EIGHT: 104,
    /**
     * NUM_NINE
     */
    NUM_NINE: 105,
    /**
     * NUM_MULTIPLY
     */
    NUM_MULTIPLY: 106,
    /**
     * NUM_PLUS
     */
    NUM_PLUS: 107,
    /**
     * NUM_MINUS
     */
    NUM_MINUS: 109,
    /**
     * NUM_PERIOD
     */
    NUM_PERIOD: 110,
    /**
     * NUM_DIVISION
     */
    NUM_DIVISION: 111,
    /**
     * F1
     */
    F1: 112,
    /**
     * F2
     */
    F2: 113,
    /**
     * F3
     */
    F3: 114,
    /**
     * F4
     */
    F4: 115,
    /**
     * F5
     */
    F5: 116,
    /**
     * F6
     */
    F6: 117,
    /**
     * F7
     */
    F7: 118,
    /**
     * F8
     */
    F8: 119,
    /**
     * F9
     */
    F9: 120,
    /**
     * F10
     */
    F10: 121,
    /**
     * F11
     */
    F11: 122,
    /**
     * F12
     */
    F12: 123,
    /**
     * NUMLOCK
     */
    NUMLOCK: 144,
    /**
     * SEMICOLON
     */
    SEMICOLON: 186,
    // needs localization
    /**
     * DASH
     */
    DASH: 189,
    // needs localization
    /**
     * EQUALS
     */
    EQUALS: 187,
    // needs localization
    /**
     * COMMA
     */
    COMMA: 188,
    // needs localization
    /**
     * PERIOD
     */
    PERIOD: 190,
    // needs localization
    /**
     * SLASH
     */
    SLASH: 191,
    // needs localization
    /**
     * APOSTROPHE
     */
    APOSTROPHE: 192,
    // needs localization
    /**
     * SINGLE_QUOTE
     */
    SINGLE_QUOTE: 222,
    // needs localization
    /**
     * OPEN_SQUARE_BRACKET
     */
    OPEN_SQUARE_BRACKET: 219,
    // needs localization
    /**
     * BACKSLASH
     */
    BACKSLASH: 220,
    // needs localization
    /**
     * CLOSE_SQUARE_BRACKET
     */
    CLOSE_SQUARE_BRACKET: 221,
    // needs localization
    /**
     * WIN_KEY
     */
    WIN_KEY: 224,
    /**
     * MAC_FF_META
     */
    MAC_FF_META: 224,
    // Firefox (Gecko) fires this for the meta key instead of 91
    /**
     * WIN_IME
     */
    WIN_IME: 229
  };
  /*
   whether text and modified key is entered at the same time.
   */
  KeyCode.isTextModifyingKeyEvent = function (e) {
    var keyCode = e.keyCode;
    if (e.altKey && !e.ctrlKey || e.metaKey || // Function keys don't generate text
      keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    }
    // The following keys are quite harmless, even in combination with
    // CTRL, ALT or SHIFT.
    switch (keyCode) {
    case KeyCode.ALT:
    case KeyCode.CAPS_LOCK:
    case KeyCode.CONTEXT_MENU:
    case KeyCode.CTRL:
    case KeyCode.DOWN:
    case KeyCode.END:
    case KeyCode.ESC:
    case KeyCode.HOME:
    case KeyCode.INSERT:
    case KeyCode.LEFT:
    case KeyCode.MAC_FF_META:
    case KeyCode.META:
    case KeyCode.NUMLOCK:
    case KeyCode.NUM_CENTER:
    case KeyCode.PAGE_DOWN:
    case KeyCode.PAGE_UP:
    case KeyCode.PAUSE:
    case KeyCode.PRINT_SCREEN:
    case KeyCode.RIGHT:
    case KeyCode.SHIFT:
    case KeyCode.UP:
    case KeyCode.WIN_KEY:
    case KeyCode.WIN_KEY_RIGHT:
      return false;
    default:
      return true;
    }
  };
  /*
   whether character is entered.
   */
  KeyCode.isCharacterKey = function (keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }
    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }
    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    }
    // Safari sends zero key code for non-latin characters.
    if (window.navigation.userAgent.indexOf('WebKit') !== -1 && keyCode === 0) {
      return true;
    }
    switch (keyCode) {
    case KeyCode.SPACE:
    case KeyCode.QUESTION_MARK:
    case KeyCode.NUM_PLUS:
    case KeyCode.NUM_MINUS:
    case KeyCode.NUM_PERIOD:
    case KeyCode.NUM_DIVISION:
    case KeyCode.SEMICOLON:
    case KeyCode.DASH:
    case KeyCode.EQUALS:
    case KeyCode.COMMA:
    case KeyCode.PERIOD:
    case KeyCode.SLASH:
    case KeyCode.APOSTROPHE:
    case KeyCode.SINGLE_QUOTE:
    case KeyCode.OPEN_SQUARE_BRACKET:
    case KeyCode.BACKSLASH:
    case KeyCode.CLOSE_SQUARE_BRACKET:
      return true;
    default:
      return false;
    }
  };
  exports = KeyCode;
  return exports;
}();
eventDomExtraLibExtraApi = function (exports) {
  var EventDom = eventDomBase;
  var KeyCode = eventDomExtraLibExtraKeyCodes;
  EventDom.KeyCode = KeyCode;
  exports = EventDom;
  return exports;
}();
eventDomExtraLibExtraFocusin = function (exports) {
  /**
   * @ignore
   * event-focusin
   * @author yiminghe@gmail.com
   */
  var DomEvent = eventDomExtraLibExtraApi;
  var Special = DomEvent.Special;
  var util = utilBase;
  var ua = _ua_;
  // 让非 IE 浏览器支持 focusin/focusout
  if (!ua.ie) {
    util.each([
      {
        name: 'focusin',
        fix: 'focus'
      },
      {
        name: 'focusout',
        fix: 'blur'
      }
    ], function (o) {
      var key = util.guid('attaches_' + util.now() + '_');
      Special[o.name] = {
        // 统一在 document 上 capture focus/blur 事件，然后模拟冒泡 fire 出来
        // 达到和 focusin 一样的效果 focusin -> focus
        // refer: http://yiminghe.iteye.com/blog/813255
        setup: function () {
          // this maybe document
          var doc = this.ownerDocument || this;
          if (!(key in doc)) {
            doc[key] = 0;
          }
          doc[key] += 1;
          if (doc[key] === 1) {
            doc.addEventListener(o.fix, handler, true);
          }
        },
        tearDown: function () {
          var doc = this.ownerDocument || this;
          doc[key] -= 1;
          if (doc[key] === 0) {
            doc.removeEventListener(o.fix, handler, true);
          }
        }
      };
      function handler(event) {
        var target = event.target;
        return DomEvent.fire(target, o.name);
      }
    });
  }
  return exports;
}();
eventDomExtraLibExtraHashchange = function (exports) {
  /**
   * @ignore
   * hashchange event for non-standard browser
   * @author yiminghe@gmail.com, xiaomacji@gmail.com
   */
  var util = utilExtra;
  var DomEvent = eventDomExtraLibExtraApi;
  var Dom = domBase;
  var UA = _ua_;
  var feature = _feature_;
  var hashChange, iframe, urlWithoutHash, Special = DomEvent.Special, win = window,
    // 用于定时器检测，上次定时器记录的 hash 值
    lastHash, doc = win.document, REPLACE_HISTORY = '__ks_replace_history__', ie = UA.ieMode, HASH_CHANGE = 'hashchange';
  if (!feature.isHashChangeSupported()) {
    var POLL_INTERVAL = 50, IFRAME_TEMPLATE = '<html><head><title>' + (doc && doc.title || '') + ' - {hash}</title>{head}</head><body>{hash}</body></html>';
    DomEvent.REPLACE_HISTORY = REPLACE_HISTORY;
    var getHash = function () {
      // 不能 location.hash
      // 1.
      // http://xx.com/#yy?z=1
      // ie6 => location.hash = #yy
      // 其他浏览器 => location.hash = #yy?z=1
      // 2.
      // #!/home/q={%22thedate%22:%2220121010~20121010%22}
      // firefox 15 => #!/home/q={'thedate':'20121010~20121010'}
      // !! :(
      var m = location.href.match(/#.+$/);
      return m && m[0] || '#';
    };
    var notifyHashChange = function () {
      // S.log('hash changed : ' + getHash());
      // does not need bubbling
      DomEvent.fireHandler(win, HASH_CHANGE, {
        newURL: location.href,
        oldURL: urlWithoutHash + lastHash
      });
      lastHash = getHash();
    };
    // 1. 不支持 hashchange 事件，支持 hash 历史导航(opera??)：定时器监控
    // 2. 不支持 hashchange 事件，不支持 hash 历史导航(ie67) : iframe + 定时器
    var getIframeDoc = function (iframe) {
      return iframe.contentWindow.document;
    };
    hashChange = ie && ie < 8 ? function (hash, replaceHistory) {
      // S.log('set iframe html :' + hash);
      var html = util.substitute(IFRAME_TEMPLATE, {
          // 防止 hash 里有代码造成 xss
          // 后面通过 innerText，相当于 unEscapeHtml
          hash: util.escapeHtml(hash),
          // 一定要加哦
          head: Dom.isCustomDomain() ? '<script>' + 'document.' + 'domain = "' + doc.domain + '";</script>' : ''
        }), iframeDoc = getIframeDoc(iframe);
      try {
        // ie 下不留历史记录！
        if (replaceHistory) {
          iframeDoc.open('text/html', 'replace');
        } else {
          // 写入历史 hash
          iframeDoc.open();
        }
        // 取时要用 innerText !!
        // 否则取 innerHTML 会因为 escapeHtml 导置 body.innerHTMl != hash
        iframeDoc.write(html);
        iframeDoc.close();
      } catch (e) {
      }
    } : function () {
      notifyHashChange();
    };
    var timer, poll = function () {
        var hash = getHash(), replaceHistory = 0;
        if (hash.indexOf(REPLACE_HISTORY) !== -1) {
          replaceHistory = 1;
          hash = hash.replace(REPLACE_HISTORY, '');
          // 去除 ie67 hack 标记
          location.hash = hash;
        }
        if (hash !== lastHash) {
          // S.log('poll success :' + hash + ' :' + lastHash);
          // 通知完调用者 hashchange 事件前设置 lastHash
          // ie<8 同步 : hashChange -> onIframeLoad
          hashChange(hash, replaceHistory);
        }
        timer = setTimeout(poll, POLL_INTERVAL);
      }, setup = function () {
        if (!timer) {
          poll();
        }
      }, tearDown = function () {
        if (timer) {
          clearTimeout(timer);
        }
        timer = 0;
      };
    // ie6, 7, 覆盖一些function
    if (ie && ie < 8) {
      /*
       前进后退 : start -> notifyHashChange
       直接输入 : poll -> hashChange -> start
       iframe 内容和 url 同步
       */
      setup = function () {
        if (!iframe) {
          var iframeSrc = Dom.getEmptyIframeSrc();
          //http://www.paciellogroup.com/blog/?p=604
          iframe = Dom.create('<iframe ' + (iframeSrc ? 'src="' + iframeSrc + '"' : '') + ' style="display: none" ' + 'height="0" ' + 'width="0" ' + 'tabindex="-1" ' + 'title="empty"/>');
          // Append the iframe to the documentElement rather than the body.
          // Keeping it outside the body prevents scrolling on the initial
          // page load
          Dom.prepend(iframe, doc.documentElement);
          // init，第一次触发，以后都是 onIframeLoad
          DomEvent.add(iframe, 'load', function () {
            DomEvent.remove(iframe, 'load');
            // Update the iframe with the initial location hash, if any. This
            // will create an initial history entry that the user can return to
            // after the state has changed.
            hashChange(getHash());
            DomEvent.add(iframe, 'load', onIframeLoad);
            poll();
          });
          // Whenever `document.title` changes, update the Iframe's title to
          // prettify the back/next history menu entries. Since IE sometimes
          // errors with 'Unspecified error' the very first time this is set
          // (yes, very useful) wrap this with a try/catch block.
          doc.attachEvent('propertychange', function (e) {
            e = e || window.event;
            try {
              if (e.propertyName === 'title') {
                getIframeDoc(iframe).title = doc.title + ' - ' + getHash();
              }
            } catch (e) {
            }
          });
          /*
           前进后退 ： onIframeLoad -> 触发
           直接输入 : timer -> hashChange -> onIframeLoad -> 触发
           触发统一在 start(load)
           iframe 内容和 url 同步
           */
          var onIframeLoad = function () {
            // S.log('iframe start load..');
            // 2011.11.02 note: 不能用 innerHTML 会自动转义！！
            // #/x?z=1&y=2 => #/x?z=1&amp;y=2
            // 后退时不等
            // 定时器调用 hashChange() 修改 iframe 同步调用过来的(手动改变 location)则相等
            // S.log('set loc hash :' + c);
            location.hash = util.trim(getIframeDoc(iframe).body.innerText);
            // 使 last hash 为 iframe 历史， 不然重新写iframe，
            // 会导致最新状态（丢失前进状态）
            // 后退则立即触发 hashchange，
            // 并更新定时器记录的上个 hash 值
            notifyHashChange();
          };
        }
      };
      tearDown = function () {
        if (timer) {
          clearTimeout(timer);
        }
        timer = 0;
        DomEvent.detach(iframe);
        Dom.remove(iframe);
        iframe = 0;
      };
    }
    Special[HASH_CHANGE] = {
      setup: function () {
        if (this !== win) {
          return;
        }
        // 第一次启动 hashchange 时取一下，不能类库载入后立即取
        // 防止类库嵌入后，手动修改过 hash，
        lastHash = getHash();
        urlWithoutHash = location.href.replace(/#.+/, '');
        // 不用注册 dom 事件
        setup();
      },
      tearDown: function () {
        if (this !== win) {
          return;
        }
        tearDown();
      }
    };
  }
  return exports;
}();
eventDomExtraLibExtraInput = function (exports) {
  /**
   * @ignore
   * html input event polyfill
   * @author yiminghe@gmail.com
   */
  var DomEvent = eventDomExtraLibExtraApi;
  var Dom = domExtra;
  var noop = function () {
  };
  var Special = DomEvent.Special;
  function canFireInput(n) {
    var nodeName = (n.nodeName || '').toLowerCase();
    if (nodeName === 'textarea') {
      return true;
    } else if (nodeName === 'input') {
      return n.type === 'text' || n.type === 'password';
    }
    return false;
  }
  var INPUT_CHANGE = 'input', KEY = 'event-dom/input', HISTORY_KEY = KEY + '/history', POLL_KEY = KEY + '/poll', interval = 50;
  function clearPollTimer(target) {
    if (Dom.hasData(target, POLL_KEY)) {
      var poll = Dom.data(target, POLL_KEY);
      clearTimeout(poll);
      Dom.removeData(target, POLL_KEY);
    }
  }
  function stopPoll(target) {
    Dom.removeData(target, HISTORY_KEY);
    clearPollTimer(target);
  }
  function stopPollHandler(ev) {
    clearPollTimer(ev.target);
  }
  function checkChange(target) {
    var v = target.value, h = Dom.data(target, HISTORY_KEY);
    if (v !== h) {
      // allow delegate
      DomEvent.fire(target, INPUT_CHANGE);
      Dom.data(target, HISTORY_KEY, v);
    }
  }
  function startPoll(target) {
    if (Dom.hasData(target, POLL_KEY)) {
      return;
    }
    Dom.data(target, POLL_KEY, setTimeout(function check() {
      checkChange(target);
      Dom.data(target, POLL_KEY, setTimeout(check, interval));
    }, interval));
  }
  function startPollHandler(ev) {
    var target = ev.target;
    // when focus, record its current value immediately
    if (ev.type === 'focus') {
      Dom.data(target, HISTORY_KEY, target.value);
    }
    startPoll(target);
  }
  function monitor(target) {
    unmonitored(target);
    DomEvent.on(target, 'blur', stopPollHandler);
    DomEvent.on(target, 'mousedown keyup keydown focus', startPollHandler);
  }
  function unmonitored(target) {
    stopPoll(target);
    DomEvent.detach(target, 'blur', stopPollHandler);
    DomEvent.detach(target, 'mousedown keyup keydown focus', startPollHandler);
  }
  Special.input = {
    setup: function () {
      var self = this;
      if (canFireInput(self)) {
        monitor(self);
      } else {
        // if bind on parentNode, lazy bind event to its form elements
        DomEvent.on(self, 'focusin', beforeActivate);
      }
    },
    tearDown: function () {
      var self = this;
      if (canFireInput(self)) {
        unmonitored(self);
      } else {
        DomEvent.remove(self, 'focusin', beforeActivate);
        Dom.query('textarea,input', self).each(function (fel) {
          if (fel.__inputHandler) {
            fel.__inputHandler = 0;
            DomEvent.remove(fel, 'input', noop);
          }
        });
      }
    }
  };
  function beforeActivate(e) {
    var t = e.target;
    if (canFireInput(t) && !t.__inputHandler) {
      t.__inputHandler = 1;
      // start input monitor
      DomEvent.on(t, 'input', noop);
    }
  }
  return exports;
}();
eventDomExtraLibExtraMouseenter = function (exports) {
  /**
   * @ignore
   * event-mouseenter
   * @author yiminghe@gmail.com
   */
  var Dom = domBase;
  var DomEvent = eventDomExtraLibExtraApi;
  var util = utilBase;
  var Special = DomEvent.Special;
  util.each([
    {
      name: 'mouseenter',
      fix: 'mouseover'
    },
    {
      name: 'mouseleave',
      fix: 'mouseout'
    }
  ], function (o) {
    Special[o.name] = {
      // fix #75
      typeFix: o.fix,
      handle: function (event, observer, ce) {
        var currentTarget = event.currentTarget, relatedTarget = event.relatedTarget;
        // 在自身外边就触发
        // self === document,parent === null
        // relatedTarget 与 currentTarget 之间就是 mouseenter/leave
        if (!relatedTarget || relatedTarget !== currentTarget && !Dom.contains(currentTarget, relatedTarget)) {
          // http://msdn.microsoft.com/en-us/library/ms536945(v=vs.85).aspx
          // does not bubble
          // 2012-04-12 把 mouseover 阻止冒泡有问题！
          // <div id='0'><div id='1'><div id='2'><div id='3'></div></div></div></div>
          // 2 mouseover 停止冒泡
          // 然后快速 2,1 飞过，可能 1 的 mouseover 是 2 冒泡过来的
          // mouseover 采样时跳跃的，可能 2,1 的 mouseover 事件
          // target 都是 3,而 relatedTarget 都是 0
          // event.stopPropagation();
          return [observer.simpleNotify(event, ce)];
        }
      }
    };
  });
  return exports;
}();
eventDomExtraLibExtra = function (exports) {
  var EventDom = eventDomExtraLibExtraApi;
  eventDomExtraLibExtraFocusin;
  eventDomExtraLibExtraHashchange;
  eventDomExtraLibExtraInput;
  eventDomExtraLibExtraMouseenter;
  exports = EventDom;
  return exports;
}();
eventDomExtraIndex = function (exports) {
  exports = eventDomExtraLibExtra;
  return exports;
}();
return eventDomExtraIndex;
});define("event-gesture", ["event-dom-base",'util',"event-touch","feature"], function(require) {
var eventDomBase = require("event-dom-base");
var utilBase = require('util');
var eventTouch = require("event-touch");
var feature = require("feature");
//! Copyright 2015, event-gesture@6.1.1 MIT Licensed, build time: Thu, 29 Oct 2015 13:39:34 GMT 
/*
combined modules:
event-gesture
event-gesture/lib/edge-pan
event-gesture/lib/pan
event-gesture/lib/pinch
event-gesture/lib/rotate
event-gesture/lib/shake
*/
var eventGestureLibEdgePan, eventGestureLibPan, eventGestureLibPinch, eventGestureLibRotate, eventGestureLibShake, eventGestureIndex;
eventGestureLibEdgePan = function (exports) {
  /**
   * edge drag gesture
   * @author yiminghe@gmail.com
   */
  var GestureUtil = eventTouch._gestureUtil;
  var DomEvent = eventDomBase;
  var util = utilBase;
  var addGestureEvent = GestureUtil.addEvent;
  var SingleTouch = GestureUtil.SingleTouch;
  var EDGE_PAN_START = 'edgePanStart', EDGE_PAN = 'edgePan', EDGE_PAN_END = 'edgePanEnd', MIN_EDGE_DISTANCE = 60;
  function fire(self, e, move) {
    var touches = self.lastTouches, touch = touches[0], x = touch.pageX, y = touch.pageY, deltaX = x - self.startX, deltaY = y - self.startY, absDeltaX = Math.abs(deltaX), absDeltaY = Math.abs(deltaY), distance, event, direction = self.direction;
    if (!direction) {
      if (absDeltaX > absDeltaY) {
        direction = deltaX < 0 ? 'left' : 'right';
      } else {
        direction = deltaY < 0 ? 'up' : 'down';
      }
      self.direction = direction;
    }
    if (direction === 'up' || direction === 'down') {
      distance = absDeltaY;
    } else {
      distance = absDeltaX;
    }
    var velocityX, velocityY;
    var duration = e.timeStamp - self.startTime;
    if (!move) {
      event = EDGE_PAN_END;
      if (direction === 'left' || direction === 'right') {
        velocityX = distance / duration;
      } else {
        velocityY = distance / duration;
      }
    } else if (self.isStarted) {
      event = EDGE_PAN;
    } else {
      event = EDGE_PAN_START;
      var win = window;
      var invalidRegion = {
        left: win.pageXOffset + MIN_EDGE_DISTANCE,
        right: win.pageXOffset + win.innerWidth - MIN_EDGE_DISTANCE,
        top: win.pageYOffset + MIN_EDGE_DISTANCE,
        bottom: win.pageYOffset + win.innerHeight - MIN_EDGE_DISTANCE
      };
      if (direction === 'right' && x > invalidRegion.left) {
        return false;
      } else if (direction === 'left' && x < invalidRegion.right) {
        return false;
      } else if (direction === 'down' && y > invalidRegion.top) {
        return false;
      } else if (direction === 'up' && y < invalidRegion.bottom) {
        return false;
      }
      self.isStarted = 1;
      self.startTime = e.timeStamp;
    }
    /**
     * fired when edge drag started
     * @event EDGE_PAN_START
     * @member Event.Gesture.EdgeDrag
     * @param {Event.DomEvent.Object} e
     * @param {Number} e.pageX drag point pageX
     * @param {Number} e.pageY drag point pageY
     * @param {Number} e.distance distance between current touch and start touch
     * @param {Number} e.duration time duration between current touch and start touch
     * @param {Number} e.velocityX velocity at x-axis
     * @param {Number} e.velocityY velocity at y-axis
     * @param {String} e.direction drag start direction 'up' or 'down' or 'left' or 'right'
     */
    /**
     * fired when edge drag
     * @event EDGE_PAN
     * @member Event.Gesture.EdgeDrag
     * @param {Event.DomEvent.Object} e
     * @param {Number} e.pageX drag point pageX
     * @param {Number} e.pageY drag point pageY
     * @param {Number} e.distance distance between current touch and start touch
     * @param {Number} e.duration time duration between current touch and start touch
     * @param {Number} e.velocityX velocity at x-axis
     * @param {Number} e.velocityY velocity at y-axis
     * @param {String} e.direction drag start direction 'up' or 'down' or 'left' or 'right'
     */
    /**
     * fired when edge drag gesture is finished
     * @event EDGE_PAN_END
     * @member Event.Gesture.EdgeDrag
     * @param {Event.DomEvent.Object} e
     * @param {Number} e.pageX drag point pageX
     * @param {Number} e.pageY drag point pageY
     * @param {Number} e.distance distance between current touch and start touch
     * @param {Number} e.duration time duration between current touch and start touch
     * @param {Number} e.velocityX velocity at x-axis
     * @param {Number} e.velocityY velocity at y-axis
     * @param {String} e.direction drag start direction 'up' or 'down' or 'left' or 'right'
     */
    DomEvent.fire(touch.target, event, {
      originalEvent: e.originalEvent,
      pageX: touch.pageX,
      pageY: touch.pageY,
      which: 1,
      direction: direction,
      distance: distance,
      duration: duration / 1000,
      velocityX: velocityX,
      velocityY: velocityY
    });
    return undefined;
  }
  function EdgeDrag() {
  }
  util.extend(EdgeDrag, SingleTouch, {
    requiredGestureType: 'touch',
    start: function () {
      var self = this;
      EdgeDrag.superclass.start.apply(self, arguments);
      var touch = self.lastTouches[0];
      self.direction = null;
      self.startX = touch.pageX;
      self.startY = touch.pageY;
    },
    move: function (e) {
      EdgeDrag.superclass.move.apply(this, arguments);
      return fire(this, e, 1);
    },
    end: function (e) {
      EdgeDrag.superclass.end.apply(this, arguments);
      return fire(this, e, 0);
    }
  });
  addGestureEvent([
    EDGE_PAN,
    EDGE_PAN_END,
    EDGE_PAN_START
  ], { handle: new EdgeDrag() });
  exports = {
    EDGE_PAN: EDGE_PAN,
    EDGE_PAN_START: EDGE_PAN_START,
    EDGE_PAN_END: EDGE_PAN_END
  };
  return exports;
}();
eventGestureLibPan = function (exports) {
  var GestureUtil = eventTouch._gestureUtil;
  var DomEvent = eventDomBase;
  var util = utilBase;
  var addGestureEvent = GestureUtil.addEvent;
  var SingleTouch = GestureUtil.SingleTouch;
  var PAN_START = 'panStart', PAN_END = 'panEnd', PAN = 'pan', SAMPLE_INTERVAL = 300, MIN_DISTANCE = 3;
  var doc = document;
  function getDistance(p1, p2) {
    var deltaX = p1.pageX - p2.pageX, deltaY = p1.pageY - p2.pageY;
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  }
  function startDrag(self, e) {
    var currentTouch = self.lastTouches[0];
    var startPos = self.startPos;
    if (!self.direction) {
      var deltaX = e.pageX - self.startPos.pageX, deltaY = e.pageY - self.startPos.pageY, absDeltaX = Math.abs(deltaX), absDeltaY = Math.abs(deltaY);
      if (absDeltaX > absDeltaY) {
        self.direction = deltaX < 0 ? 'left' : 'right';
      } else {
        self.direction = deltaY < 0 ? 'up' : 'down';
      }
    }
    if (getDistance(currentTouch, startPos) > MIN_DISTANCE) {
      if (self.isStarted) {
        sample(self, e);
      } else {
        if (doc.body.setCapture) {
          doc.body.setCapture();
        }
        self.isStarted = true;
      }
      DomEvent.fire(self.dragTarget, PAN_START, getEventObject(self, e));
    } else {
    }
  }
  function sample(self, e) {
    var currentTouch = self.lastTouches[0];
    var currentTime = e.timeStamp;
    if (currentTime - self.lastTime > SAMPLE_INTERVAL) {
      self.lastPos = {
        pageX: currentTouch.pageX,
        pageY: currentTouch.pageY
      };
      self.lastTime = currentTime;
    }
  }
  function getEventObject(self, e, ret) {
    var startPos = self.startPos;
    ret = ret || {};
    var currentTouch = self.lastTouches[0];
    ret.which = 1;
    ret.pageX = currentTouch.pageX;
    ret.pageY = currentTouch.pageY;
    ret.originalEvent = e.originalEvent;
    ret.deltaX = currentTouch.pageX - startPos.pageX;
    ret.deltaY = currentTouch.pageY - startPos.pageY;
    ret.startTime = self.startTime;
    ret.startPos = self.startPos;
    ret.gestureType = e.gestureType;
    ret.direction = self.direction;
    return ret;
  }
  function Drag() {
  }
  util.extend(Drag, SingleTouch, {
    start: function () {
      var self = this;
      Drag.superclass.start.apply(self, arguments);
      var touch = self.lastTouches[0];
      self.lastTime = self.startTime;
      self.dragTarget = touch.target;
      self.startPos = self.lastPos = {
        pageX: touch.pageX,
        pageY: touch.pageY
      };
      self.direction = null;
    },
    move: function (e) {
      var self = this;
      Drag.superclass.move.apply(self, arguments);
      if (!self.isStarted) {
        startDrag(self, e);
      } else {
        sample(self, e);
        DomEvent.fire(self.dragTarget, PAN, getEventObject(self, e));
      }
    },
    end: function (e) {
      var self = this;
      var currentTouch = self.lastTouches[0];
      var currentTime = e.timeStamp;
      var velocityX = (currentTouch.pageX - self.lastPos.pageX) / (currentTime - self.lastTime);
      var velocityY = (currentTouch.pageY - self.lastPos.pageY) / (currentTime - self.lastTime);
      DomEvent.fire(self.dragTarget, PAN_END, getEventObject(self, e, {
        velocityX: velocityX || 0,
        velocityY: velocityY || 0
      }));
      if (doc.body.releaseCapture) {
        doc.body.releaseCapture();
      }
    }
  });
  addGestureEvent([
    PAN_START,
    PAN,
    PAN_END
  ], { handle: new Drag() });
  exports = {
    PAN_START: PAN_START,
    PAN: PAN,
    PAN_END: PAN_END
  };
  return exports;
}();
eventGestureLibPinch = function (exports) {
  var GestureUtil = eventTouch._gestureUtil;
  var DomEvent = eventDomBase;
  var Feature = feature;
  var util = utilBase;
  var DoubleTouch = GestureUtil.DoubleTouch;
  var addGestureEvent = GestureUtil.addEvent;
  var PINCH = 'pinch', PINCH_START = 'pinchStart', PINCH_END = 'pinchEnd';
  function getDistance(p1, p2) {
    var deltaX = p1.pageX - p2.pageX, deltaY = p1.pageY - p2.pageY;
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
  }
  function Pinch() {
  }
  util.extend(Pinch, DoubleTouch, {
    requiredGestureType: 'touch',
    move: function (e) {
      var self = this;
      Pinch.superclass.move.apply(self, arguments);
      var touches = self.lastTouches;
      if (!(touches[0].pageX > 0 && touches[0].pageY > 0 && touches[1].pageX > 0 && touches[1].pageY > 0)) {
        return;
      }
      var distance = getDistance(touches[0], touches[1]);
      if (!self.isStarted) {
        self.isStarted = true;
        self.startDistance = distance;
        var target = self.target = self.getCommonTarget(e);
        DomEvent.fire(target, PINCH_START, util.mix(e, {
          distance: distance,
          scale: 1
        }));
      } else {
        DomEvent.fire(self.target, PINCH, util.mix(e, {
          distance: distance,
          scale: distance / self.startDistance
        }));
      }
    },
    end: function (e) {
      var self = this;
      Pinch.superclass.end.apply(self, arguments);
      DomEvent.fire(self.target, PINCH_END, util.mix(e, { touches: self.lastTouches }));
    }
  });
  var p = new Pinch();
  addGestureEvent([
    PINCH_START,
    PINCH_END
  ], { handle: p });
  function prevent(e) {
    if (e.targetTouches.length === 2) {
      e.preventDefault();
    }
  }
  var config = { handle: p };
  if (Feature.isTouchEventSupported()) {
    config.setup = function () {
      this.addEventListener('touchmove', prevent, false);
    };
    config.tearDown = function () {
      this.removeEventListener('touchmove', prevent, false);
    };
  }
  addGestureEvent(PINCH, config);
  exports = {
    PINCH: PINCH,
    PINCH_START: PINCH_START,
    PINCH_END: PINCH_END
  };
  return exports;
}();
eventGestureLibRotate = function (exports) {
  var GestureUtil = eventTouch._gestureUtil;
  var DomEvent = eventDomBase;
  var util = utilBase;
  var Feature = feature;
  var DoubleTouch = GestureUtil.DoubleTouch;
  var addGestureEvent = GestureUtil.addEvent;
  var ROTATE_START = 'rotateStart', ROTATE = 'rotate', RAD_2_DEG = 180 / Math.PI, ROTATE_END = 'rotateEnd';
  function Rotate() {
  }
  util.extend(Rotate, DoubleTouch, {
    requiredGestureType: 'touch',
    move: function (e) {
      var self = this;
      Rotate.superclass.move.apply(self, arguments);
      var touches = self.lastTouches, one = touches[0], two = touches[1], lastAngle = self.lastAngle, angle = Math.atan2(two.pageY - one.pageY, two.pageX - one.pageX) * RAD_2_DEG;
      if (lastAngle !== undefined) {
        var diff = Math.abs(angle - lastAngle);
        var positiveAngle = (angle + 360) % 360;
        var negativeAngle = (angle - 360) % 360;
        if (Math.abs(positiveAngle - lastAngle) < diff) {
          angle = positiveAngle;
        } else if (Math.abs(negativeAngle - lastAngle) < diff) {
          angle = negativeAngle;
        }
      }
      self.lastAngle = angle;
      if (!self.isStarted) {
        self.isStarted = true;
        self.startAngle = angle;
        self.target = self.getCommonTarget(e);
        DomEvent.fire(self.target, ROTATE_START, util.mix(e, {
          angle: angle,
          rotation: 0
        }));
      } else {
        DomEvent.fire(self.target, ROTATE, util.mix(e, {
          angle: angle,
          rotation: angle - self.startAngle
        }));
      }
    },
    end: function (e) {
      var self = this;
      Rotate.superclass.end.apply(self, arguments);
      self.lastAngle = undefined;
      DomEvent.fire(self.target, ROTATE_END, util.mix(e, { touches: self.lastTouches }));
    }
  });
  function prevent(e) {
    if (e.targetTouches.length === 2) {
      e.preventDefault();
    }
  }
  var r = new Rotate();
  addGestureEvent([
    ROTATE_END,
    ROTATE_START
  ], { handle: r });
  var config = { handle: r };
  if (Feature.isTouchEventSupported()) {
    config.setup = function () {
      this.addEventListener('touchmove', prevent, false);
    };
    config.tearDown = function () {
      this.removeEventListener('touchmove', prevent, false);
    };
  }
  addGestureEvent(ROTATE, config);
  exports = {
    ROTATE_START: ROTATE_START,
    ROTATE: ROTATE,
    ROTATE_END: ROTATE_END
  };
  return exports;
}();
eventGestureLibShake = function (exports) {
  var DomEvent = eventDomBase;
  var util = utilBase;
  var Special = DomEvent.Special, start = 5, enough = 20, shaking = 0, SHAKE = 'shake', lastX, lastY, lastZ, max = Math.max, abs = Math.abs, win = window, devicemotion = 'devicemotion', checkShake = util.buffer(function () {
      if (shaking) {
        DomEvent.fireHandler(win, SHAKE, {
          accelerationIncludingGravity: {
            x: lastX,
            y: lastY,
            z: lastZ
          }
        });
        clear();
      }
    }, 250);
  Special.shake = {
    setup: function () {
      if (this !== win) {
        return;
      }
      win.addEventListener(devicemotion, shake, false);
    },
    tearDown: function () {
      if (this !== win) {
        return;
      }
      checkShake.stop();
      clear();
      win.removeEventListener(devicemotion, shake, false);
    }
  };
  function clear() {
    lastX = undefined;
    shaking = 0;
  }
  function shake(e) {
    var accelerationIncludingGravity = e.accelerationIncludingGravity, x = accelerationIncludingGravity.x, y = accelerationIncludingGravity.y, z = accelerationIncludingGravity.z, diff;
    if (lastX !== undefined) {
      diff = max(abs(x - lastX), abs(y - lastY), abs(z - lastZ));
      if (diff > start) {
        checkShake();
      }
      if (diff > enough) {
        shaking = 1;
      }
    }
    lastX = x;
    lastY = y;
    lastZ = z;
  }
  exports = { SHAKE: SHAKE };
  return exports;
}();
eventGestureIndex = function (exports) {
  var util = utilBase;
  var domEvent = eventDomBase;
  var TouchEvent = eventTouch;
  var EdgePanGestureEvent = eventGestureLibEdgePan;
  var PanGestureEvent = eventGestureLibPan;
  var PinchGestureEvent = eventGestureLibPinch;
  var RotateGestureEvent = eventGestureLibRotate;
  var ShakeGestureEvent = eventGestureLibShake;
  var GestureEvent = {
    EdgePanGestureEvent: EdgePanGestureEvent,
    PanGestureEvent: PanGestureEvent,
    PinchGestureEvent: PinchGestureEvent,
    RotateGestureEvent: RotateGestureEvent,
    ShakeGestureEvent: ShakeGestureEvent
  };
  util.mix(GestureEvent, TouchEvent);
  util.mix(domEvent, GestureEvent);
  exports = GestureEvent;
  return exports;
}();
return eventGestureIndex;
});define("event-touch", ['util','dom',"event-dom-base","feature"], function(require) {
var utilBase = require('util');
var domBase = require('dom');
var eventDomBase = require("event-dom-base");
var feature = require("feature");
//! Copyright 2015, event-touch@6.1.2 MIT Licensed, build time: Thu, 29 Oct 2015 13:40:08 GMT 
/*
combined modules:
event-touch
event-touch/lib/basic
event-touch/lib/util
event-touch/lib/util/add-event
event-touch/lib/util/touch
event-touch/lib/util/single-touch
event-touch/lib/util/double-touch
event-touch/lib/swipe
event-touch/lib/tap
*/
var eventTouchLibUtilAddEvent, eventTouchLibUtilTouch, eventTouchLibUtilSingleTouch, eventTouchLibUtilDoubleTouch, eventTouchLibUtil, eventTouchLibSwipe, eventTouchLibTap, eventTouchLibBasic, eventTouchIndex;
eventTouchLibUtilAddEvent = function (exports) {
  /**
   * @ignore
   * base handle for touch gesture, mouse and touch normalization
   * @author yiminghe@gmail.com
   */
  var util = utilBase;
  var Dom = domBase;
  var eventHandleMap = {};
  var DomEvent = eventDomBase;
  var Special = DomEvent.Special;
  var key = util.guid('touch-handle'), Feature = feature, gestureStartEvent, gestureMoveEvent, gestureEndEvent;
  var ios = /iPad|iPhone|iPod/.test(navigator.userAgent);
  function isTouchEvent(type) {
    return util.startsWith(type, 'touch');
  }
  function isMouseEvent(type) {
    return util.startsWith(type, 'mouse');
  }
  function isPointerEvent(type) {
    return util.startsWith(type, 'MSPointer') || util.startsWith(type, 'pointer');
  }
  // This should be long enough to ignore compatible mouse events made by touch
  var DUP_TIMEOUT = 2500;
  // radius around touchend that swallows mouse events
  var DUP_DIST = 25;
  if (Feature.isTouchEventSupported()) {
    if (ios) {
      // ios mousedown is buggy
      gestureEndEvent = 'touchend touchcancel';
      gestureStartEvent = 'touchstart';
      gestureMoveEvent = 'touchmove';
    } else {
      gestureEndEvent = 'touchend touchcancel mouseup';
      // allow touch and mouse both!
      gestureStartEvent = 'touchstart mousedown';
      gestureMoveEvent = 'touchmove mousemove';
    }
  } else if (Feature.isPointerSupported()) {
    // ie11 requires lowercase
    // https://github.com/kissyteam/kissy/issues/509
    gestureStartEvent = 'pointerdown';
    gestureMoveEvent = 'pointermove';
    gestureEndEvent = 'pointerup pointercancel';
  } else if (Feature.isMsPointerSupported()) {
    gestureStartEvent = 'MSPointerDown';
    gestureMoveEvent = 'MSPointerMove';
    gestureEndEvent = 'MSPointerUp MSPointerCancel';
  } else {
    gestureStartEvent = 'mousedown';
    gestureMoveEvent = 'mousemove';
    gestureEndEvent = 'mouseup';
  }
  function DocumentHandler(doc) {
    var self = this;
    self.doc = doc;
    self.eventHandles = [];
    self.init();
    // normalize pointer event to touch event
    self.touches = [];
    // touches length of touch event
    self.inTouch = 0;
  }
  DocumentHandler.prototype = {
    constructor: DocumentHandler,
    lastTouches: [],
    firstTouch: null,
    init: function () {
      var self = this, doc = self.doc;
      DomEvent.on(doc, gestureStartEvent, self.onTouchStart, self);
      // pointermove will be fired regardless of pointerdown
      if (!isPointerEvent(gestureMoveEvent)) {
        DomEvent.on(doc, gestureMoveEvent, self.onTouchMove, self);
      }
      DomEvent.on(doc, gestureEndEvent, self.onTouchEnd, self);
    },
    addTouch: function (originalEvent) {
      originalEvent.identifier = originalEvent.pointerId;
      this.touches.push(originalEvent);
    },
    removeTouch: function (originalEvent) {
      var i = 0, touch, pointerId = originalEvent.pointerId, touches = this.touches, l = touches.length;
      for (; i < l; i++) {
        touch = touches[i];
        if (touch.pointerId === pointerId) {
          touches.splice(i, 1);
          break;
        }
      }
    },
    updateTouch: function (originalEvent) {
      var i = 0, touch, pointerId = originalEvent.pointerId, touches = this.touches, l = touches.length;
      for (; i < l; i++) {
        touch = touches[i];
        if (touch.pointerId === pointerId) {
          touches[i] = originalEvent;
        }
      }
    },
    isPrimaryTouch: function (inTouch) {
      return this.firstTouch === inTouch.identifier;
    },
    setPrimaryTouch: function (inTouch) {
      if (this.firstTouch === null) {
        this.firstTouch = inTouch.identifier;
      }
    },
    removePrimaryTouch: function (inTouch) {
      if (this.isPrimaryTouch(inTouch)) {
        this.firstTouch = null;
      }
    },
    // prevent mouse events from creating pointer events
    dupMouse: function (inEvent) {
      var lts = this.lastTouches;
      var t = inEvent.changedTouches[0];
      // only the primary finger will dup mouse events
      if (this.isPrimaryTouch(t)) {
        // remember x/y of last touch
        var lt = {
          x: t.clientX,
          y: t.clientY
        };
        lts.push(lt);
        setTimeout(function () {
          var i = lts.indexOf(lt);
          if (i > -1) {
            lts.splice(i, 1);
          }
        }, DUP_TIMEOUT);
      }
    },
    // collide with the touch event
    isEventSimulatedFromTouch: function (inEvent) {
      var lts = this.lastTouches;
      var x = inEvent.clientX, y = inEvent.clientY;
      for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
        // simulated mouse events will be swallowed near a primary touchend
        var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
        if (dx <= DUP_DIST && dy <= DUP_DIST) {
          return true;
        }
      }
      return 0;
    },
    normalize: function (e) {
      var type = e.type, notUp, touchEvent, touchList;
      if (touchEvent = isTouchEvent(type)) {
        touchList = type === 'touchend' || type === 'touchcancel' ? e.changedTouches : e.touches;
        e.gestureType = 'touch';
      } else {
        if (isPointerEvent(type)) {
          e.gestureType = e.originalEvent.pointerType;
        } else if (isMouseEvent(type)) {
          e.gestureType = 'mouse';
        }
        touchList = this.touches;
      }
      if (touchList && touchList.length === 1) {
        e.which = 1;
        e.pageX = touchList[0].pageX;
        e.pageY = touchList[0].pageY;
      }
      if (touchEvent) {
        return e;
      }
      notUp = !type.match(/(up|cancel)$/i);
      e.touches = notUp ? touchList : [];
      e.targetTouches = notUp ? touchList : [];
      e.changedTouches = touchList;
      return e;
    },
    onTouchStart: function (event) {
      var e, h, self = this, type = event.type, eventHandles = self.eventHandles;
      if (isTouchEvent(type)) {
        self.setPrimaryTouch(event.changedTouches[0]);
        self.dupMouse(event);
      } else if (isMouseEvent(type)) {
        if (self.isEventSimulatedFromTouch(event)) {
          return;
        }
        self.touches = [event];
      } else if (isPointerEvent(type)) {
        self.addTouch(event.originalEvent);
        if (self.touches.length === 1) {
          DomEvent.on(self.doc, gestureMoveEvent, self.onTouchMove, self);
        }
      } else {
        throw new Error('unrecognized touch event: ' + event.type);
      }
      for (var i = 0, l = eventHandles.length; i < l; i++) {
        e = eventHandles[i];
        h = eventHandles[e].handle;
        h.isActive = 1;
      }
      // if preventDefault, will not trigger click event
      self.callEventHandle('onTouchStart', event);
    },
    onTouchMove: function (event) {
      var self = this, type = event.type;
      if (isMouseEvent(type)) {
        if (self.isEventSimulatedFromTouch(type)) {
          return;
        }
        self.touches = [event];
      } else if (isPointerEvent(type)) {
        self.updateTouch(event.originalEvent);
      } else if (!isTouchEvent(type)) {
        throw new Error('unrecognized touch event: ' + event.type);
      }
      // no throttle! to allow preventDefault
      self.callEventHandle('onTouchMove', event);
    },
    onTouchEnd: function (event) {
      var self = this, type = event.type;
      if (isMouseEvent(type)) {
        if (self.isEventSimulatedFromTouch(event)) {
          return;
        }
      }
      self.callEventHandle('onTouchEnd', event);
      if (isTouchEvent(type)) {
        self.dupMouse(event);
        util.makeArray(event.changedTouches).forEach(function (touch) {
          self.removePrimaryTouch(touch);
        });
      } else if (isMouseEvent(type)) {
        self.touches = [];
      } else if (isPointerEvent(type)) {
        self.removeTouch(event.originalEvent);
        if (!self.touches.length) {
          DomEvent.detach(self.doc, gestureMoveEvent, self.onTouchMove, self);
        }
      }
    },
    callEventHandle: function (method, event) {
      var self = this, eventHandles = self.eventHandles, handleArray = eventHandles.concat(), e, h;
      event = self.normalize(event);
      var gestureType = event.gestureType;
      // ie touchstart on iframe then touchend on parent
      if (!event.changedTouches.length) {
        return;
      }
      for (var i = 0, l = handleArray.length; i < l; i++) {
        e = handleArray[i];
        if (eventHandles[e]) {
          // event processor shared by multiple events
          h = eventHandles[e].handle;
          // touch only gesture
          if (h.requiredGestureType && gestureType !== h.requiredGestureType) {
            continue;
          }
          if (h.processed) {
            continue;
          }
          h.processed = 1;
          if (h.isActive && h[method] && h[method](event) === false) {
            h.isActive = 0;
          }
        }
      }
      for (i = 0, l = handleArray.length; i < l; i++) {
        e = eventHandles[i];
        if (eventHandles[e]) {
          h = eventHandles[e].handle;
          h.processed = 0;
        }
      }
    },
    addEventHandle: function (event) {
      var self = this, eventHandles = self.eventHandles, handle = eventHandleMap[event].handle;
      if (eventHandles[event]) {
        eventHandles[event].count++;
      } else {
        eventHandles.push(event);
        self.sortEventHandles();
        eventHandles[event] = {
          count: 1,
          handle: handle
        };
      }
    },
    sortEventHandles: function () {
      this.eventHandles.sort(function (e1, e2) {
        var e1Config = eventHandleMap[e1];
        var e2Config = eventHandleMap[e2];
        return e1Config.order - e2Config.order;
      });
    },
    removeEventHandle: function (event) {
      var eventHandles = this.eventHandles;
      if (eventHandles[event]) {
        eventHandles[event].count--;
        if (!eventHandles[event].count) {
          eventHandles.splice(util.indexOf(event, eventHandles), 1);
          delete eventHandles[event];
        }
      }
    },
    destroy: function () {
      var self = this, doc = self.doc;
      DomEvent.detach(doc, gestureStartEvent, self.onTouchStart, self);
      DomEvent.detach(doc, gestureMoveEvent, self.onTouchMove, self);
      DomEvent.detach(doc, gestureEndEvent, self.onTouchEnd, self);
    }
  };
  function setup(event) {
    addDocumentHandle(this, event);
  }
  function tearDown(event) {
    removeDocumentHandle(this, event);
  }
  function setupExtra(event) {
    setup.call(this, event);
    eventHandleMap[event].setup.apply(this, arguments);
  }
  function tearDownExtra(event) {
    tearDown.call(this, event);
    eventHandleMap[event].tearDown.apply(this, arguments);
  }
  function addDocumentHandle(el, event) {
    var doc = Dom.getDocument(el), handle = Dom.data(doc, key);
    if (!handle) {
      Dom.data(doc, key, handle = new DocumentHandler(doc));
    }
    if (event) {
      handle.addEventHandle(event);
    }
  }
  function removeDocumentHandle(el, event) {
    var doc = Dom.getDocument(el), handle = Dom.data(doc, key);
    if (handle) {
      if (event) {
        handle.removeEventHandle(event);
      }
      if (!handle.eventHandles.length) {
        handle.destroy();
        Dom.removeData(doc, key);
      }
    }
  }
  exports = function (events, config) {
    if (typeof events === 'string') {
      events = [events];
    }
    util.each(events, function (event) {
      var specialEvent = {};
      specialEvent.setup = config.setup ? setupExtra : setup;
      specialEvent.tearDown = config.tearDown ? tearDownExtra : tearDown;
      specialEvent.add = config.add;
      specialEvent.remove = config.remove;
      config.order = config.order || 100;
      eventHandleMap[event] = config;
      Special[event] = specialEvent;
    });
  };
  return exports;
}();
eventTouchLibUtilTouch = function (exports) {
  var noop = function () {
  };
  function Touch() {
  }
  Touch.prototype = {
    constructor: Touch,
    requiredTouchCount: 0,
    onTouchStart: function (e) {
      var self = this, requiredTouchesCount = self.requiredTouchCount, touches = e.touches, touchesCount = touches.length;
      if (touchesCount === requiredTouchesCount) {
        if (!self.isTracking) {
          self.isTracking = true;
          self.isStarted = false;
        }
        self.lastTouches = e.touches;
        self.startTime = e.timeStamp;
        return self.start(e);
      } else if (touchesCount > requiredTouchesCount) {
        self.onTouchEnd(e, true);
      }
      return undefined;
    },
    onTouchMove: function (e) {
      var self = this;
      if (!self.isTracking) {
        return undefined;
      }
      self.lastTouches = e.touches;
      return self.move(e);
    },
    onTouchEnd: function (e, moreTouches) {
      var self = this;
      if (self.isTracking) {
        self.isTracking = false;
        if (self.isStarted) {
          self.isStarted = false;
          self.end(e, moreTouches);
        }
      }
    },
    start: noop,
    move: noop,
    end: noop
  };
  exports = Touch;
  return exports;
}();
eventTouchLibUtilSingleTouch = function (exports) {
  var Touch = eventTouchLibUtilTouch;
  var util = utilBase;
  function SingleTouch() {
  }
  util.extend(SingleTouch, Touch, {
    requiredTouchCount: 1,
    start: function () {
      SingleTouch.superclass.start.apply(this, arguments);
      var self = this, touches = self.lastTouches;
      self.lastXY = {
        pageX: touches[0].pageX,
        pageY: touches[0].pageY
      };
    }
  });
  exports = SingleTouch;
  return exports;
}();
eventTouchLibUtilDoubleTouch = function (exports) {
  var Dom = domBase;
  var Touch = eventTouchLibUtilTouch;
  var util = utilBase;
  function DoubleTouch() {
  }
  util.extend(DoubleTouch, Touch, {
    requiredTouchCount: 2,
    getCommonTarget: function (e) {
      var touches = e.touches, t1 = touches[0].target, t2 = touches[1].target;
      if (t1 === t2) {
        return t1;
      }
      if (Dom.contains(t1, t2)) {
        return t1;
      }
      while (t2) {
        if (Dom.contains(t2, t1)) {
          return t2;
        }
        t2 = t2.parentNode;
      }
      return undefined;
    }
  });
  exports = DoubleTouch;
  return exports;
}();
eventTouchLibUtil = function (exports) {
  var addGestureEvent = eventTouchLibUtilAddEvent;
  exports = {
    addEvent: addGestureEvent,
    Touch: eventTouchLibUtilTouch,
    SingleTouch: eventTouchLibUtilSingleTouch,
    DoubleTouch: eventTouchLibUtilDoubleTouch
  };
  return exports;
}();
eventTouchLibSwipe = function (exports) {
  var util = utilBase;
  var Dom = domBase;
  var GestureUtil = eventTouchLibUtil;
  var addGestureEvent = GestureUtil.addEvent;
  var DomEvent = eventDomBase;
  var SingleTouch = GestureUtil.SingleTouch;
  var SWIPE = 'swipe', MAX_DURATION = 1000, MAX_OFFSET = 35, MIN_DISTANCE = 50;
  function fire(self, e, ing) {
    var touches = self.lastTouches, touch = touches[0], x = touch.pageX, y = touch.pageY, deltaX = x - self.startX, deltaY = y - self.startY, absDeltaX = Math.abs(deltaX), absDeltaY = Math.abs(deltaY), distance, direction, time = e.timeStamp;
    self.isStarted = 1;
    if (time - self.startTime > MAX_DURATION) {
      return false;
    }
    if (self.isVertical && absDeltaX > MAX_OFFSET) {
      self.isVertical = 0;
    }
    if (self.isHorizontal && absDeltaY > MAX_OFFSET) {
      self.isHorizontal = 0;
    }
    if (self.isVertical && self.isHorizontal) {
      if (absDeltaY > absDeltaX) {
        self.isHorizontal = 0;
      } else {
        self.isVertical = 0;
      }
    }
    if (!ing) {
      if (self.isVertical && absDeltaY < MIN_DISTANCE) {
        self.isVertical = 0;
      }
      if (self.isHorizontal && absDeltaX < MIN_DISTANCE) {
        self.isHorizontal = 0;
      }
    }
    if (self.isHorizontal) {
      direction = deltaX < 0 ? 'left' : 'right';
      distance = absDeltaX;
    } else if (self.isVertical) {
      direction = deltaY < 0 ? 'up' : 'down';
      distance = absDeltaY;
    } else {
      return false;
    }
    if (ing) {
      var prevent = e.originalEvent._ksSwipePrevent;
      if (prevent) {
        if (prevent === true || prevent[direction]) {
          e.preventDefault();
        }
      }
      return;
    }
    DomEvent.fire(touch.target, SWIPE, {
      originalEvent: e.originalEvent,
      pageX: touch.pageX,
      pageY: touch.pageY,
      which: 1,
      direction: direction,
      distance: distance,
      duration: (e.timeStamp - self.startTime) / 1000
    });
  }
  function Swipe() {
  }
  util.extend(Swipe, SingleTouch, {
    requiredGestureType: 'touch',
    start: function () {
      var self = this;
      Swipe.superclass.start.apply(self, arguments);
      var touch = self.lastTouches[0];
      self.isHorizontal = 1;
      self.isVertical = 1;
      self.startX = touch.pageX;
      self.startY = touch.pageY;
    },
    move: function (e) {
      Swipe.superclass.move.apply(this, arguments);
      return fire(this, e, 1);
    },
    end: function (e) {
      Swipe.superclass.end.apply(this, arguments);
      return fire(this, e, 0);
    }
  });
  function matchFilter(target, currentTarget, filter) {
    var ret = false;
    while (target !== currentTarget) {
      ret = Dom.test(target, filter);
      if (ret) {
        break;
      }
      target = target.parentNode;
    }
    return ret;
  }
  addGestureEvent([SWIPE], {
    handle: new Swipe(),
    add: function (observer) {
      var config = observer.config;
      var preventDefault = config.preventDefault;
      if (preventDefault) {
        var filter = config.filter;
        observer._preventFn = function (e) {
          if (!filter || matchFilter(e.target, e.currentTarget, filter)) {
            e._ksSwipePrevent = preventDefault;
          }
        };
        this.addEventListener('touchmove', observer._preventFn);
      }
    },
    remove: function (observer) {
      if (observer._preventFn) {
        this.removeEventListener('touchmove', observer._preventFn);
        observer._preventFn = null;
      }
    }
  });
  exports = { SWIPE: SWIPE };
  return exports;
}();
eventTouchLibTap = function (exports) {
  var GestureUtil = eventTouchLibUtil;
  var addGestureEvent = GestureUtil.addEvent;
  var DomEvent = eventDomBase;
  var SingleTouch = GestureUtil.SingleTouch;
  var util = utilBase;
  var SINGLE_TAP = 'singleTap', DOUBLE_TAP = 'doubleTap', HOLD = 'hold', TAP = 'tap', TAP_HOLD_DELAY = 1000, SINGLE_TAP_DELAY = 300, TOUCH_MOVE_SENSITIVITY = 5, DomEventObject = DomEvent.Object;
  var ios = /iPad|iPhone|iPod/.test(navigator.userAgent);
  function preventDefault(e) {
    e.preventDefault();
  }
  function clearTimers(self) {
    if (self.singleTapTimer) {
      clearTimeout(self.singleTapTimer);
      self.singleTapTimer = 0;
    }
    if (self.tapHoldTimer) {
      clearTimeout(self.tapHoldTimer);
      self.tapHoldTimer = 0;
    }
  }
  function Tap() {
    Tap.superclass.constructor.apply(this, arguments);
  }
  util.extend(Tap, SingleTouch, {
    start: function (e) {
      var self = this;
      Tap.superclass.start.call(self, e);
      clearTimers(self);
      var currentTouch = self.lastTouches[0];
      self.tapHoldTimer = setTimeout(function () {
        var eventObj = util.mix({
          which: 1,
          duration: (util.now() - e.timeStamp) / 1000
        }, self.lastXY);
        self.tapHoldTimer = 0;
        self.lastXY = 0;
        DomEvent.fire(currentTouch.target, HOLD, eventObj);
      }, TAP_HOLD_DELAY);
      self.isStarted = true;
      return undefined;
    },
    move: function () {
      var self = this, lastXY;
      if (!(lastXY = self.lastXY)) {
        return false;
      }
      var currentTouch = self.lastTouches[0];
      if (!currentTouch || Math.abs(currentTouch.pageX - lastXY.pageX) > TOUCH_MOVE_SENSITIVITY || Math.abs(currentTouch.pageY - lastXY.pageY) > TOUCH_MOVE_SENSITIVITY) {
        clearTimers(self);
        return false;
      }
      return undefined;
    },
    end: function (e, moreTouches) {
      var self = this, lastXY;
      clearTimers(self);
      if (moreTouches) {
        return;
      }
      if (!(lastXY = self.lastXY)) {
        return;
      }
      var touch = self.lastTouches[0];
      var target = touch.target;
      var eventObject = new DomEventObject(e.originalEvent);
      util.mix(eventObject, {
        type: TAP,
        which: 1,
        pageX: lastXY.pageX,
        pageY: lastXY.pageY,
        target: target,
        currentTarget: target
      });
      DomEvent.fire(target, TAP, eventObject);
      if (eventObject.isDefaultPrevented()) {
        if (ios) {
          e.preventDefault();
        } else {
          DomEvent.on(target.ownerDocument || target, 'click', {
            fn: preventDefault,
            once: 1
          });
        }
      }
      var lastEndTime = self.lastEndTime, time = e.timeStamp, duration;
      self.lastEndTime = time;
      if (lastEndTime) {
        duration = time - lastEndTime;
        if (duration < SINGLE_TAP_DELAY) {
          self.lastEndTime = 0;
          DomEvent.fire(target, DOUBLE_TAP, {
            pageX: lastXY.pageX,
            pageY: lastXY.pageY,
            which: 1,
            duration: duration / 1000
          });
          return;
        }
      }
      duration = time - self.startTime;
      if (duration > SINGLE_TAP_DELAY) {
        DomEvent.fire(target, SINGLE_TAP, {
          pageX: lastXY.pageX,
          pageY: lastXY.pageY,
          which: 1,
          duration: duration / 1000
        });
      } else {
        self.singleTapTimer = setTimeout(function () {
          DomEvent.fire(target, SINGLE_TAP, {
            pageX: lastXY.pageX,
            pageY: lastXY.pageY,
            which: 1,
            duration: (util.now() - self.startTime) / 1000
          });
        }, SINGLE_TAP_DELAY);
      }
    }
  });
  addGestureEvent([
    TAP,
    DOUBLE_TAP,
    SINGLE_TAP,
    HOLD
  ], { handle: new Tap() });
  exports = {
    TAP: TAP,
    SINGLE_TAP: SINGLE_TAP,
    DOUBLE_TAP: DOUBLE_TAP,
    HOLD: HOLD
  };
  return exports;
}();
eventTouchLibBasic = function (exports) {
  var DomEvent = eventDomBase;
  var GestureUtil = eventTouchLibUtil;
  var addGestureEvent = GestureUtil.addEvent;
  var BasicGesture = exports = {
    START: 'ksGestureStart',
    MOVE: 'ksGestureMove',
    END: 'ksGestureEnd'
  };
  function addBasicGestureEvent(event, onHandler) {
    var handle = { isActive: 1 };
    handle[onHandler] = function (e) {
      DomEvent.fire(e.target, event, e);
    };
    addGestureEvent(event, {
      order: 1,
      handle: handle
    });
  }
  addBasicGestureEvent(BasicGesture.START, 'onTouchStart');
  addBasicGestureEvent(BasicGesture.MOVE, 'onTouchMove');
  addBasicGestureEvent(BasicGesture.END, 'onTouchEnd');
  return exports;
}();
eventTouchIndex = function (exports) {
  var util = utilBase;
  var domEvent = eventDomBase;
  var BasicGestureEvent = eventTouchLibBasic;
  var SwipeGestureEvent = eventTouchLibSwipe;
  var TapGestureEvent = eventTouchLibTap;
  var GestureUtil = eventTouchLibUtil;
  var TouchEvent = {
    BasicGestureEvent: BasicGestureEvent,
    SwipeGestureEvent: SwipeGestureEvent,
    TapGestureEvent: TapGestureEvent
  };
  TouchEvent._gestureUtil = GestureUtil;
  util.mix(domEvent, TouchEvent);
  exports = TouchEvent;
  return exports;
}();
return eventTouchIndex;
});define("node-anim", ["node-base",'anim','util'], function(require) {
var nodeBase = require("node-base");
var animTransition = require('anim');
var utilBase = require('util');
//! Copyright 2015, node-anim@6.1.2 MIT Licensed, build time: Thu, 29 Oct 2015 12:26:01 GMT 
/*
combined modules:
node-anim
node-anim/lib/attach
*/
var nodeAnimLibAttach, nodeAnimIndex;
nodeAnimLibAttach = function (exports) {
  /**
   * @ignore
   * anim-node-plugin
   * @author yiminghe@gmail.com,
   *         lifesinger@gmail.com,
   *         qiaohua@taobao.com,
   */
  var NodeBase = nodeBase;
  var Anim = animTransition;
  var util = utilBase;
  var Dom = NodeBase.Dom;
  var FX = [
    // height animations
    [
      'height',
      'margin-top',
      'margin-bottom',
      'padding-top',
      'padding-bottom'
    ],
    // width animations
    [
      'width',
      'margin-left',
      'margin-right',
      'padding-left',
      'padding-right'
    ],
    // opacity animations
    ['opacity']
  ];
  function getFxs(type, num, from) {
    var ret = [], obj = {};
    for (var i = from || 0; i < num; i++) {
      ret.push.apply(ret, FX[i]);
    }
    for (i = 0; i < ret.length; i++) {
      obj[ret[i]] = type;
    }
    return obj;
  }
  util.augment(NodeBase, {
    /**
     * animate for current node list.
     * @chainable
     * @member KISSY.Node
     */
    animate: function () {
      var self = this, l = self.length, needClone = self.length > 1, originArgs = util.makeArray(arguments);
      var cfg = originArgs[0];
      var AnimConstructor = Anim;
      if (cfg.to) {
        AnimConstructor = cfg.Anim || Anim;
      } else {
        cfg = originArgs[1];
        if (cfg) {
          AnimConstructor = cfg.Anim || Anim;
        }
      }
      for (var i = 0; i < l; i++) {
        var elem = self[i];
        var args = needClone ? util.clone(originArgs) : originArgs, arg0 = args[0];
        if (arg0.to) {
          arg0.node = elem;
          new AnimConstructor(arg0).run();
        } else {
          AnimConstructor.apply(undefined, [elem].concat(args)).run();
        }
      }
      return self;
    },
    /**
     * stop anim of current node list.
     * @param {Boolean} [end] see {@link KISSY.Anim#static-method-stop}
     * @param [clearQueue]
     * @param [queue]
     * @chainable
     * @member KISSY.Node
     */
    stop: function (end, clearQueue, queue) {
      var self = this;
      util.each(self, function (elem) {
        Anim.stop(elem, end, clearQueue, queue);
      });
      return self;
    },
    /**
     * pause anim of current node list.
     * @param {Boolean} end see {@link KISSY.Anim#static-method-pause}
     * @param queue
     * @chainable
     * @member KISSY.Node
     */
    pause: function (end, queue) {
      var self = this;
      util.each(self, function (elem) {
        Anim.pause(elem, queue);
      });
      return self;
    },
    /**
     * resume anim of current node list.
     * @param {Boolean} end see {@link KISSY.Anim#static-method-resume}
     * @param queue
     * @chainable
     * @member KISSY.Node
     */
    resume: function (end, queue) {
      var self = this;
      util.each(self, function (elem) {
        Anim.resume(elem, queue);
      });
      return self;
    },
    /**
     * whether one of current node list is animating.
     * @return {Boolean}
     * @member KISSY.Node
     */
    isRunning: function () {
      var self = this;
      for (var i = 0; i < self.length; i++) {
        if (Anim.isRunning(self[i])) {
          return true;
        }
      }
      return false;
    },
    /**
     * whether one of current node list 's animation is paused.
     * @return {Boolean}
     * @member KISSY.Node
     */
    isPaused: function () {
      var self = this;
      for (var i = 0; i < self.length; i++) {
        if (Anim.isPaused(self[i])) {
          return true;
        }
      }
      return false;
    }
  });
  /**
   * animate show effect for current node list.
   * @param {Number} duration duration of effect
   * @param {Function} [complete] callback function on anim complete.
   * @param {String|Function} [easing] easing type or custom function.
   * @chainable
   * @member KISSY.Node
   * @method show
   */
  /**
   * animate hide effect for current node list.
   * @param {Number} duration duration of effect
   * @param {Function} [complete] callback function on anim complete.
   * @param {String|Function} [easing] easing type or custom function.
   * @chainable
   * @member KISSY.Node
   * @method hide
   */
  /**
   * toggle show and hide effect for current node list.
   * @param {Number} duration duration of effect
   * @param {Function} [complete] callback function on anim complete.
   * @param {String|Function} [easing] easing type or custom function.
   * @chainable
   * @member KISSY.Node
   * @method toggle
   */
  /**
   * animate fadeIn effect for current node list.
   * @param {Number} duration duration of effect
   * @param {Function} [complete] callback function on anim complete.
   * @param {String|Function} [easing] easing type or custom function.
   * @chainable
   * @member KISSY.Node
   * @method fadeIn
   */
  /**
   * animate fadeOut effect for current node list.
   * @param {Number} duration duration of effect
   * @param {Function} [complete] callback function on anim complete.
   * @param {String|Function} [easing] easing type or custom function.
   * @chainable
   * @member KISSY.Node
   * @method fadeOut
   */
  /**
   * toggle fadeIn and fadeOut effect for current node list.
   * @param {Number} duration duration of effect
   * @param {Function} [complete] callback function on anim complete.
   * @param {String|Function} [easing] easing type or custom function.
   * @chainable
   * @member KISSY.Node
   * @method fadeToggle
   */
  /**
   * animate slideUp effect for current node list.
   * @param {Number} duration duration of effect
   * @param {Function} [complete] callback function on anim complete.
   * @param {String|Function} [easing] easing type or custom function.
   * @chainable
   * @member KISSY.Node
   * @method slideUp
   */
  /**
   * animate slideDown effect for current node list.
   * @param {Number} duration duration of effect
   * @param {Function} [complete] callback function on anim complete.
   * @param {String|Function} [easing] easing type or custom function.
   * @chainable
   * @member KISSY.Node
   * @method slideDown
   */
  /**
   * toggle slideUp and slideDown effect for current node list.
   * @param {Number} duration duration of effect
   * @param {Function} [complete] callback function on anim complete.
   * @param {String|Function} [easing] easing type or custom function.
   * @chainable
   * @member KISSY.Node
   * @method slideToggle
   */
  util.each({
    show: getFxs('show', 3),
    hide: getFxs('hide', 3),
    toggle: getFxs('toggle', 3),
    fadeIn: getFxs('show', 3, 2),
    fadeOut: getFxs('hide', 3, 2),
    fadeToggle: getFxs('toggle', 3, 2),
    slideDown: getFxs('show', 1),
    slideUp: getFxs('hide', 1),
    slideToggle: getFxs('toggle', 1)
  }, function (v, k) {
    NodeBase.prototype[k] = function (duration, complete, easing) {
      var self = this;
      // 没有参数时，调用 Dom 中的对应方法
      if (Dom[k] && !duration) {
        Dom[k](self);
      } else {
        var AnimConstructor = Anim;
        if (typeof duration === 'object') {
          AnimConstructor = duration.Anim || Anim;
        }
        util.each(self, function (elem) {
          new AnimConstructor(elem, v, duration, easing, complete).run();
        });
      }
      return self;
    };
  });
  exports = NodeBase;
  return exports;
}();
nodeAnimIndex = function (exports) {
  exports = nodeAnimLibAttach;
  return exports;
}();
return nodeAnimIndex;
});define("anim-transition", ['util','dom',"anim-base","feature"], function(require) {
var utilBase = require('util');
var domBase = require('dom');
var animBase = require("anim-base");
var feature = require("feature");
//! Copyright 2015, anim-transition@6.1.2 MIT Licensed, build time: Thu, 29 Oct 2015 06:57:16 GMT 
/*
combined modules:
anim-transition
anim-transition/lib/transition
*/
var animTransitionLibTransition, animTransitionIndex;
animTransitionLibTransition = function (exports) {
  /**
   * animation using css transition
   * @author yiminghe@gmail.com
   * @ignore
   */
  var util = utilBase;
  var Dom = domBase;
  var AnimBase = animBase;
  var Feature = feature;
  var getCssVendorInfo = Feature.getCssVendorInfo;
  var transitionVendorInfo = getCssVendorInfo('transition');
  function genTransition(propsData) {
    var str = '';
    util.each(propsData, function (propData, prop) {
      if (str) {
        str += ',';
      }
      str += prop + ' ' + propData.duration + 's ' + propData.easing + ' ' + propData.delay + 's';
    });
    return str;
  }
  function unCamelCase(propertyName) {
    return propertyName.replace(/[A-Z]/g, function (m) {
      return '-' + m.toLowerCase();
    });
  }
  function TransitionAnim(node, to, duration, easing, complete) {
    var self = this;
    if (!(self instanceof TransitionAnim)) {
      return new TransitionAnim(node, to, duration, easing, complete);
    }
    TransitionAnim.superclass.constructor.apply(self, arguments);
  }
  if (transitionVendorInfo) {
    var TRANSITION = transitionVendorInfo.propertyName;
    var DEFAULT_EASING = 'linear';
    var css3Anim = {
      ease: 1,
      linear: 1,
      'ease-in': 1,
      'ease-out': 1,
      'ease-in-out': 1
    };
    util.extend(TransitionAnim, AnimBase, {
      prepareFx: function () {
        var self = this, propsData = self._propsData;
        var newProps = {};
        var val;
        var vendorInfo;
        for (var propertyName in propsData) {
          val = propsData[propertyName];
          if (typeof val.easing === 'string') {
            if (!util.startsWith(val.easing, 'cubic-bezier') && !css3Anim[val.easing]) {
              val.easing = DEFAULT_EASING;
            }
          } else {
            val.easing = DEFAULT_EASING;
          }
          vendorInfo = getCssVendorInfo(propertyName);
          if (!vendorInfo) {
            console.error('anim: unsupported css property for transition anim: ' + propertyName);
            continue;
          }
          newProps[unCamelCase(vendorInfo.propertyName)] = propsData[propertyName];
        }
        self._propsData = newProps;
      },
      doStart: function () {
        var self = this, node = self.node, elStyle = node.style, _propsData = self._propsData, original = elStyle[TRANSITION], totalDuration = 0, propsCss = {};
        util.each(_propsData, function (propData, prop) {
          var v = propData.value;
          // hack, for to reflow?
          Dom.css(node, prop, Dom.css(node, prop));
          propsCss[prop] = v;
          totalDuration = Math.max(propData.duration + propData.delay, totalDuration);
        });
        // chrome none
        // firefox none 0s ease 0s
        if (original.indexOf('none') !== -1) {
          original = '';
        } else if (original) {
          original += ',';
        }
        elStyle[TRANSITION] = original + genTransition(_propsData);
        // bug when set left on relative element
        setTimeout(function () {
          Dom.css(node, propsCss);
        }, 0);
        // timer is more reliable and can deal with short hand css properties
        self._transitionEndTimer = setTimeout(function () {
          self.stop(true);
        }, totalDuration * 1000);
      },
      beforeResume: function () {
        // note: pause/resume in css transition is not smooth as js timer
        // already run time before pause
        var self = this, propsData = self._propsData, tmpPropsData = util.merge(propsData), runTime = self._runTime / 1000;
        util.each(tmpPropsData, function (propData, prop) {
          var tRunTime = runTime;
          if (propData.delay >= tRunTime) {
            propData.delay -= tRunTime;
          } else {
            tRunTime -= propData.delay;
            propData.delay = 0;
            if (propData.duration >= tRunTime) {
              propData.duration -= tRunTime;
            } else {
              delete propsData[prop];
            }
          }
        });
      },
      doStop: function (finish) {
        var self = this, node = self.node, elStyle = node.style, _propsData = self._propsData, propList = [], clear, propsCss = {};
        if (self._transitionEndTimer) {
          clearTimeout(self._transitionEndTimer);
          self._transitionEndTimer = null;
        }
        util.each(_propsData, function (propData, prop) {
          if (!finish) {
            propsCss[prop] = Dom.css(node, prop);
          }
          propList.push(prop);
        });
        // firefox need set transition and need set none
        clear = util.trim(elStyle[TRANSITION].replace(new RegExp('(^|,)' + '\\s*(?:' + propList.join('|') + ')\\s+[^,]+', 'gi'), '$1')).replace(/^,|,,|,$/g, '') || 'none';
        elStyle[TRANSITION] = clear;
        Dom.css(node, propsCss);
      }
    });
    util.mix(TransitionAnim, AnimBase.Statics);
    // bad
    exports = TransitionAnim;
    TransitionAnim._name_ = 'TransitionAnim';
  } else {
    exports = null;
  }
  return exports;
}();
animTransitionIndex = function (exports) {
  var AnimTransition = animTransitionLibTransition;
  exports = AnimTransition;
  return exports;
}();
return animTransitionIndex;
});define("anim-base", ['dom','util',"promise"], function(require) {
var domBase = require('dom');
var utilBase = require('util');
var promise = require("promise");
//! Copyright 2015, anim-base@6.1.1 MIT Licensed, build time: Wed, 04 Nov 2015 04:59:57 GMT 
/*
combined modules:
anim-base
anim-base/lib/base
anim-base/lib/base/utils
anim-base/lib/base/queue
*/
var animBaseLibBaseQueue, animBaseLibBaseUtils, animBaseLibBase, animBaseIndex;
animBaseLibBaseQueue = function (exports) {
  /**
   * @ignore queue data structure
   * @author yiminghe@gmail.com
   */
  var Dom = domBase;
  var util = utilBase;
  // 队列集合容器
  var queueCollectionKey = util.guid('ks-queue-' + util.now() + '-'),
    // 默认队列
    queueKey = util.guid('ks-queue-' + util.now() + '-'), Q;
  function getQueue(node, name, readOnly) {
    name = name || queueKey;
    var qu, quCollection = Dom.data(node, queueCollectionKey);
    if (!quCollection && !readOnly) {
      Dom.data(node, queueCollectionKey, quCollection = {});
    }
    if (quCollection) {
      qu = quCollection[name];
      if (!qu && !readOnly) {
        qu = quCollection[name] = [];
      }
    }
    return qu;
  }
  Q = {
    queueCollectionKey: queueCollectionKey,
    queue: function (node, queue, item) {
      var qu = getQueue(node, queue);
      qu.push(item);
      return qu;
    },
    remove: function (node, queue, item) {
      var qu = getQueue(node, queue, 1), index;
      if (qu) {
        index = util.indexOf(item, qu);
        if (index > -1) {
          qu.splice(index, 1);
        }
      }
      if (qu && !qu.length) {
        // remove queue data
        Q.clearQueue(node, queue);
      }
      return qu;
    },
    clearQueues: function (node) {
      Dom.removeData(node, queueCollectionKey);
    },
    clearQueue: function clearQueue(node, queue) {
      queue = queue || queueKey;
      var quCollection = Dom.data(node, queueCollectionKey);
      if (quCollection) {
        delete quCollection[queue];
      }
      if (util.isEmptyObject(quCollection)) {
        Dom.removeData(node, queueCollectionKey);
      }
    },
    dequeue: function (node, queue) {
      var qu = getQueue(node, queue, 1);
      if (qu) {
        qu.shift();
        if (!qu.length) {
          // remove queue data
          Q.clearQueue(node, queue);
        }
      }
      return qu;
    }
  };
  exports = Q;
  return exports;
}();
animBaseLibBaseUtils = function (exports) {
  var Q = animBaseLibBaseQueue, util = utilBase, Dom = domBase;
  var runningKey = util.guid('ks-anim-unqueued-' + util.now() + '-');
  function saveRunningAnim(anim) {
    var node = anim.node, allRunning = Dom.data(node, runningKey);
    if (!allRunning) {
      Dom.data(node, runningKey, allRunning = {});
    }
    allRunning[util.stamp(anim)] = anim;
  }
  function removeRunningAnim(anim) {
    var node = anim.node, allRunning = Dom.data(node, runningKey);
    if (allRunning) {
      delete allRunning[util.stamp(anim)];
      if (util.isEmptyObject(allRunning)) {
        Dom.removeData(node, runningKey);
      }
    }
  }
  function isAnimRunning(anim) {
    var node = anim.node, allRunning = Dom.data(node, runningKey);
    if (allRunning) {
      return !!allRunning[util.stamp(anim)];
    }
    return 0;
  }
  var pausedKey = util.guid('ks-anim-paused-' + util.now() + '-');
  function savePausedAnim(anim) {
    var node = anim.node, paused = Dom.data(node, pausedKey);
    if (!paused) {
      Dom.data(node, pausedKey, paused = {});
    }
    paused[util.stamp(anim)] = anim;
  }
  function removePausedAnim(anim) {
    var node = anim.node, paused = Dom.data(node, pausedKey);
    if (paused) {
      delete paused[util.stamp(anim)];
      if (util.isEmptyObject(paused)) {
        Dom.removeData(node, pausedKey);
      }
    }
  }
  function isAnimPaused(anim) {
    var node = anim.node, paused = Dom.data(node, pausedKey);
    if (paused) {
      return !!paused[util.stamp(anim)];
    }
    return 0;
  }
  function pauseOrResumeQueue(node, queue, action) {
    var allAnims = Dom.data(node, action === 'resume' ? pausedKey : runningKey), anims = util.merge(allAnims);
    util.each(anims, function (anim) {
      if (queue === undefined || anim.config.queue === queue) {
        anim[action]();
      }
    });
  }
  exports = {
    saveRunningAnim: saveRunningAnim,
    removeRunningAnim: removeRunningAnim,
    isAnimPaused: isAnimPaused,
    removePausedAnim: removePausedAnim,
    savePausedAnim: savePausedAnim,
    isAnimRunning: isAnimRunning,
    isElPaused: function (node) {
      var paused = Dom.data(node, pausedKey);
      return paused && !util.isEmptyObject(paused);
    },
    isElRunning: function (node) {
      var allRunning = Dom.data(node, runningKey);
      return allRunning && !util.isEmptyObject(allRunning);
    },
    pauseOrResumeQueue: pauseOrResumeQueue,
    stopEl: function (node, end, clearQueue, queue) {
      if (clearQueue) {
        if (queue === undefined) {
          Q.clearQueues(node);
        } else if (queue !== false) {
          Q.clearQueue(node, queue);
        }
      }
      var allRunning = Dom.data(node, runningKey), anims = util.merge(allRunning);
      util.each(anims, function (anim) {
        if (queue === undefined || anim.config.queue === queue) {
          anim.stop(end);
        }
      });
    }
  };
  return exports;
}();
animBaseLibBase = function (exports) {
  var Dom = domBase, Utils = animBaseLibBaseUtils, Q = animBaseLibBaseQueue;
  var Promise = promise;
  var util = utilBase, NodeType = Dom.NodeType, camelCase = util.camelCase, noop = util.noop, specialVals = {
      toggle: 1,
      hide: 1,
      show: 1
    };
  var undef;
  var defaultConfig = {
    duration: 1,
    easing: 'linear'
  };
  function syncComplete(self) {
    var _backupProps, complete = self.config.complete;
    if (!util.isEmptyObject(_backupProps = self._backupProps)) {
      Dom.css(self.node, _backupProps);
    }
    if (complete) {
      complete.call(self);
    }
  }
  function AnimBase(node, to, duration, easing, complete) {
    var self = this;
    var config;
    if (node.node) {
      config = node;
    } else {
      if (util.isPlainObject(duration)) {
        config = util.clone(duration);
      } else {
        config = { complete: complete };
        if (duration) {
          config.duration = duration;
        }
        if (easing) {
          config.easing = easing;
        }
      }
      config.node = node;
      config.to = to;
    }
    config = util.merge(defaultConfig, config);
    AnimBase.superclass.constructor.call(self);
    Promise.Defer(self);
    self.config = config;
    node = config.node;
    if (!util.isPlainObject(node)) {
      node = Dom.get(config.node);
    }
    self.node = self.el = node;
    self._backupProps = {};
    self._propsData = {};
    var newTo = {};
    to = config.to;
    for (var prop in to) {
      newTo[camelCase(prop)] = to[prop];
    }
    config.to = newTo;
  }
  util.extend(AnimBase, Promise, {
    prepareFx: noop,
    runInternal: function () {
      var self = this, config = self.config, node = self.node, val, _backupProps = self._backupProps, _propsData = self._propsData, to = config.to, defaultDelay = config.delay || 0, defaultDuration = config.duration;
      Utils.saveRunningAnim(self);
      util.each(to, function (val, prop) {
        if (!util.isPlainObject(val)) {
          val = { value: val };
        }
        _propsData[prop] = util.mix({
          delay: defaultDelay,
          easing: config.easing,
          frame: config.frame,
          duration: defaultDuration
        }, val);
      });
      if (node.nodeType === NodeType.ELEMENT_NODE) {
        if (to.width || to.height) {
          var elStyle = node.style;
          util.mix(_backupProps, {
            overflow: elStyle.overflow,
            'overflow-x': elStyle.overflowX,
            'overflow-y': elStyle.overflowY
          });
          elStyle.overflow = 'hidden';
        }
        var exit, hidden;
        util.each(_propsData, function (_propData, prop) {
          val = _propData.value;
          if (specialVals[val]) {
            if (hidden === undef) {
              hidden = Dom.css(node, 'display') === 'none';
            }
            if (val === 'hide' && hidden || val === 'show' && !hidden) {
              self.stop(true);
              exit = false;
              return exit;
            }
            _backupProps[prop] = Dom._style(node, prop);
            if (val === 'toggle') {
              val = hidden ? 'show' : 'hide';
            }
            if (val === 'hide') {
              _propData.value = 0;
              _backupProps.display = 'none';
            } else {
              _propData.value = Dom.css(node, prop);
              Dom.css(node, prop, 0);
              Dom.show(node);
            }
          }
          return undefined;
        });
        if (exit === false) {
          return;
        }
      }
      self.startTime = util.now();
      if (util.isEmptyObject(_propsData)) {
        self.__totalTime = defaultDuration * 1000;
        self.__waitTimeout = setTimeout(function () {
          self.stop(true);
        }, self.__totalTime);
      } else {
        self.prepareFx();
        self.doStart();
      }
    },
    isRunning: function () {
      return Utils.isAnimRunning(this);
    },
    isPaused: function () {
      return Utils.isAnimPaused(this);
    },
    pause: function () {
      var self = this;
      if (self.isRunning()) {
        self._runTime = util.now() - self.startTime;
        self.__totalTime -= self._runTime;
        Utils.removeRunningAnim(self);
        Utils.savePausedAnim(self);
        if (self.__waitTimeout) {
          clearTimeout(self.__waitTimeout);
        } else {
          self.doStop();
        }
      }
      return self;
    },
    doStop: noop,
    doStart: noop,
    resume: function () {
      var self = this;
      if (self.isPaused()) {
        self.startTime = util.now() - self._runTime;
        Utils.removePausedAnim(self);
        Utils.saveRunningAnim(self);
        if (self.__waitTimeout) {
          self.__waitTimeout = setTimeout(function () {
            self.stop(true);
          }, self.__totalTime);
        } else {
          self.beforeResume();
          self.doStart();
        }
      }
      return self;
    },
    beforeResume: noop,
    run: function () {
      var self = this, q, queue = self.config.queue;
      if (queue === false) {
        self.runInternal();
      } else {
        q = Q.queue(self.node, queue, self);
        if (q.length === 1) {
          self.runInternal();
        }
      }
      return self;
    },
    stop: function (finish) {
      var self = this, node = self.node, q, queue = self.config.queue;
      if (self.isResolved() || self.isRejected()) {
        return self;
      }
      if (self.__waitTimeout) {
        clearTimeout(self.__waitTimeout);
        self.__waitTimeout = 0;
      }
      if (!self.isRunning() && !self.isPaused()) {
        if (queue !== false) {
          Q.remove(node, queue, self);
        }
        return self;
      }
      self.doStop(finish);
      Utils.removeRunningAnim(self);
      Utils.removePausedAnim(self);
      var defer = self.defer;
      if (finish) {
        syncComplete(self);
        defer.resolve([self]);
      } else {
        defer.reject([self]);
      }
      if (queue !== false) {
        q = Q.dequeue(node, queue);
        if (q && q[0]) {
          q[0].runInternal();
        }
      }
      return self;
    }
  });
  var Statics = AnimBase.Statics = {
    isRunning: Utils.isElRunning,
    isPaused: Utils.isElPaused,
    stop: Utils.stopEl,
    Q: Q
  };
  util.each([
    'pause',
    'resume'
  ], function (action) {
    Statics[action] = function (node, queue) {
      if (queue === null || typeof queue === 'string' || queue === false) {
        return Utils.pauseOrResumeQueue(node, queue, action);
      }
      return Utils.pauseOrResumeQueue(node, undefined, action);
    };
  });
  exports = AnimBase;
  return exports;
}();
animBaseIndex = function (exports) {
  var AnimBase = animBaseLibBase;
  exports = AnimBase;
  return exports;
}();
return animBaseIndex;
});